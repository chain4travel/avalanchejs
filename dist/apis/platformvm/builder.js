"use strict";
/**
 * @packageDocumentation
 * @module API-PlatformVM-Builder
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Builder = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const buffer_1 = require("buffer/");
const common_1 = require("../../common");
const utils_1 = require("../../utils");
const errors_1 = require("../../utils/errors");
const _1 = require(".");
const create_hash_1 = __importDefault(require("create-hash"));
const adddepositoffertx_1 = require("../../apis/platformvm/adddepositoffertx");
const zero = new bn_js_1.default(0);
class Builder {
    constructor(spender, caminoEnabled) {
        /**
         * Creates an [[UnsignedTx]] wrapping a [[BaseTx]]. For more granular control, you may create your own
         * [[UnsignedTx]] wrapping a [[BaseTx]] manually (with their corresponding [[TransferableInput]]s and [[TransferableOutput]]s).
         *
         * @param networkID The number representing NetworkID of the node
         * @param blockchainID The {@link https://github.com/feross/buffer|Buffer} representing the BlockchainID for the transaction
         * @param amount The amount of the asset to be spent in its smallest denomination, represented as {@link https://github.com/indutny/bn.js/|BN}.
         * @param assetID {@link https://github.com/feross/buffer|Buffer} of the asset ID for the UTXO
         * @param toAddresses The addresses to send the funds
         * @param fromSigner The addresses being used to send and verify the funds from the UTXOs {@link https://github.com/feross/buffer|Buffer}
         * @param changeAddresses Optional. The addresses that can spend the change remaining from the spent UTXOs. Default: toAddresses
         * @param fee Optional. The amount of fees to burn in its smallest denomination, represented as {@link https://github.com/indutny/bn.js/|BN}
         * @param feeAssetID Optional. The assetID of the fees being burned. Default: assetID
         * @param memo Optional. Contains arbitrary data, up to 256 bytes
         * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
         * @param locktime Optional. The locktime field created in the resulting outputs
         * @param toThreshold Optional. The number of signatures required to spend the funds in the resultant UTXO
         * @param changeThreshold Optional. The number of signatures required to spend the funds in the resultant change UTXO
         *
         * @returns An unsigned transaction created from the passed in parameters.
         *
         */
        this.buildBaseTx = (networkID, blockchainID, amount, amountAssetID, toAddresses, fromSigner, changeAddresses = undefined, fee = zero, feeAssetID = undefined, memo = undefined, asOf = zero, lockTime = zero, toThreshold = 1, changeThreshold = 1) => __awaiter(this, void 0, void 0, function* () {
            if (toThreshold > toAddresses.length) {
                /* istanbul ignore next */
                throw new errors_1.ThresholdError("Error - UTXOSet.buildBaseTx: threshold is greater than number of addresses");
            }
            if (typeof changeAddresses === "undefined") {
                changeAddresses = [];
            }
            if (typeof feeAssetID === "undefined") {
                feeAssetID = amountAssetID;
            }
            if (amount.eq(zero)) {
                return undefined;
            }
            const aad = new _1.AssetAmountDestination(toAddresses, toThreshold, fromSigner.from, fromSigner.signer, changeAddresses, changeThreshold);
            if (amountAssetID.toString("hex") === feeAssetID.toString("hex")) {
                aad.addAssetAmount(amountAssetID, amount, fee);
            }
            else {
                aad.addAssetAmount(amountAssetID, amount, zero);
                if (this._feeCheck(fee, feeAssetID)) {
                    aad.addAssetAmount(feeAssetID, zero, fee);
                }
            }
            let ins = [];
            let outs = [];
            let owners = [];
            const minSpendableErr = yield this.spender.getMinimumSpendable(aad, asOf, lockTime, "Unlocked");
            if (typeof minSpendableErr === "undefined") {
                ins = aad.getInputs();
                outs = aad.getAllOutputs();
                owners = aad.getOutputOwners();
            }
            else {
                throw minSpendableErr;
            }
            const baseTx = new _1.BaseTx(networkID, blockchainID, outs, ins, memo);
            baseTx.setOutputOwners(owners);
            return new _1.UnsignedTx(baseTx);
        });
        /**
         * Creates an unsigned ImportTx transaction.
         *
         * @param networkID The number representing NetworkID of the node
         * @param blockchainID The {@link https://github.com/feross/buffer|Buffer} representing the BlockchainID for the transaction
         * @param toAddresses The addresses to send the funds
         * @param fromSigner The addresses being used to send and verify the funds from the UTXOs {@link https://github.com/feross/buffer|Buffer}
         * @param changeAddresses Optional. The addresses that can spend the change remaining from the spent UTXOs. Default: toAddresses
         * @param importIns An array of [[TransferableInput]]s being imported
         * @param sourceChain A {@link https://github.com/feross/buffer|Buffer} for the chainid where the imports are coming from.
         * @param fee Optional. The amount of fees to burn in its smallest denomination, represented as {@link https://github.com/indutny/bn.js/|BN}. Fee will come from the inputs first, if they can.
         * @param feeAssetID Optional. The assetID of the fees being burned.
         * @param memo Optional contains arbitrary bytes, up to 256 bytes
         * @param locktime Optional. The locktime field created in the resulting outputs
         * @param toThreshold Optional. The number of signatures required to spend the funds in the received UTXO
         * @param changeThreshold Optional. The number of signatures required to spend the funds in the resultant change UTXO
         *
         * @returns An unsigned transaction created from the passed in parameters.
         *
         */
        this.buildImportTx = (networkID, blockchainID, toAddresses, fromSigner, changeAddresses, atomics, sourceChain = undefined, fee = zero, feeAssetID = undefined, memo = undefined, asOf = zero, locktime = zero, toThreshold = 1, changeThreshold = 1) => __awaiter(this, void 0, void 0, function* () {
            let ins = [];
            let outs = [];
            let owners = [];
            const importOwners = [];
            if (typeof fee === "undefined") {
                fee = zero.clone();
            }
            const importIns = [];
            let feepaid = new bn_js_1.default(0);
            let feeAssetStr = feeAssetID.toString("hex");
            for (let i = 0; i < atomics.length; i++) {
                const utxo = atomics[`${i}`];
                const assetID = utxo.getAssetID();
                const output = utxo.getOutput();
                let amt = output.getAmount().clone();
                let infeeamount = amt.clone();
                let assetStr = assetID.toString("hex");
                if (typeof feeAssetID !== "undefined" &&
                    fee.gt(zero) &&
                    feepaid.lt(fee) &&
                    assetStr === feeAssetStr) {
                    feepaid = feepaid.add(infeeamount);
                    if (feepaid.gte(fee)) {
                        infeeamount = feepaid.sub(fee);
                        feepaid = fee.clone();
                    }
                    else {
                        infeeamount = zero.clone();
                    }
                }
                const txid = utxo.getTxID();
                const outputidx = utxo.getOutputIdx();
                const input = new _1.SECPTransferInput(amt);
                const xferin = new _1.TransferableInput(txid, outputidx, assetID, input);
                const from = output.getAddresses();
                const spenders = output.getSpenders(from);
                for (let j = 0; j < spenders.length; j++) {
                    const idx = output.getAddressIdx(spenders[`${j}`]);
                    if (idx === -1) {
                        /* istanbul ignore next */
                        throw new errors_1.AddressError("Error - UTXOSet.buildImportTx: no such " +
                            `address in output: ${spenders[`${j}`]}`);
                    }
                    xferin.getInput().addSignatureIdx(idx, spenders[`${j}`]);
                }
                importOwners.push(new common_1.OutputOwners(output.getAddresses(), output.getLocktime(), output.getThreshold()));
                importIns.push(xferin);
                //add extra outputs for each amount (calculated from the imported inputs), minus fees
                if (infeeamount.gt(zero)) {
                    const spendout = (0, _1.SelectOutputClass)(output.getOutputID(), infeeamount, toAddresses, locktime, toThreshold);
                    const xferout = new _1.TransferableOutput(assetID, spendout);
                    outs.push(xferout);
                }
            }
            // get remaining fees from the provided addresses
            let feeRemaining = fee.sub(feepaid);
            if (feeRemaining.gt(zero) && this._feeCheck(feeRemaining, feeAssetID)) {
                const aad = new _1.AssetAmountDestination(toAddresses, toThreshold, fromSigner.from, fromSigner.signer, changeAddresses, changeThreshold);
                aad.addAssetAmount(feeAssetID, zero, feeRemaining);
                const minSpendableErr = yield this.spender.getMinimumSpendable(aad, asOf, locktime, "Unlocked");
                if (typeof minSpendableErr === "undefined") {
                    ins = aad.getInputs();
                    outs = aad.getAllOutputs();
                    owners = aad.getOutputOwners();
                    owners.push(...importOwners);
                }
                else {
                    throw minSpendableErr;
                }
            }
            const baseTx = new _1.ImportTx(networkID, blockchainID, outs, ins, memo, sourceChain, importIns);
            baseTx.setOutputOwners(owners);
            return new _1.UnsignedTx(baseTx);
        });
        /**
         * Creates an unsigned ExportTx transaction.
         *
         * @param networkID The number representing NetworkID of the node
         * @param blockchainID The {@link https://github.com/feross/buffer|Buffer} representing the BlockchainID for the transaction
         * @param amount The amount being exported as a {@link https://github.com/indutny/bn.js/|BN}
         * @param avaxAssetID {@link https://github.com/feross/buffer|Buffer} of the asset ID for AVAX
         * @param toAddresses An array of addresses as {@link https://github.com/feross/buffer|Buffer} who recieves the AVAX
         * @param fromSigner The addresses being used to send and verify the funds from the UTXOs {@link https://github.com/feross/buffer|Buffer}
         * @param changeAddresses An array of addresses as {@link https://github.com/feross/buffer|Buffer} who gets the change leftover of the AVAX
         * @param destinationChain Optional. A {@link https://github.com/feross/buffer|Buffer} for the chainid where to send the asset.
         * @param fee Optional. The amount of fees to burn in its smallest denomination, represented as {@link https://github.com/indutny/bn.js/|BN}
         * @param feeAssetID Optional. The assetID of the fees being burned.
         * @param memo Optional contains arbitrary bytes, up to 256 bytes
         * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
         * @param locktime Optional. The locktime field created in the resulting outputs
         * @param toThreshold Optional. The number of signatures required to spend the funds in the received UTXO
         * @param changeThreshold Optional. The number of signatures required to spend the funds in the resultant change UTXO
         *
         * @returns An unsigned transaction created from the passed in parameters.
         *
         */
        this.buildExportTx = (networkID, blockchainID, amount, amountAssetID, toAddresses, fromSigner, destinationChain, changeAddresses = undefined, fee = zero, feeAssetID = undefined, memo = undefined, asOf = zero, locktime = zero, toThreshold = 1, changeThreshold = 1) => __awaiter(this, void 0, void 0, function* () {
            let ins = [];
            let outs = [];
            let owners = [];
            if (typeof changeAddresses === "undefined") {
                changeAddresses = toAddresses;
            }
            if (amount.eq(zero)) {
                return undefined;
            }
            if (typeof feeAssetID === "undefined") {
                feeAssetID = amountAssetID;
            }
            else if (feeAssetID.toString("hex") !== amountAssetID.toString("hex")) {
                /* istanbul ignore next */
                throw new errors_1.FeeAssetError("Error - CaminoExecutor.buildExportTx: " +
                    `feeAssetID must match avaxAssetID`);
            }
            const aad = new _1.AssetAmountDestination(toAddresses, toThreshold, fromSigner.from, fromSigner.signer, changeAddresses, changeThreshold);
            let singleAsset = true;
            if (amountAssetID.toString("hex") === feeAssetID.toString("hex")) {
                aad.addAssetAmount(amountAssetID, zero, fee.add(amount));
            }
            else {
                singleAsset = false;
                aad.addAssetAmount(amountAssetID, amount, zero);
                if (this._feeCheck(fee, feeAssetID)) {
                    aad.addAssetAmount(feeAssetID, zero, fee);
                }
            }
            const minSpendableErr = yield this.spender.getMinimumSpendable(aad, asOf, locktime, "Unlocked");
            if (typeof minSpendableErr === "undefined") {
                ins = aad.getInputs();
                outs = singleAsset ? aad.getAllOutputs() : aad.getChangeOutputs();
                exports = singleAsset ? [] : aad.getOutputs();
                owners = aad.getOutputOwners();
            }
            else {
                throw minSpendableErr;
            }
            const baseTx = new _1.ExportTx(networkID, blockchainID, outs, ins, memo, destinationChain, exports.length > 0
                ? exports
                : [
                    new _1.SECPTransferOutput(amount, toAddresses, locktime, toThreshold).makeTransferable(amountAssetID)
                ]);
            baseTx.setOutputOwners(owners);
            return new _1.UnsignedTx(baseTx);
        });
        /**
         * Class representing an unsigned [[AddSubnetValidatorTx]] transaction.
         *
         * @param networkID Networkid, [[DefaultNetworkID]]
         * @param blockchainID Blockchainid, default undefined
         * @param fromSigner The addresses being used to send and verify the funds from the UTXOs {@link https://github.com/feross/buffer|Buffer}
         * @param changeAddresses An array of addresses as {@link https://github.com/feross/buffer|Buffer} who gets the change leftover from the fee payment
         * @param nodeID The node ID of the validator being added.
         * @param startTime The Unix time when the validator starts validating the Primary Network.
         * @param endTime The Unix time when the validator stops validating the Primary Network (and staked AVAX is returned).
         * @param weight The amount of weight for this subnet validator.
         * @param fee Optional. The amount of fees to burn in its smallest denomination, represented as {@link https://github.com/indutny/bn.js/|BN}
         * @param feeAssetID Optional. The assetID of the fees being burned.
         * @param memo Optional contains arbitrary bytes, up to 256 bytes
         * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
         * @param subnetAuth Optional. An Auth struct which contains the subnet Auth and the signers.
         * @param changeThreshold Optional. The number of signatures required to spend the funds in the resultant change UTXO
         *
         * @returns An unsigned transaction created from the passed in parameters.
         */
        this.buildAddSubnetValidatorTx = (networkID = utils_1.DefaultNetworkID, blockchainID, fromSigner, changeAddresses, nodeID, startTime, endTime, weight, subnetID, fee = zero, feeAssetID = undefined, memo = undefined, asOf = zero, subnetAuth = { addresses: [], threshold: 0, signer: [] }, changeThreshold = 1) => __awaiter(this, void 0, void 0, function* () {
            let ins = [];
            let outs = [];
            let owners = [];
            const now = (0, utils_1.UnixNow)();
            if (startTime.lt(now) || endTime.lte(startTime)) {
                throw new Error("CaminoExecutor.buildAddSubnetValidatorTx -- startTime must be in the future and endTime must come after startTime");
            }
            if (this._feeCheck(fee, feeAssetID)) {
                const aad = new _1.AssetAmountDestination([], 0, fromSigner.from, fromSigner.signer, changeAddresses, changeThreshold);
                aad.addAssetAmount(feeAssetID, zero, fee);
                const minSpendableErr = yield this.spender.getMinimumSpendable(aad, asOf, zero, this.caminoEnabled ? "Unlocked" : "Stake");
                if (typeof minSpendableErr === "undefined") {
                    ins = aad.getInputs();
                    outs = aad.getAllOutputs();
                    owners = aad.getOutputOwners();
                }
                else {
                    throw minSpendableErr;
                }
            }
            const baseTx = new _1.AddSubnetValidatorTx(networkID, blockchainID, outs, ins, memo, nodeID, startTime, endTime, weight, subnetID);
            subnetAuth.signer.forEach((subnetSigner) => {
                baseTx.addSignatureIdx(subnetSigner[0], subnetSigner[1]);
            });
            // We need to fetch the AUTH for later msig verification
            // For now we use simply what we get in subnetAuth
            owners.push(new common_1.OutputOwners(subnetAuth.addresses, common_1.ZeroBN, subnetAuth.threshold));
            if (this.caminoEnabled) {
                baseTx.includeNodeSignature();
                owners.push(new common_1.OutputOwners([nodeID], common_1.ZeroBN, 1));
            }
            baseTx.setOutputOwners(owners);
            return new _1.UnsignedTx(baseTx);
        });
        /**
         * Class representing an unsigned [[AddDelegatorTx]] transaction.
         *
         * @param networkID Networkid, [[DefaultNetworkID]]
         * @param blockchainID Blockchainid, default undefined
         * @param avaxAssetID {@link https://github.com/feross/buffer|Buffer} of the asset ID for AVAX
         * @param toAddresses An array of addresses as {@link https://github.com/feross/buffer|Buffer} recieves the stake at the end of the staking period
         * @param fromSigner The addresses being used to send and verify the funds from the UTXOs {@link https://github.com/feross/buffer|Buffer}
         * @param changeAddresses An array of addresses as {@link https://github.com/feross/buffer|Buffer} who gets the change leftover from the staking payment
         * @param nodeID The node ID of the validator being added.
         * @param startTime The Unix time when the validator starts validating the Primary Network.
         * @param endTime The Unix time when the validator stops validating the Primary Network (and staked AVAX is returned).
         * @param stakeAmount A {@link https://github.com/indutny/bn.js/|BN} for the amount of stake to be delegated in nAVAX.
         * @param rewardLocktime The locktime field created in the resulting reward outputs
         * @param rewardThreshold The number of signatures required to spend the funds in the resultant reward UTXO
         * @param rewardAddresses The addresses the validator reward goes.
         * @param fee Optional. The amount of fees to burn in its smallest denomination, represented as {@link https://github.com/indutny/bn.js/|BN}
         * @param feeAssetID Optional. The assetID of the fees being burned.
         * @param memo Optional contains arbitrary bytes, up to 256 bytes
         * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
         * @param toThreshold Optional. The number of signatures required to spend the funds in the stake UTXO
         * @param changeThreshold Optional. The number of signatures required to spend the funds in the change UTXO
         *
         * @returns An unsigned transaction created from the passed in parameters.
         */
        this.buildAddDelegatorTx = (networkID = utils_1.DefaultNetworkID, blockchainID, avaxAssetID, toAddresses, fromSigner, changeAddresses, nodeID, startTime, endTime, stakeAmount, rewardLocktime, rewardThreshold, rewardAddresses, fee = zero, feeAssetID = undefined, memo = undefined, asOf = zero, toThreshold = 1, changeThreshold = 1) => __awaiter(this, void 0, void 0, function* () {
            if (this.caminoEnabled) {
                throw new errors_1.ProtocolError("buildAddDelegatorTx - Not supported in Camino mode");
            }
            if (rewardThreshold > rewardAddresses.length) {
                /* istanbul ignore next */
                throw new errors_1.ThresholdError("Error - UTXOSet.buildAddDelegatorTx: reward threshold is greater than number of addresses");
            }
            if (typeof changeAddresses === "undefined") {
                changeAddresses = toAddresses;
            }
            let ins = [];
            let outs = [];
            let stakeOuts = [];
            let owners = [];
            const now = (0, utils_1.UnixNow)();
            if (startTime.lt(now) || endTime.lte(startTime)) {
                throw new errors_1.TimeError("UTXOSet.buildAddDelegatorTx -- startTime must be in the future and endTime must come after startTime");
            }
            const aad = new _1.AssetAmountDestination(toAddresses, toThreshold, fromSigner.from, fromSigner.signer, changeAddresses, changeThreshold);
            if (avaxAssetID.toString("hex") === feeAssetID.toString("hex")) {
                aad.addAssetAmount(avaxAssetID, stakeAmount, fee);
            }
            else {
                aad.addAssetAmount(avaxAssetID, stakeAmount, zero);
                if (this._feeCheck(fee, feeAssetID)) {
                    aad.addAssetAmount(feeAssetID, zero, fee);
                }
            }
            const minSpendableErr = yield this.spender.getMinimumSpendable(aad, asOf, zero, "Stake");
            if (typeof minSpendableErr === "undefined") {
                ins = aad.getInputs();
                outs = aad.getChangeOutputs();
                stakeOuts = aad.getOutputs();
                owners = aad.getOutputOwners();
            }
            else {
                throw minSpendableErr;
            }
            const rewardOutputOwners = new _1.SECPOwnerOutput(rewardAddresses, rewardLocktime, rewardThreshold);
            const baseTx = new _1.AddDelegatorTx(networkID, blockchainID, outs, ins, memo, nodeID, startTime, endTime, stakeAmount, stakeOuts, new _1.ParseableOutput(rewardOutputOwners));
            baseTx.setOutputOwners(owners);
            return new _1.UnsignedTx(baseTx);
        });
        /**
         * Class representing an unsigned [[AddValidatorTx]] transaction.
         *
         * @param networkID NetworkID, [[DefaultNetworkID]]
         * @param blockchainID BlockchainID, default undefined
         * @param avaxAssetID {@link https://github.com/feross/buffer|Buffer} of the asset ID for AVAX
         * @param toAddresses An array of addresses as {@link https://github.com/feross/buffer|Buffer} recieves the stake at the end of the staking period
         * @param fromSigner The addresses being used to send and verify the funds from the UTXOs {@link https://github.com/feross/buffer|Buffer}
         * @param changeAddresses An array of addresses as {@link https://github.com/feross/buffer|Buffer} who gets the change leftover from the staking payment
         * @param nodeID The node ID of the validator being added.
         * @param startTime The Unix time when the validator starts validating the Primary Network.
         * @param endTime The Unix time when the validator stops validating the Primary Network (and staked AVAX is returned).
         * @param stakeAmount A {@link https://github.com/indutny/bn.js/|BN} for the amount of stake to be delegated in nAVAX.
         * @param rewardLocktime The locktime field created in the resulting reward outputs
         * @param rewardThreshold The number of signatures required to spend the funds in the resultant reward UTXO
         * @param rewardAddresses The addresses the validator reward goes.
         * @param delegationFee A number for the percentage of reward to be given to the validator when someone delegates to them. Must be between 0 and 100.
         * @param minStake A {@link https://github.com/indutny/bn.js/|BN} representing the minimum stake required to validate on this network.
         * @param fee Optional. The amount of fees to burn in its smallest denomination, represented as {@link https://github.com/indutny/bn.js/|BN}
         * @param feeAssetID Optional. The assetID of the fees being burned.
         * @param memo Optional contains arbitrary bytes, up to 256 bytes
         * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
         * @param toThreshold Optional. The number of signatures required to spend the funds in the stake UTXO
         * @param changeThreshold Optional. The number of signatures required to spend the funds in the change UTXO
         */
        this.buildAddValidatorTx = (networkID = utils_1.DefaultNetworkID, blockchainID, toAddresses, fromSigner, changeAddresses, nodeID, startTime, endTime, stakeAmount, stakeAssetID, rewardLocktime, rewardThreshold, rewardAddresses, delegationFee, fee = zero, feeAssetID = undefined, memo = undefined, asOf = (0, utils_1.UnixNow)(), toThreshold = 1, changeThreshold = 1) => __awaiter(this, void 0, void 0, function* () {
            if (this.caminoEnabled) {
                throw new Error("Use buildCaminoAddValidatorTx");
            }
            let ins = [];
            let outs = [];
            let stakeOuts = [];
            let owners = [];
            const now = (0, utils_1.UnixNow)();
            if (startTime.lt(now) || endTime.lte(startTime)) {
                throw new errors_1.TimeError("UTXOSet.buildAddValidatorTx -- startTime must be in the future and endTime must come after startTime");
            }
            if (delegationFee > 100 || delegationFee < 0) {
                throw new errors_1.TimeError("UTXOSet.buildAddValidatorTx -- startTime must be in the range of 0 to 100, inclusively");
            }
            const aad = new _1.AssetAmountDestination(toAddresses, toThreshold, fromSigner.from, fromSigner.signer, changeAddresses, changeThreshold);
            if (stakeAssetID.toString("hex") === feeAssetID.toString("hex")) {
                aad.addAssetAmount(stakeAssetID, stakeAmount, fee);
            }
            else {
                aad.addAssetAmount(stakeAssetID, stakeAmount, zero);
                if (this._feeCheck(fee, feeAssetID)) {
                    aad.addAssetAmount(feeAssetID, zero, fee);
                }
            }
            const minSpendableErr = yield this.spender.getMinimumSpendable(aad, asOf, zero, "Stake");
            if (typeof minSpendableErr === "undefined") {
                ins = aad.getInputs();
                outs = aad.getChangeOutputs();
                stakeOuts = aad.getOutputs();
                owners = aad.getOutputOwners();
            }
            else {
                throw minSpendableErr;
            }
            const rewardOutputOwners = new _1.SECPOwnerOutput(rewardAddresses, rewardLocktime, rewardThreshold);
            const baseTx = new _1.AddValidatorTx(networkID, blockchainID, outs, ins, memo, nodeID, startTime, endTime, stakeAmount, stakeOuts, new _1.ParseableOutput(rewardOutputOwners), delegationFee);
            baseTx.setOutputOwners(owners);
            return new _1.UnsignedTx(baseTx);
        });
        /**
         * Class representing an unsigned [[CreateSubnetTx]] transaction.
         *
         * @param networkID Networkid, [[DefaultNetworkID]]
         * @param blockchainID Blockchainid, default undefined
         * @param fromSigner The addresses being used to send and verify the funds from the UTXOs {@link https://github.com/feross/buffer|Buffer}
         * @param changeAddresses The addresses that can spend the change remaining from the spent UTXOs.
         * @param subnetOwnerAddresses An array of {@link https://github.com/feross/buffer|Buffer} for the addresses to add to a subnet
         * @param subnetOwnerThreshold The number of owners's signatures required to add a validator to the network
         * @param fee Optional. The amount of fees to burn in its smallest denomination, represented as {@link https://github.com/indutny/bn.js/|BN}
         * @param feeAssetID Optional. The assetID of the fees being burned
         * @param memo Optional contains arbitrary bytes, up to 256 bytes
         * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
         * @param changeThreshold Optional. The number of signatures required to spend the funds in the resultant change UTXO
         *
         * @returns An unsigned transaction created from the passed in parameters.
         */
        this.buildCreateSubnetTx = (networkID = utils_1.DefaultNetworkID, blockchainID, fromSigner, changeAddresses, subnetOwnerAddresses, subnetOwnerThreshold, fee = zero, feeAssetID = undefined, memo = undefined, asOf = zero, changeThreshold = 1) => __awaiter(this, void 0, void 0, function* () {
            let ins = [];
            let outs = [];
            let owners = [];
            if (this._feeCheck(fee, feeAssetID)) {
                const aad = new _1.AssetAmountDestination([], 0, fromSigner.from, fromSigner.signer, changeAddresses, changeThreshold);
                aad.addAssetAmount(feeAssetID, zero, fee);
                const minSpendableErr = yield this.spender.getMinimumSpendable(aad, asOf, zero, "Unlocked");
                if (typeof minSpendableErr === "undefined") {
                    ins = aad.getInputs();
                    outs = aad.getAllOutputs();
                    owners = aad.getOutputOwners();
                }
                else {
                    throw minSpendableErr;
                }
            }
            const locktime = new bn_js_1.default(0);
            const subnetOwners = new _1.SECPOwnerOutput(subnetOwnerAddresses, locktime, subnetOwnerThreshold);
            const baseTx = new _1.CreateSubnetTx(networkID, blockchainID, outs, ins, memo, subnetOwners);
            baseTx.setOutputOwners(owners);
            return new _1.UnsignedTx(baseTx);
        });
        /**
         * Build an unsigned [[CreateChainTx]].
         *
         * @param networkID Networkid, [[DefaultNetworkID]]
         * @param blockchainID Blockchainid, default undefined
         * @param fromSigner The addresses being used to send and verify the funds from the UTXOs {@link https://github.com/feross/buffer|Buffer}
         * @param changeAddresses The addresses that can spend the change remaining from the spent UTXOs.
         * @param subnetID Optional ID of the Subnet that validates this blockchain
         * @param chainName Optional A human readable name for the chain; need not be unique
         * @param vmID Optional ID of the VM running on the new chain
         * @param fxIDs Optional IDs of the feature extensions running on the new chain
         * @param genesisData Optional Byte representation of genesis state of the new chain
         * @param fee Optional. The amount of fees to burn in its smallest denomination, represented as {@link https://github.com/indutny/bn.js/|BN}
         * @param feeAssetID Optional. The assetID of the fees being burned
         * @param memo Optional contains arbitrary bytes, up to 256 bytes
         * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
         * @param subnetAuth Optional. An Auth struct to sign for the Subnet.
         * @param changeThreshold Optional. The number of signatures required to spend the funds in the resultant change UTXO
         *
         * @returns An unsigned CreateChainTx created from the passed in parameters.
         */
        this.buildCreateChainTx = (networkID = utils_1.DefaultNetworkID, blockchainID, fromSigner, changeAddresses, subnetID = undefined, chainName = undefined, vmID = undefined, fxIDs = undefined, genesisData = undefined, fee = zero, feeAssetID = undefined, memo = undefined, asOf = zero, subnetAuth = { addresses: [], threshold: 0, signer: [] }, changeThreshold = 1) => __awaiter(this, void 0, void 0, function* () {
            let ins = [];
            let outs = [];
            let owners = [];
            if (this._feeCheck(fee, feeAssetID)) {
                const aad = new _1.AssetAmountDestination([], 0, fromSigner.from, fromSigner.signer, changeAddresses, changeThreshold);
                aad.addAssetAmount(feeAssetID, zero, fee);
                const minSpendableErr = yield this.spender.getMinimumSpendable(aad, asOf, zero, "Unlocked");
                if (typeof minSpendableErr === "undefined") {
                    ins = aad.getInputs();
                    outs = aad.getAllOutputs();
                    owners = aad.getOutputOwners();
                }
                else {
                    throw minSpendableErr;
                }
            }
            const baseTx = new _1.CreateChainTx(networkID, blockchainID, outs, ins, memo, subnetID, chainName, vmID, fxIDs, genesisData);
            subnetAuth.signer.forEach((subnetAuthSigner) => {
                baseTx.addSignatureIdx(subnetAuthSigner[0], subnetAuthSigner[1]);
            });
            // We need to fetch the AUTH for later msig verification
            // For now we use simply what we get in subnetAuth
            owners.push(new common_1.OutputOwners(subnetAuth.addresses, common_1.ZeroBN, subnetAuth.threshold));
            baseTx.setOutputOwners(owners);
            return new _1.UnsignedTx(baseTx);
        });
        /**
         * Helper function which creates an unsigned [[CaminoAddValidatorTx]]. For more granular control, you may create your own
         * [[UnsignedTx]] manually and import the [[CaminoAddValidatorTx]] class directly.
         *
         * @param networkID Networkid, [[DefaultNetworkID]]
         * @param blockchainID Blockchainid, default undefined
         * @param toAddresses An array of addresses as {@link https://github.com/feross/buffer|Buffer} who received the staked tokens at the end of the staking period
         * @param fromSigner The addresses being used to send and verify the funds from the UTXOs {@link https://github.com/feross/buffer|Buffer}
         * @param changeAddresses An array of addresses as {@link https://github.com/feross/buffer|Buffer} who gets the change leftover from the fee payment
         * @param nodeID The node ID of the validator being added.
         * @param nodeOwner The address and signature indices of the registered nodeId owner.
         * @param startTime The Unix time when the validator starts validating the Primary Network.
         * @param endTime The Unix time when the validator stops validating the Primary Network (and staked AVAX is returned).
         * @param stakeAmount The amount being delegated as a {@link https://github.com/indutny/bn.js/|BN}
         * @param rewardAddresses The addresses which will recieve the rewards from the delegated stake.
         * @param rewardLocktime Optional. The locktime field created in the resulting reward outputs
         * @param rewardThreshold Opional. The number of signatures required to spend the funds in the resultant reward UTXO. Default 1.
         * @param memo Optional contains arbitrary bytes, up to 256 bytes
         * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
         * @param toThreshold Optional. The number of signatures required to spend the funds in the received UTXO
         * @param changeThreshold Optional. The number of signatures required to spend the funds in the resultant change UTXO
         *
         * @returns An unsigned transaction created from the passed in parameters.
         */
        this.buildCaminoAddValidatorTx = (networkID = utils_1.DefaultNetworkID, blockchainID, to, fromSigner, change, nodeID, nodeOwner, startTime, endTime, stakeAmount, stakeAssetID, rewards, rewardLocktime = zero, rewardThreshold = 1, memo = undefined, asOf = zero, toThreshold = 1, changeThreshold = 1) => __awaiter(this, void 0, void 0, function* () {
            let ins = [];
            let outs = [];
            let owners = [];
            const now = (0, utils_1.UnixNow)();
            if (startTime.lt(now) || endTime.lte(startTime)) {
                throw new errors_1.TimeError("buildCaminoAddValidatorTx -- startTime must be in the future and endTime must come after startTime");
            }
            const aad = new _1.AssetAmountDestination(to, toThreshold, fromSigner.from, fromSigner.signer, change, changeThreshold);
            aad.addAssetAmount(stakeAssetID, stakeAmount, new bn_js_1.default(0));
            const minSpendableErr = yield this.spender.getMinimumSpendable(aad, asOf, zero, "Bond");
            if (typeof minSpendableErr === "undefined") {
                ins = aad.getInputs();
                outs = aad.getAllOutputs();
                owners = aad.getOutputOwners();
            }
            else {
                throw minSpendableErr;
            }
            const rewardOutputOwners = new _1.SECPOwnerOutput(rewards, rewardLocktime, rewardThreshold);
            const baseTx = new _1.CaminoAddValidatorTx(networkID, blockchainID, outs, ins, memo, nodeID, startTime, endTime, stakeAmount, new _1.ParseableOutput(rewardOutputOwners));
            nodeOwner.auth.forEach((o) => {
                baseTx.addSignatureIdx(o[0], o[1]);
            });
            owners.push(new common_1.OutputOwners([nodeOwner.address], common_1.ZeroBN, 1));
            baseTx.setOutputOwners(owners);
            return new _1.UnsignedTx(baseTx);
        });
        /**
         * Build an unsigned [[AddressStateTx]].
         *
         * @param version Optional. Transaction version number, default 0.
         * @param networkID Networkid, [[DefaultNetworkID]]
         * @param blockchainID Blockchainid, default undefined
         * @param fromSigner The addresses being used to send and verify the funds from the UTXOs {@link https://github.com/feross/buffer|Buffer}
         * @param changeAddresses The addresses that can spend the change remaining from the spent UTXOs.
         * @param address The address to alter state.
         * @param state The state to set or remove on the given address
         * @param remove Optional. Flag if state should be applied or removed
         * @param fee Optional. The amount of fees to burn in its smallest denomination, represented as {@link https://github.com/indutny/bn.js/|BN}
         * @param feeAssetID Optional. The assetID of the fees being burned
         * @param memo Optional contains arbitrary bytes, up to 256 bytes
         * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
         * @param changeThreshold Optional. The number of signatures required to spend the funds in the resultant change UTXO
         *
         * @returns An unsigned AddressStateTx created from the passed in parameters.
         */
        this.buildAddressStateTx = (version = utils_1.DefaultTransactionVersionNumber, networkID = utils_1.DefaultNetworkID, blockchainID, fromSigner, changeAddresses, address, state, remove = false, fee = zero, feeAssetID = undefined, memo = undefined, asOf = zero, changeThreshold = 1, executorAddress = undefined, executorAuth = []) => __awaiter(this, void 0, void 0, function* () {
            let ins = [];
            let outs = [];
            let owners = [];
            if (this._feeCheck(fee, feeAssetID)) {
                const aad = new _1.AssetAmountDestination([], 0, fromSigner.from, fromSigner.signer, changeAddresses, changeThreshold);
                aad.addAssetAmount(feeAssetID, zero, fee);
                const minSpendableErr = yield this.spender.getMinimumSpendable(aad, asOf, zero, "Unlocked");
                if (typeof minSpendableErr === "undefined") {
                    ins = aad.getInputs();
                    outs = aad.getAllOutputs();
                }
                else {
                    throw minSpendableErr;
                }
            }
            const baseTx = new _1.AddressStateTx(version, networkID, blockchainID, outs, ins, memo, address, state, remove, executorAddress);
            if (executorAddress) {
                executorAuth.forEach((signer) => {
                    baseTx.addSignatureIdx(signer[0], signer[1]);
                });
                owners.push(new common_1.OutputOwners([executorAddress], common_1.ZeroBN, 1));
            }
            baseTx.setOutputOwners(owners);
            return new _1.UnsignedTx(baseTx);
        });
        /**
         * Build an unsigned [[RegisterNodeTx]].
         *
         * @param networkID Networkid, [[DefaultNetworkID]]
         * @param blockchainID Blockchainid, default undefined
         * @param fromSigner The addresses being used to send and verify the funds from the UTXOs {@link https://github.com/feross/buffer|Buffer}
         * @param changeAddresses The addresses that can spend the change remaining from the spent UTXOs.
         * @param oldNodeID Optional. ID of the existing NodeID to replace or remove.
         * @param newNodeID Optional. ID of the newNodID to register address.
         * @param address The consortiumMemberAddress, single or multi-sig.
         * @param addressAuths An array of index and address to verify ownership of address.
         * @param fee Optional. The amount of fees to burn in its smallest denomination, represented as {@link https://github.com/indutny/bn.js/|BN}
         * @param feeAssetID Optional. The assetID of the fees being burned
         * @param memo Optional contains arbitrary bytes, up to 256 bytes
         * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
         * @param changeThreshold Optional. The number of signatures required to spend the funds in the resultant change UTXO
         *
         * @returns An unsigned RegisterNodeTx created from the passed in parameters.
         */
        this.buildRegisterNodeTx = (networkID = utils_1.DefaultNetworkID, blockchainID, fromSigner, changeAddresses, oldNodeID = undefined, newNodeID = undefined, address = undefined, addressAuths = [], fee = zero, feeAssetID = undefined, memo = undefined, asOf = zero, changeThreshold = 1) => __awaiter(this, void 0, void 0, function* () {
            let ins = [];
            let outs = [];
            let owners = [];
            if (this._feeCheck(fee, feeAssetID)) {
                const aad = new _1.AssetAmountDestination([], 0, fromSigner.from, fromSigner.signer, changeAddresses, changeThreshold);
                aad.addAssetAmount(feeAssetID, zero, fee);
                const minSpendableErr = yield this.spender.getMinimumSpendable(aad, asOf, zero, "Unlocked");
                if (typeof minSpendableErr === "undefined") {
                    ins = aad.getInputs();
                    outs = aad.getAllOutputs();
                    owners = aad.getOutputOwners();
                }
                else {
                    throw minSpendableErr;
                }
            }
            const baseTx = new _1.RegisterNodeTx(networkID, blockchainID, outs, ins, memo, oldNodeID, newNodeID, address);
            addressAuths.forEach((addressAuth) => {
                baseTx.addSignatureIdx(addressAuth[0], addressAuth[1]);
            });
            owners.push(newNodeID && !oldNodeID
                ? new common_1.OutputOwners([newNodeID], common_1.ZeroBN, 1)
                : new common_1.OutputOwners());
            owners.push(new common_1.OutputOwners([address], common_1.ZeroBN, 1));
            baseTx.setOutputOwners(owners);
            return new _1.UnsignedTx(baseTx);
        });
        /**
         * Build an unsigned [[DepositTx]].
         *
         * @param version Optional. Transaction version number, default 0.
         * @param networkID Networkid, [[DefaultNetworkID]]
         * @param blockchainID Blockchainid, default undefined
         * @param fromSigner The addresses being used to send and verify the funds from the UTXOs {@link https://github.com/feross/buffer|Buffer}
         * @param changeAddresses The addresses that can spend the change remaining from the spent UTXOs.
         * @param depositOfferID ID of the deposit offer.
         * @param depositDuration Duration of the deposit
         * @param rewardsOwner Optional The owners of the reward. If omitted, all inputs must have the same owner
         * @param depositCreatorAddress Address that is authorized to create deposit with given offer. Could be empty, if offer owner is empty.
         * @param depositCreatorAuth Auth for deposit creator address
         * @param depositOfferOwnerSigs Signatures which recover to depositOfferOwner address(es)
         * @param depositOfferOwnerAuth Auth for deposit offer owner
         * @param fee Optional. The amount of fees to burn in its smallest denomination, represented as {@link https://github.com/indutny/bn.js/|BN}
         * @param feeAssetID Optional. The assetID of the fees being burned
         * @param memo Optional contains arbitrary bytes, up to 256 bytes
         * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
         * @param changeThreshold Optional. The number of signatures required to spend the funds in the resultant change UTXO
         *
         * @returns An unsigned DepositTx created from the passed in parameters.
         */
        this.buildDepositTx = (version = utils_1.DefaultTransactionVersionNumber, networkID = utils_1.DefaultNetworkID, blockchainID, fromSigner, changeAddresses, depositOfferID, depositDuration, rewardsOwner, depositCreatorAddress = undefined, depositCreatorAuth = [], depositOfferOwnerSigs = [], depositOfferOwnerAuth = [], fee = zero, feeAssetID = undefined, memo = undefined, asOf = zero, amountToLock, changeThreshold = 1, to = [], toThreshold = 0) => __awaiter(this, void 0, void 0, function* () {
            let ins = [];
            let outs = [];
            let owners = [];
            if (this._feeCheck(fee, feeAssetID)) {
                const aad = new _1.AssetAmountDestination(to, toThreshold, fromSigner.from, fromSigner.signer, changeAddresses, changeThreshold);
                aad.addAssetAmount(feeAssetID, amountToLock, fee);
                const minSpendableErr = yield this.spender.getMinimumSpendable(aad, asOf, zero, "Deposit");
                if (typeof minSpendableErr === "undefined") {
                    ins = aad.getInputs();
                    outs = aad.getAllOutputs();
                    owners = aad.getOutputOwners();
                }
                else {
                    throw minSpendableErr;
                }
            }
            const secpOwners = new _1.SECPOwnerOutput(rewardsOwner.getAddresses(), rewardsOwner === null || rewardsOwner === void 0 ? void 0 : rewardsOwner.getLocktime(), rewardsOwner.getThreshold());
            const baseTx = new _1.DepositTx(version, networkID, blockchainID, outs, ins, memo, depositOfferID, depositDuration, new _1.ParseableOutput(secpOwners), depositCreatorAddress);
            if (version > 0) {
                baseTx.addDepositCreatorAuth(depositCreatorAuth);
                baseTx.addOwnerAuth(depositOfferOwnerAuth, depositOfferOwnerSigs);
                owners.push(new common_1.OutputOwners([depositCreatorAddress], common_1.ZeroBN, 1));
                // Create pseudo addresses for Multisig, they have to passed
                // to MultisigKeychain on keychain initialization
                const numAddresses = depositOfferOwnerAuth.length > 0
                    ? depositOfferOwnerAuth.at(depositOfferOwnerAuth.length - 1)[0]
                    : 0;
                const addrs = [];
                for (let i = 0; i < numAddresses; ++i) {
                    addrs.push(buffer_1.Buffer.alloc(20));
                    addrs.at(addrs.length - 1).writeUIntBE(i + 1, 16, 4);
                }
                owners.push(new common_1.OutputOwners(addrs, common_1.ZeroBN, depositOfferOwnerAuth.length));
            }
            baseTx.setOutputOwners(owners);
            return new _1.UnsignedTx(baseTx);
        });
        /**
         * Build an unsigned [[UnlockDepositTx]].
         *
         * @param networkID Networkid, [[DefaultNetworkID]]
         * @param blockchainID Blockchainid, default undefined
         * @param fromSigner @param fromSigner The addresses being used to send and verify the funds from the UTXOs {@link https://github.com/feross/buffer|Buffer}
         * @param changeAddresses The addresses that can spend the change remaining from the spent UTXOs.
         * @param fee Optional. The amount of fees to burn in its smallest denomination, represented as {@link https://github.com/indutny/bn.js/|BN}
         * @param feeAssetID Optional. The assetID of the fees being burned
         * @param memo Optional contains arbitrary bytes, up to 256 bytes
         * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
         * @param changeThreshold Optional. The number of signatures required to spend the funds in the resultant change UTXO
         *
         * @returns An unsigned UnlockDepositTx created from the passed in parameters.
         */
        this.buildUnlockDepositTx = (networkID = utils_1.DefaultNetworkID, blockchainID, fromSigner, changeAddresses, fee = zero, feeAssetID = undefined, memo = undefined, asOf = zero, changeThreshold = 1) => __awaiter(this, void 0, void 0, function* () {
            let ins = [];
            let outs = [];
            if (this._feeCheck(fee, feeAssetID)) {
                const aad = new _1.AssetAmountDestination([], 0, fromSigner.from, fromSigner.signer, changeAddresses, changeThreshold);
                aad.addAssetAmount(feeAssetID, zero, fee);
                const minSpendableErr = yield this.spender.getMinimumSpendable(aad, asOf, zero, "Unlocked");
                if (typeof minSpendableErr === "undefined") {
                    ins = aad.getInputs();
                    outs = aad.getAllOutputs();
                }
                else {
                    throw minSpendableErr;
                }
            }
            const unlockDepositTx = new _1.UnlockDepositTx(networkID, blockchainID, outs, ins, memo);
            return new _1.UnsignedTx(unlockDepositTx);
        });
        /**
         * Build an unsigned [[ClaimTx]].
         *
         * @param networkID NetworkID, [[DefaultNetworkID]]
         * @param blockchainID BlockchainID, default undefined
         * @param fromSigner @param fromSigner The addresses being used to send and verify the funds from the UTXOs {@link https://github.com/feross/buffer|Buffer}
         * @param changeAddresses The addresses that can spend the change remaining from the spent UTXOs.
         * @param fee Optional. The amount of fees to burn in its smallest denomination, represented as {@link https://github.com/indutny/bn.js/|BN}
         * @param feeAssetID Optional. The assetID of the fees being burned
         * @param memo Optional contains arbitrary bytes, up to 256 bytes
         * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
         * @param changeThreshold Optional. The number of signatures required to spend the funds in the resultant change UTXO
         * @param claimAmounts The specification and authentication what and how much to claim
         * @param claimTo The address to claimed rewards will be directed to
         *
         * @returns An unsigned ClaimTx created from the passed in parameters.
         */
        this.buildClaimTx = (networkID = utils_1.DefaultNetworkID, blockchainID, fromSigner, changeAddresses, fee = zero, feeAssetID = undefined, memo = undefined, asOf = zero, changeThreshold = 1, claimAmounts, claimTo = undefined) => __awaiter(this, void 0, void 0, function* () {
            let ins = [];
            let outs = [];
            let owners = [];
            if (this._feeCheck(fee, feeAssetID)) {
                const aad = new _1.AssetAmountDestination([], 0, fromSigner.from, fromSigner.signer, changeAddresses, changeThreshold);
                aad.addAssetAmount(feeAssetID, zero, fee);
                const minSpendableErr = yield this.spender.getMinimumSpendable(aad, asOf, zero, "Unlocked");
                if (typeof minSpendableErr === "undefined") {
                    ins = aad.getInputs();
                    outs = aad.getAllOutputs();
                    owners = aad.getOutputOwners();
                }
                else {
                    throw minSpendableErr;
                }
            }
            // TODO: Compact if possible
            const txClaimAmounts = [];
            const allSigIdxs = [];
            for (const amt of claimAmounts) {
                const receiver = claimTo ? claimTo : amt.owners;
                outs.push(new _1.TransferableOutput(feeAssetID, new _1.SECPTransferOutput(amt.amount, receiver.getAddresses(), receiver.getLocktime(), receiver.getThreshold())));
                let id = amt.id;
                if (!id) {
                    if (amt.claimType === _1.ClaimType.ACTIVE_DEPOSIT_REWARD)
                        throw new Error("ClaimAmount id must be set");
                    const b = buffer_1.Buffer.alloc(2, _1.PlatformVMConstants.LATESTCODEC);
                    id = buffer_1.Buffer.from((0, create_hash_1.default)("sha256")
                        .update(buffer_1.Buffer.concat([b, amt.owners.toBuffer()]))
                        .digest());
                }
                // Create SigIdxs
                if (amt.sigIdxs.length !== amt.owners.getThreshold())
                    throw new Error("SigIdx count mismatch");
                const sigIdxs = [];
                const addrs = amt.owners.getAddresses();
                for (const idx of amt.sigIdxs) {
                    if (idx >= addrs.length)
                        throw new Error("SigIdx out of bound");
                    sigIdxs.push(new common_1.SigIdx(idx, addrs[idx]));
                }
                // Create auth for verification of claimAmount owner
                const bufferSigIdxs = sigIdxs.map((s) => s.getBytes());
                txClaimAmounts.push(new _1.ClaimAmount(id, amt.claimType, amt.amount, bufferSigIdxs));
                allSigIdxs.push(sigIdxs);
                owners.push(amt.owners);
            }
            const claimTx = new _1.ClaimTx(networkID, blockchainID, outs, ins, memo, txClaimAmounts);
            // Build signatureIndices
            for (const s of allSigIdxs)
                claimTx.addSigIdxs(s);
            claimTx.setOutputOwners(owners);
            return new _1.UnsignedTx(claimTx);
        });
        /**
         * Build an unsigned [[MultisigAliasTx]].
         *
         * @param networkID Network ID, default [[DefaultNetworkID]]
         * @param blockchainID Blockchain ID, default undefined
         * @param fromSigner The addresses being used to send and verify the funds from the UTXOs
         * @param changeAddresses The addresses that can spend the change remaining from the spent UTXOs
         * @param multisigAliasParams Parameters of MultisigAliasTx. multisigAliasParams.ID must be empty if it's the new alias
         * @param fee Optional amount of fees to burn in its smallest denomination, represented as BN
         * @param feeAssetID Optional asset ID of the fees being burned
         * @param memo Optional contains arbitrary bytes, up to 256 bytes
         * @param asOf Optional timestamp to verify the transaction against, as BN
         * @param changeThreshold Optional number of signatures required to spend the funds in the resultant change UTXO
         *
         * @returns An unsigned MultisigAliasTx created from the passed-in parameters.
         */
        this.buildMultisigAliasTx = (networkID = utils_1.DefaultNetworkID, blockchainID, fromSigner, changeAddresses, multisigAliasParams, fee = zero, feeAssetID = undefined, memo = undefined, asOf = zero, changeThreshold = 1) => __awaiter(this, void 0, void 0, function* () {
            let ins = [];
            let outs = [];
            let owners = [];
            if (this._feeCheck(fee, feeAssetID)) {
                const aad = new _1.AssetAmountDestination([], 0, fromSigner.from, fromSigner.signer, changeAddresses, changeThreshold);
                aad.addAssetAmount(feeAssetID, zero, fee);
                const minSpendableErr = yield this.spender.getMinimumSpendable(aad, asOf, zero, "Unlocked");
                if (typeof minSpendableErr === "undefined") {
                    ins = aad.getInputs();
                    outs = aad.getAllOutputs();
                    owners = aad.getOutputOwners();
                }
                else {
                    throw minSpendableErr;
                }
            }
            const output = new _1.SECPOwnerOutput(multisigAliasParams.owners.getAddresses(), multisigAliasParams.owners.getLocktime(), multisigAliasParams.owners.getThreshold());
            const multisigAlias = new _1.MultisigAlias(multisigAliasParams.id, buffer_1.Buffer.from(multisigAliasParams.memo, "utf-8"), new _1.ParseableOutput(output));
            const baseTx = new _1.MultisigAliasTx(networkID, blockchainID, outs, ins, memo, multisigAlias);
            multisigAliasParams.auth.forEach((addressAuth) => {
                baseTx.addSignatureIdx(addressAuth[0], addressAuth[1]);
            });
            if (multisigAliasParams.id && multisigAliasParams.id.length != 0) {
                owners.push(new common_1.OutputOwners([multisigAliasParams.id], common_1.ZeroBN, 1));
            }
            baseTx.setOutputOwners(owners);
            return new _1.UnsignedTx(baseTx);
        });
        /**
         * Build an unsigned [[AddDepositOfferTx]].
         *
         * @param networkID
         * @param blockchainID
         * @param fromSigner
         * @param changeAddresses
         * @param depositOffer
         * @param depositOfferCreatorAddress
         * @param depositOfferCreatorAuth
         * @param fee
         * @param feeAssetID
         * @param memo
         * @param asOf
         * @param changeThreshold
         */
        this.buildAddDepositOfferTx = (networkID = utils_1.DefaultNetworkID, blockchainID, fromSigner, changeAddresses, offer, depositOfferCreatorAddress, depositOfferCreatorAuth = [], fee = zero, feeAssetID = undefined, memo = undefined, asOf = zero, changeThreshold = 1) => __awaiter(this, void 0, void 0, function* () {
            let ins = [];
            let outs = [];
            let owners = [];
            if (this._feeCheck(fee, feeAssetID)) {
                const aad = new _1.AssetAmountDestination([], 0, fromSigner.from, fromSigner.signer, changeAddresses, changeThreshold);
                aad.addAssetAmount(feeAssetID, zero, fee);
                const minSpendableErr = yield this.spender.getMinimumSpendable(aad, asOf, zero, "Unlocked");
                if (typeof minSpendableErr === "undefined") {
                    ins = aad.getInputs();
                    outs = aad.getAllOutputs();
                    owners = aad.getOutputOwners();
                }
                else {
                    throw minSpendableErr;
                }
            }
            const baseTx = new adddepositoffertx_1.AddDepositOfferTx(networkID, blockchainID, outs, ins, memo, offer, depositOfferCreatorAddress);
            depositOfferCreatorAuth.forEach((signer) => {
                baseTx.addSignatureIdx(signer[0], signer[1]);
            });
            owners.push(new common_1.OutputOwners([depositOfferCreatorAddress], common_1.ZeroBN, 1));
            baseTx.setOutputOwners(owners);
            return new _1.UnsignedTx(baseTx);
        });
        this.spender = spender;
        this.caminoEnabled = caminoEnabled;
    }
    _feeCheck(fee, feeAssetID) {
        return (typeof fee !== "undefined" &&
            typeof feeAssetID !== "undefined" &&
            fee.gt(new bn_js_1.default(0)) &&
            feeAssetID instanceof buffer_1.Buffer);
    }
}
exports.Builder = Builder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVpbGRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9hcGlzL3BsYXRmb3Jtdm0vYnVpbGRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7OztHQUdHOzs7Ozs7Ozs7Ozs7Ozs7QUFFSCxrREFBc0I7QUFFdEIsb0NBQWdDO0FBQ2hDLHlDQUEyRDtBQUMzRCx1Q0FJb0I7QUFDcEIsK0NBTTJCO0FBQzNCLHdCQWlDVTtBQUVWLDhEQUFvQztBQUNwQywrRUFHZ0Q7QUE2QmhELE1BQU0sSUFBSSxHQUFPLElBQUksZUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFBO0FBRTFCLE1BQWEsT0FBTztJQUlsQixZQUFZLE9BQXlCLEVBQUUsYUFBc0I7UUFLN0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztXQXFCRztRQUNILGdCQUFXLEdBQUcsQ0FDWixTQUFpQixFQUNqQixZQUFvQixFQUNwQixNQUFVLEVBQ1YsYUFBcUIsRUFDckIsV0FBcUIsRUFDckIsVUFBc0IsRUFDdEIsa0JBQTRCLFNBQVMsRUFDckMsTUFBVSxJQUFJLEVBQ2QsYUFBcUIsU0FBUyxFQUM5QixPQUFlLFNBQVMsRUFDeEIsT0FBVyxJQUFJLEVBQ2YsV0FBZSxJQUFJLEVBQ25CLGNBQXNCLENBQUMsRUFDdkIsa0JBQTBCLENBQUMsRUFDTixFQUFFO1lBQ3ZCLElBQUksV0FBVyxHQUFHLFdBQVcsQ0FBQyxNQUFNLEVBQUU7Z0JBQ3BDLDBCQUEwQjtnQkFDMUIsTUFBTSxJQUFJLHVCQUFjLENBQ3RCLDRFQUE0RSxDQUM3RSxDQUFBO2FBQ0Y7WUFFRCxJQUFJLE9BQU8sZUFBZSxLQUFLLFdBQVcsRUFBRTtnQkFDMUMsZUFBZSxHQUFHLEVBQUUsQ0FBQTthQUNyQjtZQUVELElBQUksT0FBTyxVQUFVLEtBQUssV0FBVyxFQUFFO2dCQUNyQyxVQUFVLEdBQUcsYUFBYSxDQUFBO2FBQzNCO1lBRUQsSUFBSSxNQUFNLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFO2dC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QUFDLENBQUMsQ0FBQTtZQUVGLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxxQkFBWSxDQUFDLENBQUMsMEJBQTBCLENBQUMsRUFBRSxlQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQTtZQUV0RSxNQUFNLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxDQUFBO1lBQzlCLE9BQU8sSUFBSSxhQUFVLENBQUMsTUFBTSxDQUFDLENBQUE7UUFDL0IsQ0FBQyxDQUFBLENBQUE7UUEzcERDLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFBO1FBQ3RCLElBQUksQ0FBQyxhQUFhLEdBQUcsYUFBYSxDQUFBO0lBQ3BDLENBQUM7SUFpa0RELFNBQVMsQ0FBQyxHQUFPLEVBQUUsVUFBa0I7UUFDbkMsT0FBTyxDQUNMLE9BQU8sR0FBRyxLQUFLLFdBQVc7WUFDMUIsT0FBTyxVQUFVLEtBQUssV0FBVztZQUNqQyxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksZUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2pCLFVBQVUsWUFBWSxlQUFNLENBQzdCLENBQUE7SUFDSCxDQUFDO0NBa0ZGO0FBanFERCwwQkFpcURDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqIEBtb2R1bGUgQVBJLVBsYXRmb3JtVk0tQnVpbGRlclxuICovXG5cbmltcG9ydCBCTiBmcm9tIFwiYm4uanNcIlxuXG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tIFwiYnVmZmVyL1wiXG5pbXBvcnQgeyBPdXRwdXRPd25lcnMsIFNpZ0lkeCwgWmVyb0JOIH0gZnJvbSBcIi4uLy4uL2NvbW1vblwiXG5pbXBvcnQge1xuICBEZWZhdWx0TmV0d29ya0lELFxuICBEZWZhdWx0VHJhbnNhY3Rpb25WZXJzaW9uTnVtYmVyLFxuICBVbml4Tm93XG59IGZyb20gXCIuLi8uLi91dGlsc1wiXG5pbXBvcnQge1xuICBBZGRyZXNzRXJyb3IsXG4gIEZlZUFzc2V0RXJyb3IsXG4gIFByb3RvY29sRXJyb3IsXG4gIFRocmVzaG9sZEVycm9yLFxuICBUaW1lRXJyb3Jcbn0gZnJvbSBcIi4uLy4uL3V0aWxzL2Vycm9yc1wiXG5pbXBvcnQge1xuICBBZGREZWxlZ2F0b3JUeCxcbiAgQWRkcmVzc1N0YXRlVHgsXG4gIEFkZFN1Ym5ldFZhbGlkYXRvclR4LFxuICBBZGRWYWxpZGF0b3JUeCxcbiAgQW1vdW50T3V0cHV0LFxuICBBc3NldEFtb3VudERlc3RpbmF0aW9uLFxuICBCYXNlVHgsXG4gIENhbWlub0FkZFZhbGlkYXRvclR4LFxuICBDbGFpbUFtb3VudCxcbiAgQ2xhaW1BbW91bnRQYXJhbXMsXG4gIENsYWltVHgsXG4gIENsYWltVHlwZSxcbiAgQ3JlYXRlQ2hhaW5UeCxcbiAgQ3JlYXRlU3VibmV0VHgsXG4gIERlcG9zaXRUeCxcbiAgRXhwb3J0VHgsXG4gIEltcG9ydFR4LFxuICBNdWx0aXNpZ0FsaWFzUGFyYW1zLFxuICBQYXJzZWFibGVPdXRwdXQsXG4gIFBsYXRmb3JtVk1Db25zdGFudHMsXG4gIFJlZ2lzdGVyTm9kZVR4LFxuICBTRUNQT3duZXJPdXRwdXQsXG4gIFNFQ1BUcmFuc2ZlcklucHV0LFxuICBTRUNQVHJhbnNmZXJPdXRwdXQsXG4gIFNlbGVjdE91dHB1dENsYXNzLFxuICBUcmFuc2ZlcmFibGVJbnB1dCxcbiAgVHJhbnNmZXJhYmxlT3V0cHV0LFxuICBVbmxvY2tEZXBvc2l0VHgsXG4gIFVuc2lnbmVkVHgsXG4gIFVUWE8sXG4gIE11bHRpc2lnQWxpYXMsXG4gIE11bHRpc2lnQWxpYXNUeFxufSBmcm9tIFwiLlwiXG5pbXBvcnQgeyBHZW5lc2lzRGF0YSB9IGZyb20gXCIuLi9hdm1cIlxuaW1wb3J0IGNyZWF0ZUhhc2ggZnJvbSBcImNyZWF0ZS1oYXNoXCJcbmltcG9ydCB7XG4gIEFkZERlcG9zaXRPZmZlclR4LFxuICBPZmZlclxufSBmcm9tIFwiLi4vLi4vYXBpcy9wbGF0Zm9ybXZtL2FkZGRlcG9zaXRvZmZlcnR4XCJcblxuZXhwb3J0IHR5cGUgTG9ja01vZGUgPSBcIlVubG9ja2VkXCIgfCBcIkJvbmRcIiB8IFwiRGVwb3NpdFwiIHwgXCJTdGFrZVwiXG5cbmV4cG9ydCBpbnRlcmZhY2UgTWluaW11bVNwZW5kYWJsZSB7XG4gIGdldE1pbmltdW1TcGVuZGFibGUoXG4gICAgYWFkOiBBc3NldEFtb3VudERlc3RpbmF0aW9uLFxuICAgIGFzT2Y6IEJOLFxuICAgIGxvY2t0aW1lOiBCTixcbiAgICBsb2NrTW9kZTogTG9ja01vZGVcbiAgKTogUHJvbWlzZTxFcnJvcj5cbn1cblxuZXhwb3J0IHR5cGUgRnJvbVNpZ25lciA9IHtcbiAgZnJvbTogQnVmZmVyW11cbiAgc2lnbmVyOiBCdWZmZXJbXVxufVxuXG5leHBvcnQgdHlwZSBOb2RlT3duZXIgPSB7XG4gIGFkZHJlc3M6IEJ1ZmZlclxuICBhdXRoOiBbbnVtYmVyLCBCdWZmZXJdW11cbn1cblxuZXhwb3J0IHR5cGUgQXV0aCA9IHtcbiAgYWRkcmVzc2VzOiBCdWZmZXJbXVxuICB0aHJlc2hvbGQ6IG51bWJlclxuICBzaWduZXI6IFtudW1iZXIsIEJ1ZmZlcl1bXVxufVxuXG5jb25zdCB6ZXJvOiBCTiA9IG5ldyBCTigwKVxuXG5leHBvcnQgY2xhc3MgQnVpbGRlciB7XG4gIHNwZW5kZXI6IE1pbmltdW1TcGVuZGFibGVcbiAgY2FtaW5vRW5hYmxlZDogYm9vbGVhblxuXG4gIGNvbnN0cnVjdG9yKHNwZW5kZXI6IE1pbmltdW1TcGVuZGFibGUsIGNhbWlub0VuYWJsZWQ6IGJvb2xlYW4pIHtcbiAgICB0aGlzLnNwZW5kZXIgPSBzcGVuZGVyXG4gICAgdGhpcy5jYW1pbm9FbmFibGVkID0gY2FtaW5vRW5hYmxlZFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gW1tVbnNpZ25lZFR4XV0gd3JhcHBpbmcgYSBbW0Jhc2VUeF1dLiBGb3IgbW9yZSBncmFudWxhciBjb250cm9sLCB5b3UgbWF5IGNyZWF0ZSB5b3VyIG93blxuICAgKiBbW1Vuc2lnbmVkVHhdXSB3cmFwcGluZyBhIFtbQmFzZVR4XV0gbWFudWFsbHkgKHdpdGggdGhlaXIgY29ycmVzcG9uZGluZyBbW1RyYW5zZmVyYWJsZUlucHV0XV1zIGFuZCBbW1RyYW5zZmVyYWJsZU91dHB1dF1dcykuXG4gICAqXG4gICAqIEBwYXJhbSBuZXR3b3JrSUQgVGhlIG51bWJlciByZXByZXNlbnRpbmcgTmV0d29ya0lEIG9mIHRoZSBub2RlXG4gICAqIEBwYXJhbSBibG9ja2NoYWluSUQgVGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IHJlcHJlc2VudGluZyB0aGUgQmxvY2tjaGFpbklEIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIGFtb3VudCBUaGUgYW1vdW50IG9mIHRoZSBhc3NldCB0byBiZSBzcGVudCBpbiBpdHMgc21hbGxlc3QgZGVub21pbmF0aW9uLCByZXByZXNlbnRlZCBhcyB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfS5cbiAgICogQHBhcmFtIGFzc2V0SUQge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gb2YgdGhlIGFzc2V0IElEIGZvciB0aGUgVVRYT1xuICAgKiBAcGFyYW0gdG9BZGRyZXNzZXMgVGhlIGFkZHJlc3NlcyB0byBzZW5kIHRoZSBmdW5kc1xuICAgKiBAcGFyYW0gZnJvbVNpZ25lciBUaGUgYWRkcmVzc2VzIGJlaW5nIHVzZWQgdG8gc2VuZCBhbmQgdmVyaWZ5IHRoZSBmdW5kcyBmcm9tIHRoZSBVVFhPcyB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfVxuICAgKiBAcGFyYW0gY2hhbmdlQWRkcmVzc2VzIE9wdGlvbmFsLiBUaGUgYWRkcmVzc2VzIHRoYXQgY2FuIHNwZW5kIHRoZSBjaGFuZ2UgcmVtYWluaW5nIGZyb20gdGhlIHNwZW50IFVUWE9zLiBEZWZhdWx0OiB0b0FkZHJlc3Nlc1xuICAgKiBAcGFyYW0gZmVlIE9wdGlvbmFsLiBUaGUgYW1vdW50IG9mIGZlZXMgdG8gYnVybiBpbiBpdHMgc21hbGxlc3QgZGVub21pbmF0aW9uLCByZXByZXNlbnRlZCBhcyB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfVxuICAgKiBAcGFyYW0gZmVlQXNzZXRJRCBPcHRpb25hbC4gVGhlIGFzc2V0SUQgb2YgdGhlIGZlZXMgYmVpbmcgYnVybmVkLiBEZWZhdWx0OiBhc3NldElEXG4gICAqIEBwYXJhbSBtZW1vIE9wdGlvbmFsLiBDb250YWlucyBhcmJpdHJhcnkgZGF0YSwgdXAgdG8gMjU2IGJ5dGVzXG4gICAqIEBwYXJhbSBhc09mIE9wdGlvbmFsLiBUaGUgdGltZXN0YW1wIHRvIHZlcmlmeSB0aGUgdHJhbnNhY3Rpb24gYWdhaW5zdCBhcyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcy98Qk59XG4gICAqIEBwYXJhbSBsb2NrdGltZSBPcHRpb25hbC4gVGhlIGxvY2t0aW1lIGZpZWxkIGNyZWF0ZWQgaW4gdGhlIHJlc3VsdGluZyBvdXRwdXRzXG4gICAqIEBwYXJhbSB0b1RocmVzaG9sZCBPcHRpb25hbC4gVGhlIG51bWJlciBvZiBzaWduYXR1cmVzIHJlcXVpcmVkIHRvIHNwZW5kIHRoZSBmdW5kcyBpbiB0aGUgcmVzdWx0YW50IFVUWE9cbiAgICogQHBhcmFtIGNoYW5nZVRocmVzaG9sZCBPcHRpb25hbC4gVGhlIG51bWJlciBvZiBzaWduYXR1cmVzIHJlcXVpcmVkIHRvIHNwZW5kIHRoZSBmdW5kcyBpbiB0aGUgcmVzdWx0YW50IGNoYW5nZSBVVFhPXG4gICAqXG4gICAqIEByZXR1cm5zIEFuIHVuc2lnbmVkIHRyYW5zYWN0aW9uIGNyZWF0ZWQgZnJvbSB0aGUgcGFzc2VkIGluIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqL1xuICBidWlsZEJhc2VUeCA9IGFzeW5jIChcbiAgICBuZXR3b3JrSUQ6IG51bWJlcixcbiAgICBibG9ja2NoYWluSUQ6IEJ1ZmZlcixcbiAgICBhbW91bnQ6IEJOLFxuICAgIGFtb3VudEFzc2V0SUQ6IEJ1ZmZlcixcbiAgICB0b0FkZHJlc3NlczogQnVmZmVyW10sXG4gICAgZnJvbVNpZ25lcjogRnJvbVNpZ25lcixcbiAgICBjaGFuZ2VBZGRyZXNzZXM6IEJ1ZmZlcltdID0gdW5kZWZpbmVkLFxuICAgIGZlZTogQk4gPSB6ZXJvLFxuICAgIGZlZUFzc2V0SUQ6IEJ1ZmZlciA9IHVuZGVmaW5lZCxcbiAgICBtZW1vOiBCdWZmZXIgPSB1bmRlZmluZWQsXG4gICAgYXNPZjogQk4gPSB6ZXJvLFxuICAgIGxvY2tUaW1lOiBCTiA9IHplcm8sXG4gICAgdG9UaHJlc2hvbGQ6IG51bWJlciA9IDEsXG4gICAgY2hhbmdlVGhyZXNob2xkOiBudW1iZXIgPSAxXG4gICk6IFByb21pc2U8VW5zaWduZWRUeD4gPT4ge1xuICAgIGlmICh0b1RocmVzaG9sZCA+IHRvQWRkcmVzc2VzLmxlbmd0aCkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHRocm93IG5ldyBUaHJlc2hvbGRFcnJvcihcbiAgICAgICAgXCJFcnJvciAtIFVUWE9TZXQuYnVpbGRCYXNlVHg6IHRocmVzaG9sZCBpcyBncmVhdGVyIHRoYW4gbnVtYmVyIG9mIGFkZHJlc3Nlc1wiXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjaGFuZ2VBZGRyZXNzZXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNoYW5nZUFkZHJlc3NlcyA9IFtdXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmZWVBc3NldElEID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBmZWVBc3NldElEID0gYW1vdW50QXNzZXRJRFxuICAgIH1cblxuICAgIGlmIChhbW91bnQuZXEoemVybykpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBjb25zdCBhYWQ6IEFzc2V0QW1vdW50RGVzdGluYXRpb24gPSBuZXcgQXNzZXRBbW91bnREZXN0aW5hdGlvbihcbiAgICAgIHRvQWRkcmVzc2VzLFxuICAgICAgdG9UaHJlc2hvbGQsXG4gICAgICBmcm9tU2lnbmVyLmZyb20sXG4gICAgICBmcm9tU2lnbmVyLnNpZ25lcixcbiAgICAgIGNoYW5nZUFkZHJlc3NlcyxcbiAgICAgIGNoYW5nZVRocmVzaG9sZFxuICAgIClcbiAgICBpZiAoYW1vdW50QXNzZXRJRC50b1N0cmluZyhcImhleFwiKSA9PT0gZmVlQXNzZXRJRC50b1N0cmluZyhcImhleFwiKSkge1xuICAgICAgYWFkLmFkZEFzc2V0QW1vdW50KGFtb3VudEFzc2V0SUQsIGFtb3VudCwgZmVlKVxuICAgIH0gZWxzZSB7XG4gICAgICBhYWQuYWRkQXNzZXRBbW91bnQoYW1vdW50QXNzZXRJRCwgYW1vdW50LCB6ZXJvKVxuICAgICAgaWYgKHRoaXMuX2ZlZUNoZWNrKGZlZSwgZmVlQXNzZXRJRCkpIHtcbiAgICAgICAgYWFkLmFkZEFzc2V0QW1vdW50KGZlZUFzc2V0SUQsIHplcm8sIGZlZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgaW5zOiBUcmFuc2ZlcmFibGVJbnB1dFtdID0gW11cbiAgICBsZXQgb3V0czogVHJhbnNmZXJhYmxlT3V0cHV0W10gPSBbXVxuICAgIGxldCBvd25lcnM6IE91dHB1dE93bmVyc1tdID0gW11cblxuICAgIGNvbnN0IG1pblNwZW5kYWJsZUVycjogRXJyb3IgPSBhd2FpdCB0aGlzLnNwZW5kZXIuZ2V0TWluaW11bVNwZW5kYWJsZShcbiAgICAgIGFhZCxcbiAgICAgIGFzT2YsXG4gICAgICBsb2NrVGltZSxcbiAgICAgIFwiVW5sb2NrZWRcIlxuICAgIClcbiAgICBpZiAodHlwZW9mIG1pblNwZW5kYWJsZUVyciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaW5zID0gYWFkLmdldElucHV0cygpXG4gICAgICBvdXRzID0gYWFkLmdldEFsbE91dHB1dHMoKVxuICAgICAgb3duZXJzID0gYWFkLmdldE91dHB1dE93bmVycygpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG1pblNwZW5kYWJsZUVyclxuICAgIH1cblxuICAgIGNvbnN0IGJhc2VUeDogQmFzZVR4ID0gbmV3IEJhc2VUeChuZXR3b3JrSUQsIGJsb2NrY2hhaW5JRCwgb3V0cywgaW5zLCBtZW1vKVxuICAgIGJhc2VUeC5zZXRPdXRwdXRPd25lcnMob3duZXJzKVxuICAgIHJldHVybiBuZXcgVW5zaWduZWRUeChiYXNlVHgpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiB1bnNpZ25lZCBJbXBvcnRUeCB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIG5ldHdvcmtJRCBUaGUgbnVtYmVyIHJlcHJlc2VudGluZyBOZXR3b3JrSUQgb2YgdGhlIG5vZGVcbiAgICogQHBhcmFtIGJsb2NrY2hhaW5JRCBUaGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gcmVwcmVzZW50aW5nIHRoZSBCbG9ja2NoYWluSUQgZm9yIHRoZSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gdG9BZGRyZXNzZXMgVGhlIGFkZHJlc3NlcyB0byBzZW5kIHRoZSBmdW5kc1xuICAgKiBAcGFyYW0gZnJvbVNpZ25lciBUaGUgYWRkcmVzc2VzIGJlaW5nIHVzZWQgdG8gc2VuZCBhbmQgdmVyaWZ5IHRoZSBmdW5kcyBmcm9tIHRoZSBVVFhPcyB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfVxuICAgKiBAcGFyYW0gY2hhbmdlQWRkcmVzc2VzIE9wdGlvbmFsLiBUaGUgYWRkcmVzc2VzIHRoYXQgY2FuIHNwZW5kIHRoZSBjaGFuZ2UgcmVtYWluaW5nIGZyb20gdGhlIHNwZW50IFVUWE9zLiBEZWZhdWx0OiB0b0FkZHJlc3Nlc1xuICAgKiBAcGFyYW0gaW1wb3J0SW5zIEFuIGFycmF5IG9mIFtbVHJhbnNmZXJhYmxlSW5wdXRdXXMgYmVpbmcgaW1wb3J0ZWRcbiAgICogQHBhcmFtIHNvdXJjZUNoYWluIEEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gZm9yIHRoZSBjaGFpbmlkIHdoZXJlIHRoZSBpbXBvcnRzIGFyZSBjb21pbmcgZnJvbS5cbiAgICogQHBhcmFtIGZlZSBPcHRpb25hbC4gVGhlIGFtb3VudCBvZiBmZWVzIHRvIGJ1cm4gaW4gaXRzIHNtYWxsZXN0IGRlbm9taW5hdGlvbiwgcmVwcmVzZW50ZWQgYXMge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn0uIEZlZSB3aWxsIGNvbWUgZnJvbSB0aGUgaW5wdXRzIGZpcnN0LCBpZiB0aGV5IGNhbi5cbiAgICogQHBhcmFtIGZlZUFzc2V0SUQgT3B0aW9uYWwuIFRoZSBhc3NldElEIG9mIHRoZSBmZWVzIGJlaW5nIGJ1cm5lZC5cbiAgICogQHBhcmFtIG1lbW8gT3B0aW9uYWwgY29udGFpbnMgYXJiaXRyYXJ5IGJ5dGVzLCB1cCB0byAyNTYgYnl0ZXNcbiAgICogQHBhcmFtIGxvY2t0aW1lIE9wdGlvbmFsLiBUaGUgbG9ja3RpbWUgZmllbGQgY3JlYXRlZCBpbiB0aGUgcmVzdWx0aW5nIG91dHB1dHNcbiAgICogQHBhcmFtIHRvVGhyZXNob2xkIE9wdGlvbmFsLiBUaGUgbnVtYmVyIG9mIHNpZ25hdHVyZXMgcmVxdWlyZWQgdG8gc3BlbmQgdGhlIGZ1bmRzIGluIHRoZSByZWNlaXZlZCBVVFhPXG4gICAqIEBwYXJhbSBjaGFuZ2VUaHJlc2hvbGQgT3B0aW9uYWwuIFRoZSBudW1iZXIgb2Ygc2lnbmF0dXJlcyByZXF1aXJlZCB0byBzcGVuZCB0aGUgZnVuZHMgaW4gdGhlIHJlc3VsdGFudCBjaGFuZ2UgVVRYT1xuICAgKlxuICAgKiBAcmV0dXJucyBBbiB1bnNpZ25lZCB0cmFuc2FjdGlvbiBjcmVhdGVkIGZyb20gdGhlIHBhc3NlZCBpbiBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKi9cbiAgYnVpbGRJbXBvcnRUeCA9IGFzeW5jIChcbiAgICBuZXR3b3JrSUQ6IG51bWJlcixcbiAgICBibG9ja2NoYWluSUQ6IEJ1ZmZlcixcbiAgICB0b0FkZHJlc3NlczogQnVmZmVyW10sXG4gICAgZnJvbVNpZ25lcjogRnJvbVNpZ25lcixcbiAgICBjaGFuZ2VBZGRyZXNzZXM6IEJ1ZmZlcltdLFxuICAgIGF0b21pY3M6IFVUWE9bXSxcbiAgICBzb3VyY2VDaGFpbjogQnVmZmVyID0gdW5kZWZpbmVkLFxuICAgIGZlZTogQk4gPSB6ZXJvLFxuICAgIGZlZUFzc2V0SUQ6IEJ1ZmZlciA9IHVuZGVmaW5lZCxcbiAgICBtZW1vOiBCdWZmZXIgPSB1bmRlZmluZWQsXG4gICAgYXNPZjogQk4gPSB6ZXJvLFxuICAgIGxvY2t0aW1lOiBCTiA9IHplcm8sXG4gICAgdG9UaHJlc2hvbGQ6IG51bWJlciA9IDEsXG4gICAgY2hhbmdlVGhyZXNob2xkOiBudW1iZXIgPSAxXG4gICk6IFByb21pc2U8VW5zaWduZWRUeD4gPT4ge1xuICAgIGxldCBpbnM6IFRyYW5zZmVyYWJsZUlucHV0W10gPSBbXVxuICAgIGxldCBvdXRzOiBUcmFuc2ZlcmFibGVPdXRwdXRbXSA9IFtdXG4gICAgbGV0IG93bmVyczogT3V0cHV0T3duZXJzW10gPSBbXVxuICAgIGNvbnN0IGltcG9ydE93bmVyczogT3V0cHV0T3duZXJzW10gPSBbXVxuXG4gICAgaWYgKHR5cGVvZiBmZWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGZlZSA9IHplcm8uY2xvbmUoKVxuICAgIH1cblxuICAgIGNvbnN0IGltcG9ydEluczogVHJhbnNmZXJhYmxlSW5wdXRbXSA9IFtdXG4gICAgbGV0IGZlZXBhaWQ6IEJOID0gbmV3IEJOKDApXG4gICAgbGV0IGZlZUFzc2V0U3RyOiBzdHJpbmcgPSBmZWVBc3NldElELnRvU3RyaW5nKFwiaGV4XCIpXG4gICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IGF0b21pY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHV0eG86IFVUWE8gPSBhdG9taWNzW2Ake2l9YF1cbiAgICAgIGNvbnN0IGFzc2V0SUQ6IEJ1ZmZlciA9IHV0eG8uZ2V0QXNzZXRJRCgpXG4gICAgICBjb25zdCBvdXRwdXQ6IEFtb3VudE91dHB1dCA9IHV0eG8uZ2V0T3V0cHV0KCkgYXMgQW1vdW50T3V0cHV0XG4gICAgICBsZXQgYW10OiBCTiA9IG91dHB1dC5nZXRBbW91bnQoKS5jbG9uZSgpXG5cbiAgICAgIGxldCBpbmZlZWFtb3VudCA9IGFtdC5jbG9uZSgpXG4gICAgICBsZXQgYXNzZXRTdHI6IHN0cmluZyA9IGFzc2V0SUQudG9TdHJpbmcoXCJoZXhcIilcbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIGZlZUFzc2V0SUQgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgZmVlLmd0KHplcm8pICYmXG4gICAgICAgIGZlZXBhaWQubHQoZmVlKSAmJlxuICAgICAgICBhc3NldFN0ciA9PT0gZmVlQXNzZXRTdHJcbiAgICAgICkge1xuICAgICAgICBmZWVwYWlkID0gZmVlcGFpZC5hZGQoaW5mZWVhbW91bnQpXG4gICAgICAgIGlmIChmZWVwYWlkLmd0ZShmZWUpKSB7XG4gICAgICAgICAgaW5mZWVhbW91bnQgPSBmZWVwYWlkLnN1YihmZWUpXG4gICAgICAgICAgZmVlcGFpZCA9IGZlZS5jbG9uZSgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5mZWVhbW91bnQgPSB6ZXJvLmNsb25lKClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB0eGlkOiBCdWZmZXIgPSB1dHhvLmdldFR4SUQoKVxuICAgICAgY29uc3Qgb3V0cHV0aWR4OiBCdWZmZXIgPSB1dHhvLmdldE91dHB1dElkeCgpXG4gICAgICBjb25zdCBpbnB1dDogU0VDUFRyYW5zZmVySW5wdXQgPSBuZXcgU0VDUFRyYW5zZmVySW5wdXQoYW10KVxuICAgICAgY29uc3QgeGZlcmluOiBUcmFuc2ZlcmFibGVJbnB1dCA9IG5ldyBUcmFuc2ZlcmFibGVJbnB1dChcbiAgICAgICAgdHhpZCxcbiAgICAgICAgb3V0cHV0aWR4LFxuICAgICAgICBhc3NldElELFxuICAgICAgICBpbnB1dFxuICAgICAgKVxuICAgICAgY29uc3QgZnJvbTogQnVmZmVyW10gPSBvdXRwdXQuZ2V0QWRkcmVzc2VzKClcbiAgICAgIGNvbnN0IHNwZW5kZXJzOiBCdWZmZXJbXSA9IG91dHB1dC5nZXRTcGVuZGVycyhmcm9tKVxuICAgICAgZm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IHNwZW5kZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IGlkeDogbnVtYmVyID0gb3V0cHV0LmdldEFkZHJlc3NJZHgoc3BlbmRlcnNbYCR7an1gXSlcbiAgICAgICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIHRocm93IG5ldyBBZGRyZXNzRXJyb3IoXG4gICAgICAgICAgICBcIkVycm9yIC0gVVRYT1NldC5idWlsZEltcG9ydFR4OiBubyBzdWNoIFwiICtcbiAgICAgICAgICAgICAgYGFkZHJlc3MgaW4gb3V0cHV0OiAke3NwZW5kZXJzW2Ake2p9YF19YFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICB4ZmVyaW4uZ2V0SW5wdXQoKS5hZGRTaWduYXR1cmVJZHgoaWR4LCBzcGVuZGVyc1tgJHtqfWBdKVxuICAgICAgfVxuICAgICAgaW1wb3J0T3duZXJzLnB1c2goXG4gICAgICAgIG5ldyBPdXRwdXRPd25lcnMoXG4gICAgICAgICAgb3V0cHV0LmdldEFkZHJlc3NlcygpLFxuICAgICAgICAgIG91dHB1dC5nZXRMb2NrdGltZSgpLFxuICAgICAgICAgIG91dHB1dC5nZXRUaHJlc2hvbGQoKVxuICAgICAgICApXG4gICAgICApXG4gICAgICBpbXBvcnRJbnMucHVzaCh4ZmVyaW4pXG4gICAgICAvL2FkZCBleHRyYSBvdXRwdXRzIGZvciBlYWNoIGFtb3VudCAoY2FsY3VsYXRlZCBmcm9tIHRoZSBpbXBvcnRlZCBpbnB1dHMpLCBtaW51cyBmZWVzXG4gICAgICBpZiAoaW5mZWVhbW91bnQuZ3QoemVybykpIHtcbiAgICAgICAgY29uc3Qgc3BlbmRvdXQ6IEFtb3VudE91dHB1dCA9IFNlbGVjdE91dHB1dENsYXNzKFxuICAgICAgICAgIG91dHB1dC5nZXRPdXRwdXRJRCgpLFxuICAgICAgICAgIGluZmVlYW1vdW50LFxuICAgICAgICAgIHRvQWRkcmVzc2VzLFxuICAgICAgICAgIGxvY2t0aW1lLFxuICAgICAgICAgIHRvVGhyZXNob2xkXG4gICAgICAgICkgYXMgQW1vdW50T3V0cHV0XG4gICAgICAgIGNvbnN0IHhmZXJvdXQ6IFRyYW5zZmVyYWJsZU91dHB1dCA9IG5ldyBUcmFuc2ZlcmFibGVPdXRwdXQoXG4gICAgICAgICAgYXNzZXRJRCxcbiAgICAgICAgICBzcGVuZG91dFxuICAgICAgICApXG4gICAgICAgIG91dHMucHVzaCh4ZmVyb3V0KVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGdldCByZW1haW5pbmcgZmVlcyBmcm9tIHRoZSBwcm92aWRlZCBhZGRyZXNzZXNcbiAgICBsZXQgZmVlUmVtYWluaW5nOiBCTiA9IGZlZS5zdWIoZmVlcGFpZClcbiAgICBpZiAoZmVlUmVtYWluaW5nLmd0KHplcm8pICYmIHRoaXMuX2ZlZUNoZWNrKGZlZVJlbWFpbmluZywgZmVlQXNzZXRJRCkpIHtcbiAgICAgIGNvbnN0IGFhZDogQXNzZXRBbW91bnREZXN0aW5hdGlvbiA9IG5ldyBBc3NldEFtb3VudERlc3RpbmF0aW9uKFxuICAgICAgICB0b0FkZHJlc3NlcyxcbiAgICAgICAgdG9UaHJlc2hvbGQsXG4gICAgICAgIGZyb21TaWduZXIuZnJvbSxcbiAgICAgICAgZnJvbVNpZ25lci5zaWduZXIsXG4gICAgICAgIGNoYW5nZUFkZHJlc3NlcyxcbiAgICAgICAgY2hhbmdlVGhyZXNob2xkXG4gICAgICApXG5cbiAgICAgIGFhZC5hZGRBc3NldEFtb3VudChmZWVBc3NldElELCB6ZXJvLCBmZWVSZW1haW5pbmcpXG4gICAgICBjb25zdCBtaW5TcGVuZGFibGVFcnI6IEVycm9yID0gYXdhaXQgdGhpcy5zcGVuZGVyLmdldE1pbmltdW1TcGVuZGFibGUoXG4gICAgICAgIGFhZCxcbiAgICAgICAgYXNPZixcbiAgICAgICAgbG9ja3RpbWUsXG4gICAgICAgIFwiVW5sb2NrZWRcIlxuICAgICAgKVxuICAgICAgaWYgKHR5cGVvZiBtaW5TcGVuZGFibGVFcnIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaW5zID0gYWFkLmdldElucHV0cygpXG4gICAgICAgIG91dHMgPSBhYWQuZ2V0QWxsT3V0cHV0cygpXG4gICAgICAgIG93bmVycyA9IGFhZC5nZXRPdXRwdXRPd25lcnMoKVxuICAgICAgICBvd25lcnMucHVzaCguLi5pbXBvcnRPd25lcnMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBtaW5TcGVuZGFibGVFcnJcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBiYXNlVHg6IEltcG9ydFR4ID0gbmV3IEltcG9ydFR4KFxuICAgICAgbmV0d29ya0lELFxuICAgICAgYmxvY2tjaGFpbklELFxuICAgICAgb3V0cyxcbiAgICAgIGlucyxcbiAgICAgIG1lbW8sXG4gICAgICBzb3VyY2VDaGFpbixcbiAgICAgIGltcG9ydEluc1xuICAgIClcblxuICAgIGJhc2VUeC5zZXRPdXRwdXRPd25lcnMob3duZXJzKVxuICAgIHJldHVybiBuZXcgVW5zaWduZWRUeChiYXNlVHgpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiB1bnNpZ25lZCBFeHBvcnRUeCB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIG5ldHdvcmtJRCBUaGUgbnVtYmVyIHJlcHJlc2VudGluZyBOZXR3b3JrSUQgb2YgdGhlIG5vZGVcbiAgICogQHBhcmFtIGJsb2NrY2hhaW5JRCBUaGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gcmVwcmVzZW50aW5nIHRoZSBCbG9ja2NoYWluSUQgZm9yIHRoZSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gYW1vdW50IFRoZSBhbW91bnQgYmVpbmcgZXhwb3J0ZWQgYXMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfVxuICAgKiBAcGFyYW0gYXZheEFzc2V0SUQge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gb2YgdGhlIGFzc2V0IElEIGZvciBBVkFYXG4gICAqIEBwYXJhbSB0b0FkZHJlc3NlcyBBbiBhcnJheSBvZiBhZGRyZXNzZXMgYXMge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gd2hvIHJlY2lldmVzIHRoZSBBVkFYXG4gICAqIEBwYXJhbSBmcm9tU2lnbmVyIFRoZSBhZGRyZXNzZXMgYmVpbmcgdXNlZCB0byBzZW5kIGFuZCB2ZXJpZnkgdGhlIGZ1bmRzIGZyb20gdGhlIFVUWE9zIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9XG4gICAqIEBwYXJhbSBjaGFuZ2VBZGRyZXNzZXMgQW4gYXJyYXkgb2YgYWRkcmVzc2VzIGFzIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IHdobyBnZXRzIHRoZSBjaGFuZ2UgbGVmdG92ZXIgb2YgdGhlIEFWQVhcbiAgICogQHBhcmFtIGRlc3RpbmF0aW9uQ2hhaW4gT3B0aW9uYWwuIEEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gZm9yIHRoZSBjaGFpbmlkIHdoZXJlIHRvIHNlbmQgdGhlIGFzc2V0LlxuICAgKiBAcGFyYW0gZmVlIE9wdGlvbmFsLiBUaGUgYW1vdW50IG9mIGZlZXMgdG8gYnVybiBpbiBpdHMgc21hbGxlc3QgZGVub21pbmF0aW9uLCByZXByZXNlbnRlZCBhcyB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfVxuICAgKiBAcGFyYW0gZmVlQXNzZXRJRCBPcHRpb25hbC4gVGhlIGFzc2V0SUQgb2YgdGhlIGZlZXMgYmVpbmcgYnVybmVkLlxuICAgKiBAcGFyYW0gbWVtbyBPcHRpb25hbCBjb250YWlucyBhcmJpdHJhcnkgYnl0ZXMsIHVwIHRvIDI1NiBieXRlc1xuICAgKiBAcGFyYW0gYXNPZiBPcHRpb25hbC4gVGhlIHRpbWVzdGFtcCB0byB2ZXJpZnkgdGhlIHRyYW5zYWN0aW9uIGFnYWluc3QgYXMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfVxuICAgKiBAcGFyYW0gbG9ja3RpbWUgT3B0aW9uYWwuIFRoZSBsb2NrdGltZSBmaWVsZCBjcmVhdGVkIGluIHRoZSByZXN1bHRpbmcgb3V0cHV0c1xuICAgKiBAcGFyYW0gdG9UaHJlc2hvbGQgT3B0aW9uYWwuIFRoZSBudW1iZXIgb2Ygc2lnbmF0dXJlcyByZXF1aXJlZCB0byBzcGVuZCB0aGUgZnVuZHMgaW4gdGhlIHJlY2VpdmVkIFVUWE9cbiAgICogQHBhcmFtIGNoYW5nZVRocmVzaG9sZCBPcHRpb25hbC4gVGhlIG51bWJlciBvZiBzaWduYXR1cmVzIHJlcXVpcmVkIHRvIHNwZW5kIHRoZSBmdW5kcyBpbiB0aGUgcmVzdWx0YW50IGNoYW5nZSBVVFhPXG4gICAqXG4gICAqIEByZXR1cm5zIEFuIHVuc2lnbmVkIHRyYW5zYWN0aW9uIGNyZWF0ZWQgZnJvbSB0aGUgcGFzc2VkIGluIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqL1xuICBidWlsZEV4cG9ydFR4ID0gYXN5bmMgKFxuICAgIG5ldHdvcmtJRDogbnVtYmVyLFxuICAgIGJsb2NrY2hhaW5JRDogQnVmZmVyLFxuICAgIGFtb3VudDogQk4sXG4gICAgYW1vdW50QXNzZXRJRDogQnVmZmVyLFxuICAgIHRvQWRkcmVzc2VzOiBCdWZmZXJbXSxcbiAgICBmcm9tU2lnbmVyOiBGcm9tU2lnbmVyLFxuICAgIGRlc3RpbmF0aW9uQ2hhaW46IEJ1ZmZlcixcbiAgICBjaGFuZ2VBZGRyZXNzZXM6IEJ1ZmZlcltdID0gdW5kZWZpbmVkLFxuICAgIGZlZTogQk4gPSB6ZXJvLFxuICAgIGZlZUFzc2V0SUQ6IEJ1ZmZlciA9IHVuZGVmaW5lZCxcbiAgICBtZW1vOiBCdWZmZXIgPSB1bmRlZmluZWQsXG4gICAgYXNPZjogQk4gPSB6ZXJvLFxuICAgIGxvY2t0aW1lOiBCTiA9IHplcm8sXG4gICAgdG9UaHJlc2hvbGQ6IG51bWJlciA9IDEsXG4gICAgY2hhbmdlVGhyZXNob2xkOiBudW1iZXIgPSAxXG4gICk6IFByb21pc2U8VW5zaWduZWRUeD4gPT4ge1xuICAgIGxldCBpbnM6IFRyYW5zZmVyYWJsZUlucHV0W10gPSBbXVxuICAgIGxldCBvdXRzOiBUcmFuc2ZlcmFibGVPdXRwdXRbXSA9IFtdXG4gICAgbGV0IG93bmVyczogT3V0cHV0T3duZXJzW10gPSBbXVxuXG4gICAgaWYgKHR5cGVvZiBjaGFuZ2VBZGRyZXNzZXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNoYW5nZUFkZHJlc3NlcyA9IHRvQWRkcmVzc2VzXG4gICAgfVxuXG4gICAgaWYgKGFtb3VudC5lcSh6ZXJvKSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZmVlQXNzZXRJRCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgZmVlQXNzZXRJRCA9IGFtb3VudEFzc2V0SURcbiAgICB9IGVsc2UgaWYgKGZlZUFzc2V0SUQudG9TdHJpbmcoXCJoZXhcIikgIT09IGFtb3VudEFzc2V0SUQudG9TdHJpbmcoXCJoZXhcIikpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICB0aHJvdyBuZXcgRmVlQXNzZXRFcnJvcihcbiAgICAgICAgXCJFcnJvciAtIENhbWlub0V4ZWN1dG9yLmJ1aWxkRXhwb3J0VHg6IFwiICtcbiAgICAgICAgICBgZmVlQXNzZXRJRCBtdXN0IG1hdGNoIGF2YXhBc3NldElEYFxuICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0IGFhZDogQXNzZXRBbW91bnREZXN0aW5hdGlvbiA9IG5ldyBBc3NldEFtb3VudERlc3RpbmF0aW9uKFxuICAgICAgdG9BZGRyZXNzZXMsXG4gICAgICB0b1RocmVzaG9sZCxcbiAgICAgIGZyb21TaWduZXIuZnJvbSxcbiAgICAgIGZyb21TaWduZXIuc2lnbmVyLFxuICAgICAgY2hhbmdlQWRkcmVzc2VzLFxuICAgICAgY2hhbmdlVGhyZXNob2xkXG4gICAgKVxuXG4gICAgbGV0IHNpbmdsZUFzc2V0ID0gdHJ1ZVxuICAgIGlmIChhbW91bnRBc3NldElELnRvU3RyaW5nKFwiaGV4XCIpID09PSBmZWVBc3NldElELnRvU3RyaW5nKFwiaGV4XCIpKSB7XG4gICAgICBhYWQuYWRkQXNzZXRBbW91bnQoYW1vdW50QXNzZXRJRCwgemVybywgZmVlLmFkZChhbW91bnQpKVxuICAgIH0gZWxzZSB7XG4gICAgICBzaW5nbGVBc3NldCA9IGZhbHNlXG4gICAgICBhYWQuYWRkQXNzZXRBbW91bnQoYW1vdW50QXNzZXRJRCwgYW1vdW50LCB6ZXJvKVxuICAgICAgaWYgKHRoaXMuX2ZlZUNoZWNrKGZlZSwgZmVlQXNzZXRJRCkpIHtcbiAgICAgICAgYWFkLmFkZEFzc2V0QW1vdW50KGZlZUFzc2V0SUQsIHplcm8sIGZlZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBtaW5TcGVuZGFibGVFcnI6IEVycm9yID0gYXdhaXQgdGhpcy5zcGVuZGVyLmdldE1pbmltdW1TcGVuZGFibGUoXG4gICAgICBhYWQsXG4gICAgICBhc09mLFxuICAgICAgbG9ja3RpbWUsXG4gICAgICBcIlVubG9ja2VkXCJcbiAgICApXG4gICAgaWYgKHR5cGVvZiBtaW5TcGVuZGFibGVFcnIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlucyA9IGFhZC5nZXRJbnB1dHMoKVxuICAgICAgb3V0cyA9IHNpbmdsZUFzc2V0ID8gYWFkLmdldEFsbE91dHB1dHMoKSA6IGFhZC5nZXRDaGFuZ2VPdXRwdXRzKClcbiAgICAgIGV4cG9ydHMgPSBzaW5nbGVBc3NldCA/IFtdIDogYWFkLmdldE91dHB1dHMoKVxuICAgICAgb3duZXJzID0gYWFkLmdldE91dHB1dE93bmVycygpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG1pblNwZW5kYWJsZUVyclxuICAgIH1cblxuICAgIGNvbnN0IGJhc2VUeDogRXhwb3J0VHggPSBuZXcgRXhwb3J0VHgoXG4gICAgICBuZXR3b3JrSUQsXG4gICAgICBibG9ja2NoYWluSUQsXG4gICAgICBvdXRzLFxuICAgICAgaW5zLFxuICAgICAgbWVtbyxcbiAgICAgIGRlc3RpbmF0aW9uQ2hhaW4sXG4gICAgICBleHBvcnRzLmxlbmd0aCA+IDBcbiAgICAgICAgPyBleHBvcnRzXG4gICAgICAgIDogW1xuICAgICAgICAgICAgbmV3IFNFQ1BUcmFuc2Zlck91dHB1dChcbiAgICAgICAgICAgICAgYW1vdW50LFxuICAgICAgICAgICAgICB0b0FkZHJlc3NlcyxcbiAgICAgICAgICAgICAgbG9ja3RpbWUsXG4gICAgICAgICAgICAgIHRvVGhyZXNob2xkXG4gICAgICAgICAgICApLm1ha2VUcmFuc2ZlcmFibGUoYW1vdW50QXNzZXRJRClcbiAgICAgICAgICBdXG4gICAgKVxuXG4gICAgYmFzZVR4LnNldE91dHB1dE93bmVycyhvd25lcnMpXG4gICAgcmV0dXJuIG5ldyBVbnNpZ25lZFR4KGJhc2VUeClcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gdW5zaWduZWQgW1tBZGRTdWJuZXRWYWxpZGF0b3JUeF1dIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gbmV0d29ya0lEIE5ldHdvcmtpZCwgW1tEZWZhdWx0TmV0d29ya0lEXV1cbiAgICogQHBhcmFtIGJsb2NrY2hhaW5JRCBCbG9ja2NoYWluaWQsIGRlZmF1bHQgdW5kZWZpbmVkXG4gICAqIEBwYXJhbSBmcm9tU2lnbmVyIFRoZSBhZGRyZXNzZXMgYmVpbmcgdXNlZCB0byBzZW5kIGFuZCB2ZXJpZnkgdGhlIGZ1bmRzIGZyb20gdGhlIFVUWE9zIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9XG4gICAqIEBwYXJhbSBjaGFuZ2VBZGRyZXNzZXMgQW4gYXJyYXkgb2YgYWRkcmVzc2VzIGFzIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IHdobyBnZXRzIHRoZSBjaGFuZ2UgbGVmdG92ZXIgZnJvbSB0aGUgZmVlIHBheW1lbnRcbiAgICogQHBhcmFtIG5vZGVJRCBUaGUgbm9kZSBJRCBvZiB0aGUgdmFsaWRhdG9yIGJlaW5nIGFkZGVkLlxuICAgKiBAcGFyYW0gc3RhcnRUaW1lIFRoZSBVbml4IHRpbWUgd2hlbiB0aGUgdmFsaWRhdG9yIHN0YXJ0cyB2YWxpZGF0aW5nIHRoZSBQcmltYXJ5IE5ldHdvcmsuXG4gICAqIEBwYXJhbSBlbmRUaW1lIFRoZSBVbml4IHRpbWUgd2hlbiB0aGUgdmFsaWRhdG9yIHN0b3BzIHZhbGlkYXRpbmcgdGhlIFByaW1hcnkgTmV0d29yayAoYW5kIHN0YWtlZCBBVkFYIGlzIHJldHVybmVkKS5cbiAgICogQHBhcmFtIHdlaWdodCBUaGUgYW1vdW50IG9mIHdlaWdodCBmb3IgdGhpcyBzdWJuZXQgdmFsaWRhdG9yLlxuICAgKiBAcGFyYW0gZmVlIE9wdGlvbmFsLiBUaGUgYW1vdW50IG9mIGZlZXMgdG8gYnVybiBpbiBpdHMgc21hbGxlc3QgZGVub21pbmF0aW9uLCByZXByZXNlbnRlZCBhcyB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfVxuICAgKiBAcGFyYW0gZmVlQXNzZXRJRCBPcHRpb25hbC4gVGhlIGFzc2V0SUQgb2YgdGhlIGZlZXMgYmVpbmcgYnVybmVkLlxuICAgKiBAcGFyYW0gbWVtbyBPcHRpb25hbCBjb250YWlucyBhcmJpdHJhcnkgYnl0ZXMsIHVwIHRvIDI1NiBieXRlc1xuICAgKiBAcGFyYW0gYXNPZiBPcHRpb25hbC4gVGhlIHRpbWVzdGFtcCB0byB2ZXJpZnkgdGhlIHRyYW5zYWN0aW9uIGFnYWluc3QgYXMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfVxuICAgKiBAcGFyYW0gc3VibmV0QXV0aCBPcHRpb25hbC4gQW4gQXV0aCBzdHJ1Y3Qgd2hpY2ggY29udGFpbnMgdGhlIHN1Ym5ldCBBdXRoIGFuZCB0aGUgc2lnbmVycy5cbiAgICogQHBhcmFtIGNoYW5nZVRocmVzaG9sZCBPcHRpb25hbC4gVGhlIG51bWJlciBvZiBzaWduYXR1cmVzIHJlcXVpcmVkIHRvIHNwZW5kIHRoZSBmdW5kcyBpbiB0aGUgcmVzdWx0YW50IGNoYW5nZSBVVFhPXG4gICAqXG4gICAqIEByZXR1cm5zIEFuIHVuc2lnbmVkIHRyYW5zYWN0aW9uIGNyZWF0ZWQgZnJvbSB0aGUgcGFzc2VkIGluIHBhcmFtZXRlcnMuXG4gICAqL1xuICBidWlsZEFkZFN1Ym5ldFZhbGlkYXRvclR4ID0gYXN5bmMgKFxuICAgIG5ldHdvcmtJRDogbnVtYmVyID0gRGVmYXVsdE5ldHdvcmtJRCxcbiAgICBibG9ja2NoYWluSUQ6IEJ1ZmZlcixcbiAgICBmcm9tU2lnbmVyOiBGcm9tU2lnbmVyLFxuICAgIGNoYW5nZUFkZHJlc3NlczogQnVmZmVyW10sXG4gICAgbm9kZUlEOiBCdWZmZXIsXG4gICAgc3RhcnRUaW1lOiBCTixcbiAgICBlbmRUaW1lOiBCTixcbiAgICB3ZWlnaHQ6IEJOLFxuICAgIHN1Ym5ldElEOiBzdHJpbmcsXG4gICAgZmVlOiBCTiA9IHplcm8sXG4gICAgZmVlQXNzZXRJRDogQnVmZmVyID0gdW5kZWZpbmVkLFxuICAgIG1lbW86IEJ1ZmZlciA9IHVuZGVmaW5lZCxcbiAgICBhc09mOiBCTiA9IHplcm8sXG4gICAgc3VibmV0QXV0aDogQXV0aCA9IHsgYWRkcmVzc2VzOiBbXSwgdGhyZXNob2xkOiAwLCBzaWduZXI6IFtdIH0sXG4gICAgY2hhbmdlVGhyZXNob2xkOiBudW1iZXIgPSAxXG4gICk6IFByb21pc2U8VW5zaWduZWRUeD4gPT4ge1xuICAgIGxldCBpbnM6IFRyYW5zZmVyYWJsZUlucHV0W10gPSBbXVxuICAgIGxldCBvdXRzOiBUcmFuc2ZlcmFibGVPdXRwdXRbXSA9IFtdXG4gICAgbGV0IG93bmVyczogT3V0cHV0T3duZXJzW10gPSBbXVxuXG4gICAgY29uc3Qgbm93OiBCTiA9IFVuaXhOb3coKVxuICAgIGlmIChzdGFydFRpbWUubHQobm93KSB8fCBlbmRUaW1lLmx0ZShzdGFydFRpbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQ2FtaW5vRXhlY3V0b3IuYnVpbGRBZGRTdWJuZXRWYWxpZGF0b3JUeCAtLSBzdGFydFRpbWUgbXVzdCBiZSBpbiB0aGUgZnV0dXJlIGFuZCBlbmRUaW1lIG11c3QgY29tZSBhZnRlciBzdGFydFRpbWVcIlxuICAgICAgKVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9mZWVDaGVjayhmZWUsIGZlZUFzc2V0SUQpKSB7XG4gICAgICBjb25zdCBhYWQ6IEFzc2V0QW1vdW50RGVzdGluYXRpb24gPSBuZXcgQXNzZXRBbW91bnREZXN0aW5hdGlvbihcbiAgICAgICAgW10sXG4gICAgICAgIDAsXG4gICAgICAgIGZyb21TaWduZXIuZnJvbSxcbiAgICAgICAgZnJvbVNpZ25lci5zaWduZXIsXG4gICAgICAgIGNoYW5nZUFkZHJlc3NlcyxcbiAgICAgICAgY2hhbmdlVGhyZXNob2xkXG4gICAgICApXG5cbiAgICAgIGFhZC5hZGRBc3NldEFtb3VudChmZWVBc3NldElELCB6ZXJvLCBmZWUpXG4gICAgICBjb25zdCBtaW5TcGVuZGFibGVFcnI6IEVycm9yID0gYXdhaXQgdGhpcy5zcGVuZGVyLmdldE1pbmltdW1TcGVuZGFibGUoXG4gICAgICAgIGFhZCxcbiAgICAgICAgYXNPZixcbiAgICAgICAgemVybyxcbiAgICAgICAgdGhpcy5jYW1pbm9FbmFibGVkID8gXCJVbmxvY2tlZFwiIDogXCJTdGFrZVwiXG4gICAgICApXG4gICAgICBpZiAodHlwZW9mIG1pblNwZW5kYWJsZUVyciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpbnMgPSBhYWQuZ2V0SW5wdXRzKClcbiAgICAgICAgb3V0cyA9IGFhZC5nZXRBbGxPdXRwdXRzKClcbiAgICAgICAgb3duZXJzID0gYWFkLmdldE91dHB1dE93bmVycygpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBtaW5TcGVuZGFibGVFcnJcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBiYXNlVHg6IEFkZFN1Ym5ldFZhbGlkYXRvclR4ID0gbmV3IEFkZFN1Ym5ldFZhbGlkYXRvclR4KFxuICAgICAgbmV0d29ya0lELFxuICAgICAgYmxvY2tjaGFpbklELFxuICAgICAgb3V0cyxcbiAgICAgIGlucyxcbiAgICAgIG1lbW8sXG4gICAgICBub2RlSUQsXG4gICAgICBzdGFydFRpbWUsXG4gICAgICBlbmRUaW1lLFxuICAgICAgd2VpZ2h0LFxuICAgICAgc3VibmV0SURcbiAgICApXG4gICAgc3VibmV0QXV0aC5zaWduZXIuZm9yRWFjaCgoc3VibmV0U2lnbmVyKTogdm9pZCA9PiB7XG4gICAgICBiYXNlVHguYWRkU2lnbmF0dXJlSWR4KHN1Ym5ldFNpZ25lclswXSwgc3VibmV0U2lnbmVyWzFdKVxuICAgIH0pXG5cbiAgICAvLyBXZSBuZWVkIHRvIGZldGNoIHRoZSBBVVRIIGZvciBsYXRlciBtc2lnIHZlcmlmaWNhdGlvblxuICAgIC8vIEZvciBub3cgd2UgdXNlIHNpbXBseSB3aGF0IHdlIGdldCBpbiBzdWJuZXRBdXRoXG4gICAgb3duZXJzLnB1c2goXG4gICAgICBuZXcgT3V0cHV0T3duZXJzKHN1Ym5ldEF1dGguYWRkcmVzc2VzLCBaZXJvQk4sIHN1Ym5ldEF1dGgudGhyZXNob2xkKVxuICAgIClcblxuICAgIGlmICh0aGlzLmNhbWlub0VuYWJsZWQpIHtcbiAgICAgIGJhc2VUeC5pbmNsdWRlTm9kZVNpZ25hdHVyZSgpXG4gICAgICBvd25lcnMucHVzaChuZXcgT3V0cHV0T3duZXJzKFtub2RlSURdLCBaZXJvQk4sIDEpKVxuICAgIH1cbiAgICBiYXNlVHguc2V0T3V0cHV0T3duZXJzKG93bmVycylcbiAgICByZXR1cm4gbmV3IFVuc2lnbmVkVHgoYmFzZVR4KVxuICB9XG5cbiAgLyoqXG4gICAqIENsYXNzIHJlcHJlc2VudGluZyBhbiB1bnNpZ25lZCBbW0FkZERlbGVnYXRvclR4XV0gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSBuZXR3b3JrSUQgTmV0d29ya2lkLCBbW0RlZmF1bHROZXR3b3JrSURdXVxuICAgKiBAcGFyYW0gYmxvY2tjaGFpbklEIEJsb2NrY2hhaW5pZCwgZGVmYXVsdCB1bmRlZmluZWRcbiAgICogQHBhcmFtIGF2YXhBc3NldElEIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IG9mIHRoZSBhc3NldCBJRCBmb3IgQVZBWFxuICAgKiBAcGFyYW0gdG9BZGRyZXNzZXMgQW4gYXJyYXkgb2YgYWRkcmVzc2VzIGFzIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IHJlY2lldmVzIHRoZSBzdGFrZSBhdCB0aGUgZW5kIG9mIHRoZSBzdGFraW5nIHBlcmlvZFxuICAgKiBAcGFyYW0gZnJvbVNpZ25lciBUaGUgYWRkcmVzc2VzIGJlaW5nIHVzZWQgdG8gc2VuZCBhbmQgdmVyaWZ5IHRoZSBmdW5kcyBmcm9tIHRoZSBVVFhPcyB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfVxuICAgKiBAcGFyYW0gY2hhbmdlQWRkcmVzc2VzIEFuIGFycmF5IG9mIGFkZHJlc3NlcyBhcyB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSB3aG8gZ2V0cyB0aGUgY2hhbmdlIGxlZnRvdmVyIGZyb20gdGhlIHN0YWtpbmcgcGF5bWVudFxuICAgKiBAcGFyYW0gbm9kZUlEIFRoZSBub2RlIElEIG9mIHRoZSB2YWxpZGF0b3IgYmVpbmcgYWRkZWQuXG4gICAqIEBwYXJhbSBzdGFydFRpbWUgVGhlIFVuaXggdGltZSB3aGVuIHRoZSB2YWxpZGF0b3Igc3RhcnRzIHZhbGlkYXRpbmcgdGhlIFByaW1hcnkgTmV0d29yay5cbiAgICogQHBhcmFtIGVuZFRpbWUgVGhlIFVuaXggdGltZSB3aGVuIHRoZSB2YWxpZGF0b3Igc3RvcHMgdmFsaWRhdGluZyB0aGUgUHJpbWFyeSBOZXR3b3JrIChhbmQgc3Rha2VkIEFWQVggaXMgcmV0dXJuZWQpLlxuICAgKiBAcGFyYW0gc3Rha2VBbW91bnQgQSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfSBmb3IgdGhlIGFtb3VudCBvZiBzdGFrZSB0byBiZSBkZWxlZ2F0ZWQgaW4gbkFWQVguXG4gICAqIEBwYXJhbSByZXdhcmRMb2NrdGltZSBUaGUgbG9ja3RpbWUgZmllbGQgY3JlYXRlZCBpbiB0aGUgcmVzdWx0aW5nIHJld2FyZCBvdXRwdXRzXG4gICAqIEBwYXJhbSByZXdhcmRUaHJlc2hvbGQgVGhlIG51bWJlciBvZiBzaWduYXR1cmVzIHJlcXVpcmVkIHRvIHNwZW5kIHRoZSBmdW5kcyBpbiB0aGUgcmVzdWx0YW50IHJld2FyZCBVVFhPXG4gICAqIEBwYXJhbSByZXdhcmRBZGRyZXNzZXMgVGhlIGFkZHJlc3NlcyB0aGUgdmFsaWRhdG9yIHJld2FyZCBnb2VzLlxuICAgKiBAcGFyYW0gZmVlIE9wdGlvbmFsLiBUaGUgYW1vdW50IG9mIGZlZXMgdG8gYnVybiBpbiBpdHMgc21hbGxlc3QgZGVub21pbmF0aW9uLCByZXByZXNlbnRlZCBhcyB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfVxuICAgKiBAcGFyYW0gZmVlQXNzZXRJRCBPcHRpb25hbC4gVGhlIGFzc2V0SUQgb2YgdGhlIGZlZXMgYmVpbmcgYnVybmVkLlxuICAgKiBAcGFyYW0gbWVtbyBPcHRpb25hbCBjb250YWlucyBhcmJpdHJhcnkgYnl0ZXMsIHVwIHRvIDI1NiBieXRlc1xuICAgKiBAcGFyYW0gYXNPZiBPcHRpb25hbC4gVGhlIHRpbWVzdGFtcCB0byB2ZXJpZnkgdGhlIHRyYW5zYWN0aW9uIGFnYWluc3QgYXMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfVxuICAgKiBAcGFyYW0gdG9UaHJlc2hvbGQgT3B0aW9uYWwuIFRoZSBudW1iZXIgb2Ygc2lnbmF0dXJlcyByZXF1aXJlZCB0byBzcGVuZCB0aGUgZnVuZHMgaW4gdGhlIHN0YWtlIFVUWE9cbiAgICogQHBhcmFtIGNoYW5nZVRocmVzaG9sZCBPcHRpb25hbC4gVGhlIG51bWJlciBvZiBzaWduYXR1cmVzIHJlcXVpcmVkIHRvIHNwZW5kIHRoZSBmdW5kcyBpbiB0aGUgY2hhbmdlIFVUWE9cbiAgICpcbiAgICogQHJldHVybnMgQW4gdW5zaWduZWQgdHJhbnNhY3Rpb24gY3JlYXRlZCBmcm9tIHRoZSBwYXNzZWQgaW4gcGFyYW1ldGVycy5cbiAgICovXG4gIGJ1aWxkQWRkRGVsZWdhdG9yVHggPSBhc3luYyAoXG4gICAgbmV0d29ya0lEOiBudW1iZXIgPSBEZWZhdWx0TmV0d29ya0lELFxuICAgIGJsb2NrY2hhaW5JRDogQnVmZmVyLFxuICAgIGF2YXhBc3NldElEOiBCdWZmZXIsXG4gICAgdG9BZGRyZXNzZXM6IEJ1ZmZlcltdLFxuICAgIGZyb21TaWduZXI6IEZyb21TaWduZXIsXG4gICAgY2hhbmdlQWRkcmVzc2VzOiBCdWZmZXJbXSxcbiAgICBub2RlSUQ6IEJ1ZmZlcixcbiAgICBzdGFydFRpbWU6IEJOLFxuICAgIGVuZFRpbWU6IEJOLFxuICAgIHN0YWtlQW1vdW50OiBCTixcbiAgICByZXdhcmRMb2NrdGltZTogQk4sXG4gICAgcmV3YXJkVGhyZXNob2xkOiBudW1iZXIsXG4gICAgcmV3YXJkQWRkcmVzc2VzOiBCdWZmZXJbXSxcbiAgICBmZWU6IEJOID0gemVybyxcbiAgICBmZWVBc3NldElEOiBCdWZmZXIgPSB1bmRlZmluZWQsXG4gICAgbWVtbzogQnVmZmVyID0gdW5kZWZpbmVkLFxuICAgIGFzT2Y6IEJOID0gemVybyxcbiAgICB0b1RocmVzaG9sZDogbnVtYmVyID0gMSxcbiAgICBjaGFuZ2VUaHJlc2hvbGQ6IG51bWJlciA9IDFcbiAgKTogUHJvbWlzZTxVbnNpZ25lZFR4PiA9PiB7XG4gICAgaWYgKHRoaXMuY2FtaW5vRW5hYmxlZCkge1xuICAgICAgdGhyb3cgbmV3IFByb3RvY29sRXJyb3IoXG4gICAgICAgIFwiYnVpbGRBZGREZWxlZ2F0b3JUeCAtIE5vdCBzdXBwb3J0ZWQgaW4gQ2FtaW5vIG1vZGVcIlxuICAgICAgKVxuICAgIH1cblxuICAgIGlmIChyZXdhcmRUaHJlc2hvbGQgPiByZXdhcmRBZGRyZXNzZXMubGVuZ3RoKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgdGhyb3cgbmV3IFRocmVzaG9sZEVycm9yKFxuICAgICAgICBcIkVycm9yIC0gVVRYT1NldC5idWlsZEFkZERlbGVnYXRvclR4OiByZXdhcmQgdGhyZXNob2xkIGlzIGdyZWF0ZXIgdGhhbiBudW1iZXIgb2YgYWRkcmVzc2VzXCJcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNoYW5nZUFkZHJlc3NlcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2hhbmdlQWRkcmVzc2VzID0gdG9BZGRyZXNzZXNcbiAgICB9XG5cbiAgICBsZXQgaW5zOiBUcmFuc2ZlcmFibGVJbnB1dFtdID0gW11cbiAgICBsZXQgb3V0czogVHJhbnNmZXJhYmxlT3V0cHV0W10gPSBbXVxuICAgIGxldCBzdGFrZU91dHM6IFRyYW5zZmVyYWJsZU91dHB1dFtdID0gW11cbiAgICBsZXQgb3duZXJzOiBPdXRwdXRPd25lcnNbXSA9IFtdXG5cbiAgICBjb25zdCBub3c6IEJOID0gVW5peE5vdygpXG4gICAgaWYgKHN0YXJ0VGltZS5sdChub3cpIHx8IGVuZFRpbWUubHRlKHN0YXJ0VGltZSkpIHtcbiAgICAgIHRocm93IG5ldyBUaW1lRXJyb3IoXG4gICAgICAgIFwiVVRYT1NldC5idWlsZEFkZERlbGVnYXRvclR4IC0tIHN0YXJ0VGltZSBtdXN0IGJlIGluIHRoZSBmdXR1cmUgYW5kIGVuZFRpbWUgbXVzdCBjb21lIGFmdGVyIHN0YXJ0VGltZVwiXG4gICAgICApXG4gICAgfVxuXG4gICAgY29uc3QgYWFkOiBBc3NldEFtb3VudERlc3RpbmF0aW9uID0gbmV3IEFzc2V0QW1vdW50RGVzdGluYXRpb24oXG4gICAgICB0b0FkZHJlc3NlcyxcbiAgICAgIHRvVGhyZXNob2xkLFxuICAgICAgZnJvbVNpZ25lci5mcm9tLFxuICAgICAgZnJvbVNpZ25lci5zaWduZXIsXG4gICAgICBjaGFuZ2VBZGRyZXNzZXMsXG4gICAgICBjaGFuZ2VUaHJlc2hvbGRcbiAgICApXG4gICAgaWYgKGF2YXhBc3NldElELnRvU3RyaW5nKFwiaGV4XCIpID09PSBmZWVBc3NldElELnRvU3RyaW5nKFwiaGV4XCIpKSB7XG4gICAgICBhYWQuYWRkQXNzZXRBbW91bnQoYXZheEFzc2V0SUQsIHN0YWtlQW1vdW50LCBmZWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFhZC5hZGRBc3NldEFtb3VudChhdmF4QXNzZXRJRCwgc3Rha2VBbW91bnQsIHplcm8pXG4gICAgICBpZiAodGhpcy5fZmVlQ2hlY2soZmVlLCBmZWVBc3NldElEKSkge1xuICAgICAgICBhYWQuYWRkQXNzZXRBbW91bnQoZmVlQXNzZXRJRCwgemVybywgZmVlKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG1pblNwZW5kYWJsZUVycjogRXJyb3IgPSBhd2FpdCB0aGlzLnNwZW5kZXIuZ2V0TWluaW11bVNwZW5kYWJsZShcbiAgICAgIGFhZCxcbiAgICAgIGFzT2YsXG4gICAgICB6ZXJvLFxuICAgICAgXCJTdGFrZVwiXG4gICAgKVxuICAgIGlmICh0eXBlb2YgbWluU3BlbmRhYmxlRXJyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpbnMgPSBhYWQuZ2V0SW5wdXRzKClcbiAgICAgIG91dHMgPSBhYWQuZ2V0Q2hhbmdlT3V0cHV0cygpXG4gICAgICBzdGFrZU91dHMgPSBhYWQuZ2V0T3V0cHV0cygpXG4gICAgICBvd25lcnMgPSBhYWQuZ2V0T3V0cHV0T3duZXJzKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbWluU3BlbmRhYmxlRXJyXG4gICAgfVxuXG4gICAgY29uc3QgcmV3YXJkT3V0cHV0T3duZXJzOiBTRUNQT3duZXJPdXRwdXQgPSBuZXcgU0VDUE93bmVyT3V0cHV0KFxuICAgICAgcmV3YXJkQWRkcmVzc2VzLFxuICAgICAgcmV3YXJkTG9ja3RpbWUsXG4gICAgICByZXdhcmRUaHJlc2hvbGRcbiAgICApXG5cbiAgICBjb25zdCBiYXNlVHg6IEFkZERlbGVnYXRvclR4ID0gbmV3IEFkZERlbGVnYXRvclR4KFxuICAgICAgbmV0d29ya0lELFxuICAgICAgYmxvY2tjaGFpbklELFxuICAgICAgb3V0cyxcbiAgICAgIGlucyxcbiAgICAgIG1lbW8sXG4gICAgICBub2RlSUQsXG4gICAgICBzdGFydFRpbWUsXG4gICAgICBlbmRUaW1lLFxuICAgICAgc3Rha2VBbW91bnQsXG4gICAgICBzdGFrZU91dHMsXG4gICAgICBuZXcgUGFyc2VhYmxlT3V0cHV0KHJld2FyZE91dHB1dE93bmVycylcbiAgICApXG4gICAgYmFzZVR4LnNldE91dHB1dE93bmVycyhvd25lcnMpXG4gICAgcmV0dXJuIG5ldyBVbnNpZ25lZFR4KGJhc2VUeClcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gdW5zaWduZWQgW1tBZGRWYWxpZGF0b3JUeF1dIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gbmV0d29ya0lEIE5ldHdvcmtJRCwgW1tEZWZhdWx0TmV0d29ya0lEXV1cbiAgICogQHBhcmFtIGJsb2NrY2hhaW5JRCBCbG9ja2NoYWluSUQsIGRlZmF1bHQgdW5kZWZpbmVkXG4gICAqIEBwYXJhbSBhdmF4QXNzZXRJRCB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSBvZiB0aGUgYXNzZXQgSUQgZm9yIEFWQVhcbiAgICogQHBhcmFtIHRvQWRkcmVzc2VzIEFuIGFycmF5IG9mIGFkZHJlc3NlcyBhcyB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSByZWNpZXZlcyB0aGUgc3Rha2UgYXQgdGhlIGVuZCBvZiB0aGUgc3Rha2luZyBwZXJpb2RcbiAgICogQHBhcmFtIGZyb21TaWduZXIgVGhlIGFkZHJlc3NlcyBiZWluZyB1c2VkIHRvIHNlbmQgYW5kIHZlcmlmeSB0aGUgZnVuZHMgZnJvbSB0aGUgVVRYT3Mge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn1cbiAgICogQHBhcmFtIGNoYW5nZUFkZHJlc3NlcyBBbiBhcnJheSBvZiBhZGRyZXNzZXMgYXMge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gd2hvIGdldHMgdGhlIGNoYW5nZSBsZWZ0b3ZlciBmcm9tIHRoZSBzdGFraW5nIHBheW1lbnRcbiAgICogQHBhcmFtIG5vZGVJRCBUaGUgbm9kZSBJRCBvZiB0aGUgdmFsaWRhdG9yIGJlaW5nIGFkZGVkLlxuICAgKiBAcGFyYW0gc3RhcnRUaW1lIFRoZSBVbml4IHRpbWUgd2hlbiB0aGUgdmFsaWRhdG9yIHN0YXJ0cyB2YWxpZGF0aW5nIHRoZSBQcmltYXJ5IE5ldHdvcmsuXG4gICAqIEBwYXJhbSBlbmRUaW1lIFRoZSBVbml4IHRpbWUgd2hlbiB0aGUgdmFsaWRhdG9yIHN0b3BzIHZhbGlkYXRpbmcgdGhlIFByaW1hcnkgTmV0d29yayAoYW5kIHN0YWtlZCBBVkFYIGlzIHJldHVybmVkKS5cbiAgICogQHBhcmFtIHN0YWtlQW1vdW50IEEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn0gZm9yIHRoZSBhbW91bnQgb2Ygc3Rha2UgdG8gYmUgZGVsZWdhdGVkIGluIG5BVkFYLlxuICAgKiBAcGFyYW0gcmV3YXJkTG9ja3RpbWUgVGhlIGxvY2t0aW1lIGZpZWxkIGNyZWF0ZWQgaW4gdGhlIHJlc3VsdGluZyByZXdhcmQgb3V0cHV0c1xuICAgKiBAcGFyYW0gcmV3YXJkVGhyZXNob2xkIFRoZSBudW1iZXIgb2Ygc2lnbmF0dXJlcyByZXF1aXJlZCB0byBzcGVuZCB0aGUgZnVuZHMgaW4gdGhlIHJlc3VsdGFudCByZXdhcmQgVVRYT1xuICAgKiBAcGFyYW0gcmV3YXJkQWRkcmVzc2VzIFRoZSBhZGRyZXNzZXMgdGhlIHZhbGlkYXRvciByZXdhcmQgZ29lcy5cbiAgICogQHBhcmFtIGRlbGVnYXRpb25GZWUgQSBudW1iZXIgZm9yIHRoZSBwZXJjZW50YWdlIG9mIHJld2FyZCB0byBiZSBnaXZlbiB0byB0aGUgdmFsaWRhdG9yIHdoZW4gc29tZW9uZSBkZWxlZ2F0ZXMgdG8gdGhlbS4gTXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC5cbiAgICogQHBhcmFtIG1pblN0YWtlIEEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn0gcmVwcmVzZW50aW5nIHRoZSBtaW5pbXVtIHN0YWtlIHJlcXVpcmVkIHRvIHZhbGlkYXRlIG9uIHRoaXMgbmV0d29yay5cbiAgICogQHBhcmFtIGZlZSBPcHRpb25hbC4gVGhlIGFtb3VudCBvZiBmZWVzIHRvIGJ1cm4gaW4gaXRzIHNtYWxsZXN0IGRlbm9taW5hdGlvbiwgcmVwcmVzZW50ZWQgYXMge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn1cbiAgICogQHBhcmFtIGZlZUFzc2V0SUQgT3B0aW9uYWwuIFRoZSBhc3NldElEIG9mIHRoZSBmZWVzIGJlaW5nIGJ1cm5lZC5cbiAgICogQHBhcmFtIG1lbW8gT3B0aW9uYWwgY29udGFpbnMgYXJiaXRyYXJ5IGJ5dGVzLCB1cCB0byAyNTYgYnl0ZXNcbiAgICogQHBhcmFtIGFzT2YgT3B0aW9uYWwuIFRoZSB0aW1lc3RhbXAgdG8gdmVyaWZ5IHRoZSB0cmFuc2FjdGlvbiBhZ2FpbnN0IGFzIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn1cbiAgICogQHBhcmFtIHRvVGhyZXNob2xkIE9wdGlvbmFsLiBUaGUgbnVtYmVyIG9mIHNpZ25hdHVyZXMgcmVxdWlyZWQgdG8gc3BlbmQgdGhlIGZ1bmRzIGluIHRoZSBzdGFrZSBVVFhPXG4gICAqIEBwYXJhbSBjaGFuZ2VUaHJlc2hvbGQgT3B0aW9uYWwuIFRoZSBudW1iZXIgb2Ygc2lnbmF0dXJlcyByZXF1aXJlZCB0byBzcGVuZCB0aGUgZnVuZHMgaW4gdGhlIGNoYW5nZSBVVFhPXG4gICAqL1xuICBidWlsZEFkZFZhbGlkYXRvclR4ID0gYXN5bmMgKFxuICAgIG5ldHdvcmtJRDogbnVtYmVyID0gRGVmYXVsdE5ldHdvcmtJRCxcbiAgICBibG9ja2NoYWluSUQ6IEJ1ZmZlcixcbiAgICB0b0FkZHJlc3NlczogQnVmZmVyW10sXG4gICAgZnJvbVNpZ25lcjogRnJvbVNpZ25lcixcbiAgICBjaGFuZ2VBZGRyZXNzZXM6IEJ1ZmZlcltdLFxuICAgIG5vZGVJRDogQnVmZmVyLFxuICAgIHN0YXJ0VGltZTogQk4sXG4gICAgZW5kVGltZTogQk4sXG4gICAgc3Rha2VBbW91bnQ6IEJOLFxuICAgIHN0YWtlQXNzZXRJRDogQnVmZmVyLFxuICAgIHJld2FyZExvY2t0aW1lOiBCTixcbiAgICByZXdhcmRUaHJlc2hvbGQ6IG51bWJlcixcbiAgICByZXdhcmRBZGRyZXNzZXM6IEJ1ZmZlcltdLFxuICAgIGRlbGVnYXRpb25GZWU6IG51bWJlcixcbiAgICBmZWU6IEJOID0gemVybyxcbiAgICBmZWVBc3NldElEOiBCdWZmZXIgPSB1bmRlZmluZWQsXG4gICAgbWVtbzogQnVmZmVyID0gdW5kZWZpbmVkLFxuICAgIGFzT2Y6IEJOID0gVW5peE5vdygpLFxuICAgIHRvVGhyZXNob2xkOiBudW1iZXIgPSAxLFxuICAgIGNoYW5nZVRocmVzaG9sZDogbnVtYmVyID0gMVxuICApOiBQcm9taXNlPFVuc2lnbmVkVHg+ID0+IHtcbiAgICBpZiAodGhpcy5jYW1pbm9FbmFibGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2UgYnVpbGRDYW1pbm9BZGRWYWxpZGF0b3JUeFwiKVxuICAgIH1cblxuICAgIGxldCBpbnM6IFRyYW5zZmVyYWJsZUlucHV0W10gPSBbXVxuICAgIGxldCBvdXRzOiBUcmFuc2ZlcmFibGVPdXRwdXRbXSA9IFtdXG4gICAgbGV0IHN0YWtlT3V0czogVHJhbnNmZXJhYmxlT3V0cHV0W10gPSBbXVxuICAgIGxldCBvd25lcnM6IE91dHB1dE93bmVyc1tdID0gW11cblxuICAgIGNvbnN0IG5vdzogQk4gPSBVbml4Tm93KClcbiAgICBpZiAoc3RhcnRUaW1lLmx0KG5vdykgfHwgZW5kVGltZS5sdGUoc3RhcnRUaW1lKSkge1xuICAgICAgdGhyb3cgbmV3IFRpbWVFcnJvcihcbiAgICAgICAgXCJVVFhPU2V0LmJ1aWxkQWRkVmFsaWRhdG9yVHggLS0gc3RhcnRUaW1lIG11c3QgYmUgaW4gdGhlIGZ1dHVyZSBhbmQgZW5kVGltZSBtdXN0IGNvbWUgYWZ0ZXIgc3RhcnRUaW1lXCJcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAoZGVsZWdhdGlvbkZlZSA+IDEwMCB8fCBkZWxlZ2F0aW9uRmVlIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFRpbWVFcnJvcihcbiAgICAgICAgXCJVVFhPU2V0LmJ1aWxkQWRkVmFsaWRhdG9yVHggLS0gc3RhcnRUaW1lIG11c3QgYmUgaW4gdGhlIHJhbmdlIG9mIDAgdG8gMTAwLCBpbmNsdXNpdmVseVwiXG4gICAgICApXG4gICAgfVxuXG4gICAgY29uc3QgYWFkOiBBc3NldEFtb3VudERlc3RpbmF0aW9uID0gbmV3IEFzc2V0QW1vdW50RGVzdGluYXRpb24oXG4gICAgICB0b0FkZHJlc3NlcyxcbiAgICAgIHRvVGhyZXNob2xkLFxuICAgICAgZnJvbVNpZ25lci5mcm9tLFxuICAgICAgZnJvbVNpZ25lci5zaWduZXIsXG4gICAgICBjaGFuZ2VBZGRyZXNzZXMsXG4gICAgICBjaGFuZ2VUaHJlc2hvbGRcbiAgICApXG4gICAgaWYgKHN0YWtlQXNzZXRJRC50b1N0cmluZyhcImhleFwiKSA9PT0gZmVlQXNzZXRJRC50b1N0cmluZyhcImhleFwiKSkge1xuICAgICAgYWFkLmFkZEFzc2V0QW1vdW50KHN0YWtlQXNzZXRJRCwgc3Rha2VBbW91bnQsIGZlZSlcbiAgICB9IGVsc2Uge1xuICAgICAgYWFkLmFkZEFzc2V0QW1vdW50KHN0YWtlQXNzZXRJRCwgc3Rha2VBbW91bnQsIHplcm8pXG4gICAgICBpZiAodGhpcy5fZmVlQ2hlY2soZmVlLCBmZWVBc3NldElEKSkge1xuICAgICAgICBhYWQuYWRkQXNzZXRBbW91bnQoZmVlQXNzZXRJRCwgemVybywgZmVlKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG1pblNwZW5kYWJsZUVycjogRXJyb3IgPSBhd2FpdCB0aGlzLnNwZW5kZXIuZ2V0TWluaW11bVNwZW5kYWJsZShcbiAgICAgIGFhZCxcbiAgICAgIGFzT2YsXG4gICAgICB6ZXJvLFxuICAgICAgXCJTdGFrZVwiXG4gICAgKVxuICAgIGlmICh0eXBlb2YgbWluU3BlbmRhYmxlRXJyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpbnMgPSBhYWQuZ2V0SW5wdXRzKClcbiAgICAgIG91dHMgPSBhYWQuZ2V0Q2hhbmdlT3V0cHV0cygpXG4gICAgICBzdGFrZU91dHMgPSBhYWQuZ2V0T3V0cHV0cygpXG4gICAgICBvd25lcnMgPSBhYWQuZ2V0T3V0cHV0T3duZXJzKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbWluU3BlbmRhYmxlRXJyXG4gICAgfVxuXG4gICAgY29uc3QgcmV3YXJkT3V0cHV0T3duZXJzOiBTRUNQT3duZXJPdXRwdXQgPSBuZXcgU0VDUE93bmVyT3V0cHV0KFxuICAgICAgcmV3YXJkQWRkcmVzc2VzLFxuICAgICAgcmV3YXJkTG9ja3RpbWUsXG4gICAgICByZXdhcmRUaHJlc2hvbGRcbiAgICApXG5cbiAgICBjb25zdCBiYXNlVHg6IEFkZFZhbGlkYXRvclR4ID0gbmV3IEFkZFZhbGlkYXRvclR4KFxuICAgICAgbmV0d29ya0lELFxuICAgICAgYmxvY2tjaGFpbklELFxuICAgICAgb3V0cyxcbiAgICAgIGlucyxcbiAgICAgIG1lbW8sXG4gICAgICBub2RlSUQsXG4gICAgICBzdGFydFRpbWUsXG4gICAgICBlbmRUaW1lLFxuICAgICAgc3Rha2VBbW91bnQsXG4gICAgICBzdGFrZU91dHMsXG4gICAgICBuZXcgUGFyc2VhYmxlT3V0cHV0KHJld2FyZE91dHB1dE93bmVycyksXG4gICAgICBkZWxlZ2F0aW9uRmVlXG4gICAgKVxuICAgIGJhc2VUeC5zZXRPdXRwdXRPd25lcnMob3duZXJzKVxuICAgIHJldHVybiBuZXcgVW5zaWduZWRUeChiYXNlVHgpXG4gIH1cblxuICAvKipcbiAgICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIHVuc2lnbmVkIFtbQ3JlYXRlU3VibmV0VHhdXSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIG5ldHdvcmtJRCBOZXR3b3JraWQsIFtbRGVmYXVsdE5ldHdvcmtJRF1dXG4gICAqIEBwYXJhbSBibG9ja2NoYWluSUQgQmxvY2tjaGFpbmlkLCBkZWZhdWx0IHVuZGVmaW5lZFxuICAgKiBAcGFyYW0gZnJvbVNpZ25lciBUaGUgYWRkcmVzc2VzIGJlaW5nIHVzZWQgdG8gc2VuZCBhbmQgdmVyaWZ5IHRoZSBmdW5kcyBmcm9tIHRoZSBVVFhPcyB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfVxuICAgKiBAcGFyYW0gY2hhbmdlQWRkcmVzc2VzIFRoZSBhZGRyZXNzZXMgdGhhdCBjYW4gc3BlbmQgdGhlIGNoYW5nZSByZW1haW5pbmcgZnJvbSB0aGUgc3BlbnQgVVRYT3MuXG4gICAqIEBwYXJhbSBzdWJuZXRPd25lckFkZHJlc3NlcyBBbiBhcnJheSBvZiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSBmb3IgdGhlIGFkZHJlc3NlcyB0byBhZGQgdG8gYSBzdWJuZXRcbiAgICogQHBhcmFtIHN1Ym5ldE93bmVyVGhyZXNob2xkIFRoZSBudW1iZXIgb2Ygb3duZXJzJ3Mgc2lnbmF0dXJlcyByZXF1aXJlZCB0byBhZGQgYSB2YWxpZGF0b3IgdG8gdGhlIG5ldHdvcmtcbiAgICogQHBhcmFtIGZlZSBPcHRpb25hbC4gVGhlIGFtb3VudCBvZiBmZWVzIHRvIGJ1cm4gaW4gaXRzIHNtYWxsZXN0IGRlbm9taW5hdGlvbiwgcmVwcmVzZW50ZWQgYXMge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn1cbiAgICogQHBhcmFtIGZlZUFzc2V0SUQgT3B0aW9uYWwuIFRoZSBhc3NldElEIG9mIHRoZSBmZWVzIGJlaW5nIGJ1cm5lZFxuICAgKiBAcGFyYW0gbWVtbyBPcHRpb25hbCBjb250YWlucyBhcmJpdHJhcnkgYnl0ZXMsIHVwIHRvIDI1NiBieXRlc1xuICAgKiBAcGFyYW0gYXNPZiBPcHRpb25hbC4gVGhlIHRpbWVzdGFtcCB0byB2ZXJpZnkgdGhlIHRyYW5zYWN0aW9uIGFnYWluc3QgYXMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfVxuICAgKiBAcGFyYW0gY2hhbmdlVGhyZXNob2xkIE9wdGlvbmFsLiBUaGUgbnVtYmVyIG9mIHNpZ25hdHVyZXMgcmVxdWlyZWQgdG8gc3BlbmQgdGhlIGZ1bmRzIGluIHRoZSByZXN1bHRhbnQgY2hhbmdlIFVUWE9cbiAgICpcbiAgICogQHJldHVybnMgQW4gdW5zaWduZWQgdHJhbnNhY3Rpb24gY3JlYXRlZCBmcm9tIHRoZSBwYXNzZWQgaW4gcGFyYW1ldGVycy5cbiAgICovXG4gIGJ1aWxkQ3JlYXRlU3VibmV0VHggPSBhc3luYyAoXG4gICAgbmV0d29ya0lEOiBudW1iZXIgPSBEZWZhdWx0TmV0d29ya0lELFxuICAgIGJsb2NrY2hhaW5JRDogQnVmZmVyLFxuICAgIGZyb21TaWduZXI6IEZyb21TaWduZXIsXG4gICAgY2hhbmdlQWRkcmVzc2VzOiBCdWZmZXJbXSxcbiAgICBzdWJuZXRPd25lckFkZHJlc3NlczogQnVmZmVyW10sXG4gICAgc3VibmV0T3duZXJUaHJlc2hvbGQ6IG51bWJlcixcbiAgICBmZWU6IEJOID0gemVybyxcbiAgICBmZWVBc3NldElEOiBCdWZmZXIgPSB1bmRlZmluZWQsXG4gICAgbWVtbzogQnVmZmVyID0gdW5kZWZpbmVkLFxuICAgIGFzT2Y6IEJOID0gemVybyxcbiAgICBjaGFuZ2VUaHJlc2hvbGQ6IG51bWJlciA9IDFcbiAgKTogUHJvbWlzZTxVbnNpZ25lZFR4PiA9PiB7XG4gICAgbGV0IGluczogVHJhbnNmZXJhYmxlSW5wdXRbXSA9IFtdXG4gICAgbGV0IG91dHM6IFRyYW5zZmVyYWJsZU91dHB1dFtdID0gW11cbiAgICBsZXQgb3duZXJzOiBPdXRwdXRPd25lcnNbXSA9IFtdXG5cbiAgICBpZiAodGhpcy5fZmVlQ2hlY2soZmVlLCBmZWVBc3NldElEKSkge1xuICAgICAgY29uc3QgYWFkOiBBc3NldEFtb3VudERlc3RpbmF0aW9uID0gbmV3IEFzc2V0QW1vdW50RGVzdGluYXRpb24oXG4gICAgICAgIFtdLFxuICAgICAgICAwLFxuICAgICAgICBmcm9tU2lnbmVyLmZyb20sXG4gICAgICAgIGZyb21TaWduZXIuc2lnbmVyLFxuICAgICAgICBjaGFuZ2VBZGRyZXNzZXMsXG4gICAgICAgIGNoYW5nZVRocmVzaG9sZFxuICAgICAgKVxuXG4gICAgICBhYWQuYWRkQXNzZXRBbW91bnQoZmVlQXNzZXRJRCwgemVybywgZmVlKVxuICAgICAgY29uc3QgbWluU3BlbmRhYmxlRXJyOiBFcnJvciA9IGF3YWl0IHRoaXMuc3BlbmRlci5nZXRNaW5pbXVtU3BlbmRhYmxlKFxuICAgICAgICBhYWQsXG4gICAgICAgIGFzT2YsXG4gICAgICAgIHplcm8sXG4gICAgICAgIFwiVW5sb2NrZWRcIlxuICAgICAgKVxuICAgICAgaWYgKHR5cGVvZiBtaW5TcGVuZGFibGVFcnIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaW5zID0gYWFkLmdldElucHV0cygpXG4gICAgICAgIG91dHMgPSBhYWQuZ2V0QWxsT3V0cHV0cygpXG4gICAgICAgIG93bmVycyA9IGFhZC5nZXRPdXRwdXRPd25lcnMoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbWluU3BlbmRhYmxlRXJyXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbG9ja3RpbWU6IEJOID0gbmV3IEJOKDApXG4gICAgY29uc3Qgc3VibmV0T3duZXJzOiBTRUNQT3duZXJPdXRwdXQgPSBuZXcgU0VDUE93bmVyT3V0cHV0KFxuICAgICAgc3VibmV0T3duZXJBZGRyZXNzZXMsXG4gICAgICBsb2NrdGltZSxcbiAgICAgIHN1Ym5ldE93bmVyVGhyZXNob2xkXG4gICAgKVxuICAgIGNvbnN0IGJhc2VUeDogQ3JlYXRlU3VibmV0VHggPSBuZXcgQ3JlYXRlU3VibmV0VHgoXG4gICAgICBuZXR3b3JrSUQsXG4gICAgICBibG9ja2NoYWluSUQsXG4gICAgICBvdXRzLFxuICAgICAgaW5zLFxuICAgICAgbWVtbyxcbiAgICAgIHN1Ym5ldE93bmVyc1xuICAgIClcbiAgICBiYXNlVHguc2V0T3V0cHV0T3duZXJzKG93bmVycylcbiAgICByZXR1cm4gbmV3IFVuc2lnbmVkVHgoYmFzZVR4KVxuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkIGFuIHVuc2lnbmVkIFtbQ3JlYXRlQ2hhaW5UeF1dLlxuICAgKlxuICAgKiBAcGFyYW0gbmV0d29ya0lEIE5ldHdvcmtpZCwgW1tEZWZhdWx0TmV0d29ya0lEXV1cbiAgICogQHBhcmFtIGJsb2NrY2hhaW5JRCBCbG9ja2NoYWluaWQsIGRlZmF1bHQgdW5kZWZpbmVkXG4gICAqIEBwYXJhbSBmcm9tU2lnbmVyIFRoZSBhZGRyZXNzZXMgYmVpbmcgdXNlZCB0byBzZW5kIGFuZCB2ZXJpZnkgdGhlIGZ1bmRzIGZyb20gdGhlIFVUWE9zIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9XG4gICAqIEBwYXJhbSBjaGFuZ2VBZGRyZXNzZXMgVGhlIGFkZHJlc3NlcyB0aGF0IGNhbiBzcGVuZCB0aGUgY2hhbmdlIHJlbWFpbmluZyBmcm9tIHRoZSBzcGVudCBVVFhPcy5cbiAgICogQHBhcmFtIHN1Ym5ldElEIE9wdGlvbmFsIElEIG9mIHRoZSBTdWJuZXQgdGhhdCB2YWxpZGF0ZXMgdGhpcyBibG9ja2NoYWluXG4gICAqIEBwYXJhbSBjaGFpbk5hbWUgT3B0aW9uYWwgQSBodW1hbiByZWFkYWJsZSBuYW1lIGZvciB0aGUgY2hhaW47IG5lZWQgbm90IGJlIHVuaXF1ZVxuICAgKiBAcGFyYW0gdm1JRCBPcHRpb25hbCBJRCBvZiB0aGUgVk0gcnVubmluZyBvbiB0aGUgbmV3IGNoYWluXG4gICAqIEBwYXJhbSBmeElEcyBPcHRpb25hbCBJRHMgb2YgdGhlIGZlYXR1cmUgZXh0ZW5zaW9ucyBydW5uaW5nIG9uIHRoZSBuZXcgY2hhaW5cbiAgICogQHBhcmFtIGdlbmVzaXNEYXRhIE9wdGlvbmFsIEJ5dGUgcmVwcmVzZW50YXRpb24gb2YgZ2VuZXNpcyBzdGF0ZSBvZiB0aGUgbmV3IGNoYWluXG4gICAqIEBwYXJhbSBmZWUgT3B0aW9uYWwuIFRoZSBhbW91bnQgb2YgZmVlcyB0byBidXJuIGluIGl0cyBzbWFsbGVzdCBkZW5vbWluYXRpb24sIHJlcHJlc2VudGVkIGFzIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcy98Qk59XG4gICAqIEBwYXJhbSBmZWVBc3NldElEIE9wdGlvbmFsLiBUaGUgYXNzZXRJRCBvZiB0aGUgZmVlcyBiZWluZyBidXJuZWRcbiAgICogQHBhcmFtIG1lbW8gT3B0aW9uYWwgY29udGFpbnMgYXJiaXRyYXJ5IGJ5dGVzLCB1cCB0byAyNTYgYnl0ZXNcbiAgICogQHBhcmFtIGFzT2YgT3B0aW9uYWwuIFRoZSB0aW1lc3RhbXAgdG8gdmVyaWZ5IHRoZSB0cmFuc2FjdGlvbiBhZ2FpbnN0IGFzIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn1cbiAgICogQHBhcmFtIHN1Ym5ldEF1dGggT3B0aW9uYWwuIEFuIEF1dGggc3RydWN0IHRvIHNpZ24gZm9yIHRoZSBTdWJuZXQuXG4gICAqIEBwYXJhbSBjaGFuZ2VUaHJlc2hvbGQgT3B0aW9uYWwuIFRoZSBudW1iZXIgb2Ygc2lnbmF0dXJlcyByZXF1aXJlZCB0byBzcGVuZCB0aGUgZnVuZHMgaW4gdGhlIHJlc3VsdGFudCBjaGFuZ2UgVVRYT1xuICAgKlxuICAgKiBAcmV0dXJucyBBbiB1bnNpZ25lZCBDcmVhdGVDaGFpblR4IGNyZWF0ZWQgZnJvbSB0aGUgcGFzc2VkIGluIHBhcmFtZXRlcnMuXG4gICAqL1xuICBidWlsZENyZWF0ZUNoYWluVHggPSBhc3luYyAoXG4gICAgbmV0d29ya0lEOiBudW1iZXIgPSBEZWZhdWx0TmV0d29ya0lELFxuICAgIGJsb2NrY2hhaW5JRDogQnVmZmVyLFxuICAgIGZyb21TaWduZXI6IEZyb21TaWduZXIsXG4gICAgY2hhbmdlQWRkcmVzc2VzOiBCdWZmZXJbXSxcbiAgICBzdWJuZXRJRDogc3RyaW5nIHwgQnVmZmVyID0gdW5kZWZpbmVkLFxuICAgIGNoYWluTmFtZTogc3RyaW5nID0gdW5kZWZpbmVkLFxuICAgIHZtSUQ6IHN0cmluZyA9IHVuZGVmaW5lZCxcbiAgICBmeElEczogc3RyaW5nW10gPSB1bmRlZmluZWQsXG4gICAgZ2VuZXNpc0RhdGE6IHN0cmluZyB8IEdlbmVzaXNEYXRhID0gdW5kZWZpbmVkLFxuICAgIGZlZTogQk4gPSB6ZXJvLFxuICAgIGZlZUFzc2V0SUQ6IEJ1ZmZlciA9IHVuZGVmaW5lZCxcbiAgICBtZW1vOiBCdWZmZXIgPSB1bmRlZmluZWQsXG4gICAgYXNPZjogQk4gPSB6ZXJvLFxuICAgIHN1Ym5ldEF1dGg6IEF1dGggPSB7IGFkZHJlc3NlczogW10sIHRocmVzaG9sZDogMCwgc2lnbmVyOiBbXSB9LFxuICAgIGNoYW5nZVRocmVzaG9sZDogbnVtYmVyID0gMVxuICApOiBQcm9taXNlPFVuc2lnbmVkVHg+ID0+IHtcbiAgICBsZXQgaW5zOiBUcmFuc2ZlcmFibGVJbnB1dFtdID0gW11cbiAgICBsZXQgb3V0czogVHJhbnNmZXJhYmxlT3V0cHV0W10gPSBbXVxuICAgIGxldCBvd25lcnM6IE91dHB1dE93bmVyc1tdID0gW11cblxuICAgIGlmICh0aGlzLl9mZWVDaGVjayhmZWUsIGZlZUFzc2V0SUQpKSB7XG4gICAgICBjb25zdCBhYWQ6IEFzc2V0QW1vdW50RGVzdGluYXRpb24gPSBuZXcgQXNzZXRBbW91bnREZXN0aW5hdGlvbihcbiAgICAgICAgW10sXG4gICAgICAgIDAsXG4gICAgICAgIGZyb21TaWduZXIuZnJvbSxcbiAgICAgICAgZnJvbVNpZ25lci5zaWduZXIsXG4gICAgICAgIGNoYW5nZUFkZHJlc3NlcyxcbiAgICAgICAgY2hhbmdlVGhyZXNob2xkXG4gICAgICApXG5cbiAgICAgIGFhZC5hZGRBc3NldEFtb3VudChmZWVBc3NldElELCB6ZXJvLCBmZWUpXG4gICAgICBjb25zdCBtaW5TcGVuZGFibGVFcnI6IEVycm9yID0gYXdhaXQgdGhpcy5zcGVuZGVyLmdldE1pbmltdW1TcGVuZGFibGUoXG4gICAgICAgIGFhZCxcbiAgICAgICAgYXNPZixcbiAgICAgICAgemVybyxcbiAgICAgICAgXCJVbmxvY2tlZFwiXG4gICAgICApXG4gICAgICBpZiAodHlwZW9mIG1pblNwZW5kYWJsZUVyciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpbnMgPSBhYWQuZ2V0SW5wdXRzKClcbiAgICAgICAgb3V0cyA9IGFhZC5nZXRBbGxPdXRwdXRzKClcbiAgICAgICAgb3duZXJzID0gYWFkLmdldE91dHB1dE93bmVycygpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBtaW5TcGVuZGFibGVFcnJcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBiYXNlVHg6IENyZWF0ZUNoYWluVHggPSBuZXcgQ3JlYXRlQ2hhaW5UeChcbiAgICAgIG5ldHdvcmtJRCxcbiAgICAgIGJsb2NrY2hhaW5JRCxcbiAgICAgIG91dHMsXG4gICAgICBpbnMsXG4gICAgICBtZW1vLFxuICAgICAgc3VibmV0SUQsXG4gICAgICBjaGFpbk5hbWUsXG4gICAgICB2bUlELFxuICAgICAgZnhJRHMsXG4gICAgICBnZW5lc2lzRGF0YVxuICAgIClcbiAgICBzdWJuZXRBdXRoLnNpZ25lci5mb3JFYWNoKChzdWJuZXRBdXRoU2lnbmVyKTogdm9pZCA9PiB7XG4gICAgICBiYXNlVHguYWRkU2lnbmF0dXJlSWR4KHN1Ym5ldEF1dGhTaWduZXJbMF0sIHN1Ym5ldEF1dGhTaWduZXJbMV0pXG4gICAgfSlcblxuICAgIC8vIFdlIG5lZWQgdG8gZmV0Y2ggdGhlIEFVVEggZm9yIGxhdGVyIG1zaWcgdmVyaWZpY2F0aW9uXG4gICAgLy8gRm9yIG5vdyB3ZSB1c2Ugc2ltcGx5IHdoYXQgd2UgZ2V0IGluIHN1Ym5ldEF1dGhcbiAgICBvd25lcnMucHVzaChcbiAgICAgIG5ldyBPdXRwdXRPd25lcnMoc3VibmV0QXV0aC5hZGRyZXNzZXMsIFplcm9CTiwgc3VibmV0QXV0aC50aHJlc2hvbGQpXG4gICAgKVxuXG4gICAgYmFzZVR4LnNldE91dHB1dE93bmVycyhvd25lcnMpXG4gICAgcmV0dXJuIG5ldyBVbnNpZ25lZFR4KGJhc2VUeClcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gd2hpY2ggY3JlYXRlcyBhbiB1bnNpZ25lZCBbW0NhbWlub0FkZFZhbGlkYXRvclR4XV0uIEZvciBtb3JlIGdyYW51bGFyIGNvbnRyb2wsIHlvdSBtYXkgY3JlYXRlIHlvdXIgb3duXG4gICAqIFtbVW5zaWduZWRUeF1dIG1hbnVhbGx5IGFuZCBpbXBvcnQgdGhlIFtbQ2FtaW5vQWRkVmFsaWRhdG9yVHhdXSBjbGFzcyBkaXJlY3RseS5cbiAgICpcbiAgICogQHBhcmFtIG5ldHdvcmtJRCBOZXR3b3JraWQsIFtbRGVmYXVsdE5ldHdvcmtJRF1dXG4gICAqIEBwYXJhbSBibG9ja2NoYWluSUQgQmxvY2tjaGFpbmlkLCBkZWZhdWx0IHVuZGVmaW5lZFxuICAgKiBAcGFyYW0gdG9BZGRyZXNzZXMgQW4gYXJyYXkgb2YgYWRkcmVzc2VzIGFzIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IHdobyByZWNlaXZlZCB0aGUgc3Rha2VkIHRva2VucyBhdCB0aGUgZW5kIG9mIHRoZSBzdGFraW5nIHBlcmlvZFxuICAgKiBAcGFyYW0gZnJvbVNpZ25lciBUaGUgYWRkcmVzc2VzIGJlaW5nIHVzZWQgdG8gc2VuZCBhbmQgdmVyaWZ5IHRoZSBmdW5kcyBmcm9tIHRoZSBVVFhPcyB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfVxuICAgKiBAcGFyYW0gY2hhbmdlQWRkcmVzc2VzIEFuIGFycmF5IG9mIGFkZHJlc3NlcyBhcyB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSB3aG8gZ2V0cyB0aGUgY2hhbmdlIGxlZnRvdmVyIGZyb20gdGhlIGZlZSBwYXltZW50XG4gICAqIEBwYXJhbSBub2RlSUQgVGhlIG5vZGUgSUQgb2YgdGhlIHZhbGlkYXRvciBiZWluZyBhZGRlZC5cbiAgICogQHBhcmFtIG5vZGVPd25lciBUaGUgYWRkcmVzcyBhbmQgc2lnbmF0dXJlIGluZGljZXMgb2YgdGhlIHJlZ2lzdGVyZWQgbm9kZUlkIG93bmVyLlxuICAgKiBAcGFyYW0gc3RhcnRUaW1lIFRoZSBVbml4IHRpbWUgd2hlbiB0aGUgdmFsaWRhdG9yIHN0YXJ0cyB2YWxpZGF0aW5nIHRoZSBQcmltYXJ5IE5ldHdvcmsuXG4gICAqIEBwYXJhbSBlbmRUaW1lIFRoZSBVbml4IHRpbWUgd2hlbiB0aGUgdmFsaWRhdG9yIHN0b3BzIHZhbGlkYXRpbmcgdGhlIFByaW1hcnkgTmV0d29yayAoYW5kIHN0YWtlZCBBVkFYIGlzIHJldHVybmVkKS5cbiAgICogQHBhcmFtIHN0YWtlQW1vdW50IFRoZSBhbW91bnQgYmVpbmcgZGVsZWdhdGVkIGFzIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn1cbiAgICogQHBhcmFtIHJld2FyZEFkZHJlc3NlcyBUaGUgYWRkcmVzc2VzIHdoaWNoIHdpbGwgcmVjaWV2ZSB0aGUgcmV3YXJkcyBmcm9tIHRoZSBkZWxlZ2F0ZWQgc3Rha2UuXG4gICAqIEBwYXJhbSByZXdhcmRMb2NrdGltZSBPcHRpb25hbC4gVGhlIGxvY2t0aW1lIGZpZWxkIGNyZWF0ZWQgaW4gdGhlIHJlc3VsdGluZyByZXdhcmQgb3V0cHV0c1xuICAgKiBAcGFyYW0gcmV3YXJkVGhyZXNob2xkIE9waW9uYWwuIFRoZSBudW1iZXIgb2Ygc2lnbmF0dXJlcyByZXF1aXJlZCB0byBzcGVuZCB0aGUgZnVuZHMgaW4gdGhlIHJlc3VsdGFudCByZXdhcmQgVVRYTy4gRGVmYXVsdCAxLlxuICAgKiBAcGFyYW0gbWVtbyBPcHRpb25hbCBjb250YWlucyBhcmJpdHJhcnkgYnl0ZXMsIHVwIHRvIDI1NiBieXRlc1xuICAgKiBAcGFyYW0gYXNPZiBPcHRpb25hbC4gVGhlIHRpbWVzdGFtcCB0byB2ZXJpZnkgdGhlIHRyYW5zYWN0aW9uIGFnYWluc3QgYXMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfVxuICAgKiBAcGFyYW0gdG9UaHJlc2hvbGQgT3B0aW9uYWwuIFRoZSBudW1iZXIgb2Ygc2lnbmF0dXJlcyByZXF1aXJlZCB0byBzcGVuZCB0aGUgZnVuZHMgaW4gdGhlIHJlY2VpdmVkIFVUWE9cbiAgICogQHBhcmFtIGNoYW5nZVRocmVzaG9sZCBPcHRpb25hbC4gVGhlIG51bWJlciBvZiBzaWduYXR1cmVzIHJlcXVpcmVkIHRvIHNwZW5kIHRoZSBmdW5kcyBpbiB0aGUgcmVzdWx0YW50IGNoYW5nZSBVVFhPXG4gICAqXG4gICAqIEByZXR1cm5zIEFuIHVuc2lnbmVkIHRyYW5zYWN0aW9uIGNyZWF0ZWQgZnJvbSB0aGUgcGFzc2VkIGluIHBhcmFtZXRlcnMuXG4gICAqL1xuICBidWlsZENhbWlub0FkZFZhbGlkYXRvclR4ID0gYXN5bmMgKFxuICAgIG5ldHdvcmtJRDogbnVtYmVyID0gRGVmYXVsdE5ldHdvcmtJRCxcbiAgICBibG9ja2NoYWluSUQ6IEJ1ZmZlcixcbiAgICB0bzogQnVmZmVyW10sXG4gICAgZnJvbVNpZ25lcjogRnJvbVNpZ25lcixcbiAgICBjaGFuZ2U6IEJ1ZmZlcltdLFxuICAgIG5vZGVJRDogQnVmZmVyLFxuICAgIG5vZGVPd25lcjogTm9kZU93bmVyLFxuICAgIHN0YXJ0VGltZTogQk4sXG4gICAgZW5kVGltZTogQk4sXG4gICAgc3Rha2VBbW91bnQ6IEJOLFxuICAgIHN0YWtlQXNzZXRJRDogQnVmZmVyLFxuICAgIHJld2FyZHM6IEJ1ZmZlcltdLFxuICAgIHJld2FyZExvY2t0aW1lOiBCTiA9IHplcm8sXG4gICAgcmV3YXJkVGhyZXNob2xkOiBudW1iZXIgPSAxLFxuICAgIG1lbW86IEJ1ZmZlciA9IHVuZGVmaW5lZCxcbiAgICBhc09mOiBCTiA9IHplcm8sXG4gICAgdG9UaHJlc2hvbGQ6IG51bWJlciA9IDEsXG4gICAgY2hhbmdlVGhyZXNob2xkOiBudW1iZXIgPSAxXG4gICk6IFByb21pc2U8VW5zaWduZWRUeD4gPT4ge1xuICAgIGxldCBpbnM6IFRyYW5zZmVyYWJsZUlucHV0W10gPSBbXVxuICAgIGxldCBvdXRzOiBUcmFuc2ZlcmFibGVPdXRwdXRbXSA9IFtdXG4gICAgbGV0IG93bmVyczogT3V0cHV0T3duZXJzW10gPSBbXVxuXG4gICAgY29uc3Qgbm93OiBCTiA9IFVuaXhOb3coKVxuICAgIGlmIChzdGFydFRpbWUubHQobm93KSB8fCBlbmRUaW1lLmx0ZShzdGFydFRpbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgVGltZUVycm9yKFxuICAgICAgICBcImJ1aWxkQ2FtaW5vQWRkVmFsaWRhdG9yVHggLS0gc3RhcnRUaW1lIG11c3QgYmUgaW4gdGhlIGZ1dHVyZSBhbmQgZW5kVGltZSBtdXN0IGNvbWUgYWZ0ZXIgc3RhcnRUaW1lXCJcbiAgICAgIClcbiAgICB9XG5cbiAgICBjb25zdCBhYWQ6IEFzc2V0QW1vdW50RGVzdGluYXRpb24gPSBuZXcgQXNzZXRBbW91bnREZXN0aW5hdGlvbihcbiAgICAgIHRvLFxuICAgICAgdG9UaHJlc2hvbGQsXG4gICAgICBmcm9tU2lnbmVyLmZyb20sXG4gICAgICBmcm9tU2lnbmVyLnNpZ25lcixcbiAgICAgIGNoYW5nZSxcbiAgICAgIGNoYW5nZVRocmVzaG9sZFxuICAgIClcblxuICAgIGFhZC5hZGRBc3NldEFtb3VudChzdGFrZUFzc2V0SUQsIHN0YWtlQW1vdW50LCBuZXcgQk4oMCkpXG5cbiAgICBjb25zdCBtaW5TcGVuZGFibGVFcnI6IEVycm9yID0gYXdhaXQgdGhpcy5zcGVuZGVyLmdldE1pbmltdW1TcGVuZGFibGUoXG4gICAgICBhYWQsXG4gICAgICBhc09mLFxuICAgICAgemVybyxcbiAgICAgIFwiQm9uZFwiXG4gICAgKVxuICAgIGlmICh0eXBlb2YgbWluU3BlbmRhYmxlRXJyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpbnMgPSBhYWQuZ2V0SW5wdXRzKClcbiAgICAgIG91dHMgPSBhYWQuZ2V0QWxsT3V0cHV0cygpXG4gICAgICBvd25lcnMgPSBhYWQuZ2V0T3V0cHV0T3duZXJzKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbWluU3BlbmRhYmxlRXJyXG4gICAgfVxuXG4gICAgY29uc3QgcmV3YXJkT3V0cHV0T3duZXJzOiBTRUNQT3duZXJPdXRwdXQgPSBuZXcgU0VDUE93bmVyT3V0cHV0KFxuICAgICAgcmV3YXJkcyxcbiAgICAgIHJld2FyZExvY2t0aW1lLFxuICAgICAgcmV3YXJkVGhyZXNob2xkXG4gICAgKVxuXG4gICAgY29uc3QgYmFzZVR4OiBDYW1pbm9BZGRWYWxpZGF0b3JUeCA9IG5ldyBDYW1pbm9BZGRWYWxpZGF0b3JUeChcbiAgICAgIG5ldHdvcmtJRCxcbiAgICAgIGJsb2NrY2hhaW5JRCxcbiAgICAgIG91dHMsXG4gICAgICBpbnMsXG4gICAgICBtZW1vLFxuICAgICAgbm9kZUlELFxuICAgICAgc3RhcnRUaW1lLFxuICAgICAgZW5kVGltZSxcbiAgICAgIHN0YWtlQW1vdW50LFxuICAgICAgbmV3IFBhcnNlYWJsZU91dHB1dChyZXdhcmRPdXRwdXRPd25lcnMpXG4gICAgKVxuXG4gICAgbm9kZU93bmVyLmF1dGguZm9yRWFjaCgobykgPT4ge1xuICAgICAgYmFzZVR4LmFkZFNpZ25hdHVyZUlkeChvWzBdLCBvWzFdKVxuICAgIH0pXG4gICAgb3duZXJzLnB1c2gobmV3IE91dHB1dE93bmVycyhbbm9kZU93bmVyLmFkZHJlc3NdLCBaZXJvQk4sIDEpKVxuXG4gICAgYmFzZVR4LnNldE91dHB1dE93bmVycyhvd25lcnMpXG4gICAgcmV0dXJuIG5ldyBVbnNpZ25lZFR4KGJhc2VUeClcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZCBhbiB1bnNpZ25lZCBbW0FkZHJlc3NTdGF0ZVR4XV0uXG4gICAqXG4gICAqIEBwYXJhbSB2ZXJzaW9uIE9wdGlvbmFsLiBUcmFuc2FjdGlvbiB2ZXJzaW9uIG51bWJlciwgZGVmYXVsdCAwLlxuICAgKiBAcGFyYW0gbmV0d29ya0lEIE5ldHdvcmtpZCwgW1tEZWZhdWx0TmV0d29ya0lEXV1cbiAgICogQHBhcmFtIGJsb2NrY2hhaW5JRCBCbG9ja2NoYWluaWQsIGRlZmF1bHQgdW5kZWZpbmVkXG4gICAqIEBwYXJhbSBmcm9tU2lnbmVyIFRoZSBhZGRyZXNzZXMgYmVpbmcgdXNlZCB0byBzZW5kIGFuZCB2ZXJpZnkgdGhlIGZ1bmRzIGZyb20gdGhlIFVUWE9zIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9XG4gICAqIEBwYXJhbSBjaGFuZ2VBZGRyZXNzZXMgVGhlIGFkZHJlc3NlcyB0aGF0IGNhbiBzcGVuZCB0aGUgY2hhbmdlIHJlbWFpbmluZyBmcm9tIHRoZSBzcGVudCBVVFhPcy5cbiAgICogQHBhcmFtIGFkZHJlc3MgVGhlIGFkZHJlc3MgdG8gYWx0ZXIgc3RhdGUuXG4gICAqIEBwYXJhbSBzdGF0ZSBUaGUgc3RhdGUgdG8gc2V0IG9yIHJlbW92ZSBvbiB0aGUgZ2l2ZW4gYWRkcmVzc1xuICAgKiBAcGFyYW0gcmVtb3ZlIE9wdGlvbmFsLiBGbGFnIGlmIHN0YXRlIHNob3VsZCBiZSBhcHBsaWVkIG9yIHJlbW92ZWRcbiAgICogQHBhcmFtIGZlZSBPcHRpb25hbC4gVGhlIGFtb3VudCBvZiBmZWVzIHRvIGJ1cm4gaW4gaXRzIHNtYWxsZXN0IGRlbm9taW5hdGlvbiwgcmVwcmVzZW50ZWQgYXMge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn1cbiAgICogQHBhcmFtIGZlZUFzc2V0SUQgT3B0aW9uYWwuIFRoZSBhc3NldElEIG9mIHRoZSBmZWVzIGJlaW5nIGJ1cm5lZFxuICAgKiBAcGFyYW0gbWVtbyBPcHRpb25hbCBjb250YWlucyBhcmJpdHJhcnkgYnl0ZXMsIHVwIHRvIDI1NiBieXRlc1xuICAgKiBAcGFyYW0gYXNPZiBPcHRpb25hbC4gVGhlIHRpbWVzdGFtcCB0byB2ZXJpZnkgdGhlIHRyYW5zYWN0aW9uIGFnYWluc3QgYXMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfVxuICAgKiBAcGFyYW0gY2hhbmdlVGhyZXNob2xkIE9wdGlvbmFsLiBUaGUgbnVtYmVyIG9mIHNpZ25hdHVyZXMgcmVxdWlyZWQgdG8gc3BlbmQgdGhlIGZ1bmRzIGluIHRoZSByZXN1bHRhbnQgY2hhbmdlIFVUWE9cbiAgICpcbiAgICogQHJldHVybnMgQW4gdW5zaWduZWQgQWRkcmVzc1N0YXRlVHggY3JlYXRlZCBmcm9tIHRoZSBwYXNzZWQgaW4gcGFyYW1ldGVycy5cbiAgICovXG4gIGJ1aWxkQWRkcmVzc1N0YXRlVHggPSBhc3luYyAoXG4gICAgdmVyc2lvbjogbnVtYmVyID0gRGVmYXVsdFRyYW5zYWN0aW9uVmVyc2lvbk51bWJlcixcbiAgICBuZXR3b3JrSUQ6IG51bWJlciA9IERlZmF1bHROZXR3b3JrSUQsXG4gICAgYmxvY2tjaGFpbklEOiBCdWZmZXIsXG4gICAgZnJvbVNpZ25lcjogRnJvbVNpZ25lcixcbiAgICBjaGFuZ2VBZGRyZXNzZXM6IEJ1ZmZlcltdLFxuICAgIGFkZHJlc3M6IEJ1ZmZlcixcbiAgICBzdGF0ZTogbnVtYmVyLFxuICAgIHJlbW92ZTogYm9vbGVhbiA9IGZhbHNlLFxuICAgIGZlZTogQk4gPSB6ZXJvLFxuICAgIGZlZUFzc2V0SUQ6IEJ1ZmZlciA9IHVuZGVmaW5lZCxcbiAgICBtZW1vOiBCdWZmZXIgPSB1bmRlZmluZWQsXG4gICAgYXNPZjogQk4gPSB6ZXJvLFxuICAgIGNoYW5nZVRocmVzaG9sZDogbnVtYmVyID0gMSxcbiAgICBleGVjdXRvckFkZHJlc3M6IEJ1ZmZlciA9IHVuZGVmaW5lZCxcbiAgICBleGVjdXRvckF1dGg6IFtudW1iZXIsIEJ1ZmZlcl1bXSA9IFtdXG4gICk6IFByb21pc2U8VW5zaWduZWRUeD4gPT4ge1xuICAgIGxldCBpbnM6IFRyYW5zZmVyYWJsZUlucHV0W10gPSBbXVxuICAgIGxldCBvdXRzOiBUcmFuc2ZlcmFibGVPdXRwdXRbXSA9IFtdXG4gICAgbGV0IG93bmVyczogT3V0cHV0T3duZXJzW10gPSBbXVxuXG4gICAgaWYgKHRoaXMuX2ZlZUNoZWNrKGZlZSwgZmVlQXNzZXRJRCkpIHtcbiAgICAgIGNvbnN0IGFhZDogQXNzZXRBbW91bnREZXN0aW5hdGlvbiA9IG5ldyBBc3NldEFtb3VudERlc3RpbmF0aW9uKFxuICAgICAgICBbXSxcbiAgICAgICAgMCxcbiAgICAgICAgZnJvbVNpZ25lci5mcm9tLFxuICAgICAgICBmcm9tU2lnbmVyLnNpZ25lcixcbiAgICAgICAgY2hhbmdlQWRkcmVzc2VzLFxuICAgICAgICBjaGFuZ2VUaHJlc2hvbGRcbiAgICAgIClcblxuICAgICAgYWFkLmFkZEFzc2V0QW1vdW50KGZlZUFzc2V0SUQsIHplcm8sIGZlZSlcblxuICAgICAgY29uc3QgbWluU3BlbmRhYmxlRXJyOiBFcnJvciA9IGF3YWl0IHRoaXMuc3BlbmRlci5nZXRNaW5pbXVtU3BlbmRhYmxlKFxuICAgICAgICBhYWQsXG4gICAgICAgIGFzT2YsXG4gICAgICAgIHplcm8sXG4gICAgICAgIFwiVW5sb2NrZWRcIlxuICAgICAgKVxuICAgICAgaWYgKHR5cGVvZiBtaW5TcGVuZGFibGVFcnIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaW5zID0gYWFkLmdldElucHV0cygpXG4gICAgICAgIG91dHMgPSBhYWQuZ2V0QWxsT3V0cHV0cygpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBtaW5TcGVuZGFibGVFcnJcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBiYXNlVHg6IEFkZHJlc3NTdGF0ZVR4ID0gbmV3IEFkZHJlc3NTdGF0ZVR4KFxuICAgICAgdmVyc2lvbixcbiAgICAgIG5ldHdvcmtJRCxcbiAgICAgIGJsb2NrY2hhaW5JRCxcbiAgICAgIG91dHMsXG4gICAgICBpbnMsXG4gICAgICBtZW1vLFxuICAgICAgYWRkcmVzcyxcbiAgICAgIHN0YXRlLFxuICAgICAgcmVtb3ZlLFxuICAgICAgZXhlY3V0b3JBZGRyZXNzXG4gICAgKVxuXG4gICAgaWYgKGV4ZWN1dG9yQWRkcmVzcykge1xuICAgICAgZXhlY3V0b3JBdXRoLmZvckVhY2goKHNpZ25lcik6IHZvaWQgPT4ge1xuICAgICAgICBiYXNlVHguYWRkU2lnbmF0dXJlSWR4KHNpZ25lclswXSwgc2lnbmVyWzFdKVxuICAgICAgfSlcbiAgICAgIG93bmVycy5wdXNoKG5ldyBPdXRwdXRPd25lcnMoW2V4ZWN1dG9yQWRkcmVzc10sIFplcm9CTiwgMSkpXG4gICAgfVxuXG4gICAgYmFzZVR4LnNldE91dHB1dE93bmVycyhvd25lcnMpXG4gICAgcmV0dXJuIG5ldyBVbnNpZ25lZFR4KGJhc2VUeClcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZCBhbiB1bnNpZ25lZCBbW1JlZ2lzdGVyTm9kZVR4XV0uXG4gICAqXG4gICAqIEBwYXJhbSBuZXR3b3JrSUQgTmV0d29ya2lkLCBbW0RlZmF1bHROZXR3b3JrSURdXVxuICAgKiBAcGFyYW0gYmxvY2tjaGFpbklEIEJsb2NrY2hhaW5pZCwgZGVmYXVsdCB1bmRlZmluZWRcbiAgICogQHBhcmFtIGZyb21TaWduZXIgVGhlIGFkZHJlc3NlcyBiZWluZyB1c2VkIHRvIHNlbmQgYW5kIHZlcmlmeSB0aGUgZnVuZHMgZnJvbSB0aGUgVVRYT3Mge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn1cbiAgICogQHBhcmFtIGNoYW5nZUFkZHJlc3NlcyBUaGUgYWRkcmVzc2VzIHRoYXQgY2FuIHNwZW5kIHRoZSBjaGFuZ2UgcmVtYWluaW5nIGZyb20gdGhlIHNwZW50IFVUWE9zLlxuICAgKiBAcGFyYW0gb2xkTm9kZUlEIE9wdGlvbmFsLiBJRCBvZiB0aGUgZXhpc3RpbmcgTm9kZUlEIHRvIHJlcGxhY2Ugb3IgcmVtb3ZlLlxuICAgKiBAcGFyYW0gbmV3Tm9kZUlEIE9wdGlvbmFsLiBJRCBvZiB0aGUgbmV3Tm9kSUQgdG8gcmVnaXN0ZXIgYWRkcmVzcy5cbiAgICogQHBhcmFtIGFkZHJlc3MgVGhlIGNvbnNvcnRpdW1NZW1iZXJBZGRyZXNzLCBzaW5nbGUgb3IgbXVsdGktc2lnLlxuICAgKiBAcGFyYW0gYWRkcmVzc0F1dGhzIEFuIGFycmF5IG9mIGluZGV4IGFuZCBhZGRyZXNzIHRvIHZlcmlmeSBvd25lcnNoaXAgb2YgYWRkcmVzcy5cbiAgICogQHBhcmFtIGZlZSBPcHRpb25hbC4gVGhlIGFtb3VudCBvZiBmZWVzIHRvIGJ1cm4gaW4gaXRzIHNtYWxsZXN0IGRlbm9taW5hdGlvbiwgcmVwcmVzZW50ZWQgYXMge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn1cbiAgICogQHBhcmFtIGZlZUFzc2V0SUQgT3B0aW9uYWwuIFRoZSBhc3NldElEIG9mIHRoZSBmZWVzIGJlaW5nIGJ1cm5lZFxuICAgKiBAcGFyYW0gbWVtbyBPcHRpb25hbCBjb250YWlucyBhcmJpdHJhcnkgYnl0ZXMsIHVwIHRvIDI1NiBieXRlc1xuICAgKiBAcGFyYW0gYXNPZiBPcHRpb25hbC4gVGhlIHRpbWVzdGFtcCB0byB2ZXJpZnkgdGhlIHRyYW5zYWN0aW9uIGFnYWluc3QgYXMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfVxuICAgKiBAcGFyYW0gY2hhbmdlVGhyZXNob2xkIE9wdGlvbmFsLiBUaGUgbnVtYmVyIG9mIHNpZ25hdHVyZXMgcmVxdWlyZWQgdG8gc3BlbmQgdGhlIGZ1bmRzIGluIHRoZSByZXN1bHRhbnQgY2hhbmdlIFVUWE9cbiAgICpcbiAgICogQHJldHVybnMgQW4gdW5zaWduZWQgUmVnaXN0ZXJOb2RlVHggY3JlYXRlZCBmcm9tIHRoZSBwYXNzZWQgaW4gcGFyYW1ldGVycy5cbiAgICovXG4gIGJ1aWxkUmVnaXN0ZXJOb2RlVHggPSBhc3luYyAoXG4gICAgbmV0d29ya0lEOiBudW1iZXIgPSBEZWZhdWx0TmV0d29ya0lELFxuICAgIGJsb2NrY2hhaW5JRDogQnVmZmVyLFxuICAgIGZyb21TaWduZXI6IEZyb21TaWduZXIsXG4gICAgY2hhbmdlQWRkcmVzc2VzOiBCdWZmZXJbXSxcbiAgICBvbGROb2RlSUQ6IEJ1ZmZlciA9IHVuZGVmaW5lZCxcbiAgICBuZXdOb2RlSUQ6IEJ1ZmZlciA9IHVuZGVmaW5lZCxcbiAgICBhZGRyZXNzOiBCdWZmZXIgPSB1bmRlZmluZWQsXG4gICAgYWRkcmVzc0F1dGhzOiBbbnVtYmVyLCBCdWZmZXJdW10gPSBbXSxcbiAgICBmZWU6IEJOID0gemVybyxcbiAgICBmZWVBc3NldElEOiBCdWZmZXIgPSB1bmRlZmluZWQsXG4gICAgbWVtbzogQnVmZmVyID0gdW5kZWZpbmVkLFxuICAgIGFzT2Y6IEJOID0gemVybyxcbiAgICBjaGFuZ2VUaHJlc2hvbGQ6IG51bWJlciA9IDFcbiAgKTogUHJvbWlzZTxVbnNpZ25lZFR4PiA9PiB7XG4gICAgbGV0IGluczogVHJhbnNmZXJhYmxlSW5wdXRbXSA9IFtdXG4gICAgbGV0IG91dHM6IFRyYW5zZmVyYWJsZU91dHB1dFtdID0gW11cbiAgICBsZXQgb3duZXJzOiBPdXRwdXRPd25lcnNbXSA9IFtdXG5cbiAgICBpZiAodGhpcy5fZmVlQ2hlY2soZmVlLCBmZWVBc3NldElEKSkge1xuICAgICAgY29uc3QgYWFkOiBBc3NldEFtb3VudERlc3RpbmF0aW9uID0gbmV3IEFzc2V0QW1vdW50RGVzdGluYXRpb24oXG4gICAgICAgIFtdLFxuICAgICAgICAwLFxuICAgICAgICBmcm9tU2lnbmVyLmZyb20sXG4gICAgICAgIGZyb21TaWduZXIuc2lnbmVyLFxuICAgICAgICBjaGFuZ2VBZGRyZXNzZXMsXG4gICAgICAgIGNoYW5nZVRocmVzaG9sZFxuICAgICAgKVxuXG4gICAgICBhYWQuYWRkQXNzZXRBbW91bnQoZmVlQXNzZXRJRCwgemVybywgZmVlKVxuXG4gICAgICBjb25zdCBtaW5TcGVuZGFibGVFcnI6IEVycm9yID0gYXdhaXQgdGhpcy5zcGVuZGVyLmdldE1pbmltdW1TcGVuZGFibGUoXG4gICAgICAgIGFhZCxcbiAgICAgICAgYXNPZixcbiAgICAgICAgemVybyxcbiAgICAgICAgXCJVbmxvY2tlZFwiXG4gICAgICApXG4gICAgICBpZiAodHlwZW9mIG1pblNwZW5kYWJsZUVyciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpbnMgPSBhYWQuZ2V0SW5wdXRzKClcbiAgICAgICAgb3V0cyA9IGFhZC5nZXRBbGxPdXRwdXRzKClcbiAgICAgICAgb3duZXJzID0gYWFkLmdldE91dHB1dE93bmVycygpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBtaW5TcGVuZGFibGVFcnJcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBiYXNlVHg6IFJlZ2lzdGVyTm9kZVR4ID0gbmV3IFJlZ2lzdGVyTm9kZVR4KFxuICAgICAgbmV0d29ya0lELFxuICAgICAgYmxvY2tjaGFpbklELFxuICAgICAgb3V0cyxcbiAgICAgIGlucyxcbiAgICAgIG1lbW8sXG4gICAgICBvbGROb2RlSUQsXG4gICAgICBuZXdOb2RlSUQsXG4gICAgICBhZGRyZXNzXG4gICAgKVxuXG4gICAgYWRkcmVzc0F1dGhzLmZvckVhY2goKGFkZHJlc3NBdXRoKSA9PiB7XG4gICAgICBiYXNlVHguYWRkU2lnbmF0dXJlSWR4KGFkZHJlc3NBdXRoWzBdLCBhZGRyZXNzQXV0aFsxXSlcbiAgICB9KVxuXG4gICAgb3duZXJzLnB1c2goXG4gICAgICBuZXdOb2RlSUQgJiYgIW9sZE5vZGVJRFxuICAgICAgICA/IG5ldyBPdXRwdXRPd25lcnMoW25ld05vZGVJRF0sIFplcm9CTiwgMSlcbiAgICAgICAgOiBuZXcgT3V0cHV0T3duZXJzKClcbiAgICApXG4gICAgb3duZXJzLnB1c2gobmV3IE91dHB1dE93bmVycyhbYWRkcmVzc10sIFplcm9CTiwgMSkpXG5cbiAgICBiYXNlVHguc2V0T3V0cHV0T3duZXJzKG93bmVycylcbiAgICByZXR1cm4gbmV3IFVuc2lnbmVkVHgoYmFzZVR4KVxuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkIGFuIHVuc2lnbmVkIFtbRGVwb3NpdFR4XV0uXG4gICAqXG4gICAqIEBwYXJhbSB2ZXJzaW9uIE9wdGlvbmFsLiBUcmFuc2FjdGlvbiB2ZXJzaW9uIG51bWJlciwgZGVmYXVsdCAwLlxuICAgKiBAcGFyYW0gbmV0d29ya0lEIE5ldHdvcmtpZCwgW1tEZWZhdWx0TmV0d29ya0lEXV1cbiAgICogQHBhcmFtIGJsb2NrY2hhaW5JRCBCbG9ja2NoYWluaWQsIGRlZmF1bHQgdW5kZWZpbmVkXG4gICAqIEBwYXJhbSBmcm9tU2lnbmVyIFRoZSBhZGRyZXNzZXMgYmVpbmcgdXNlZCB0byBzZW5kIGFuZCB2ZXJpZnkgdGhlIGZ1bmRzIGZyb20gdGhlIFVUWE9zIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9XG4gICAqIEBwYXJhbSBjaGFuZ2VBZGRyZXNzZXMgVGhlIGFkZHJlc3NlcyB0aGF0IGNhbiBzcGVuZCB0aGUgY2hhbmdlIHJlbWFpbmluZyBmcm9tIHRoZSBzcGVudCBVVFhPcy5cbiAgICogQHBhcmFtIGRlcG9zaXRPZmZlcklEIElEIG9mIHRoZSBkZXBvc2l0IG9mZmVyLlxuICAgKiBAcGFyYW0gZGVwb3NpdER1cmF0aW9uIER1cmF0aW9uIG9mIHRoZSBkZXBvc2l0XG4gICAqIEBwYXJhbSByZXdhcmRzT3duZXIgT3B0aW9uYWwgVGhlIG93bmVycyBvZiB0aGUgcmV3YXJkLiBJZiBvbWl0dGVkLCBhbGwgaW5wdXRzIG11c3QgaGF2ZSB0aGUgc2FtZSBvd25lclxuICAgKiBAcGFyYW0gZGVwb3NpdENyZWF0b3JBZGRyZXNzIEFkZHJlc3MgdGhhdCBpcyBhdXRob3JpemVkIHRvIGNyZWF0ZSBkZXBvc2l0IHdpdGggZ2l2ZW4gb2ZmZXIuIENvdWxkIGJlIGVtcHR5LCBpZiBvZmZlciBvd25lciBpcyBlbXB0eS5cbiAgICogQHBhcmFtIGRlcG9zaXRDcmVhdG9yQXV0aCBBdXRoIGZvciBkZXBvc2l0IGNyZWF0b3IgYWRkcmVzc1xuICAgKiBAcGFyYW0gZGVwb3NpdE9mZmVyT3duZXJTaWdzIFNpZ25hdHVyZXMgd2hpY2ggcmVjb3ZlciB0byBkZXBvc2l0T2ZmZXJPd25lciBhZGRyZXNzKGVzKVxuICAgKiBAcGFyYW0gZGVwb3NpdE9mZmVyT3duZXJBdXRoIEF1dGggZm9yIGRlcG9zaXQgb2ZmZXIgb3duZXJcbiAgICogQHBhcmFtIGZlZSBPcHRpb25hbC4gVGhlIGFtb3VudCBvZiBmZWVzIHRvIGJ1cm4gaW4gaXRzIHNtYWxsZXN0IGRlbm9taW5hdGlvbiwgcmVwcmVzZW50ZWQgYXMge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn1cbiAgICogQHBhcmFtIGZlZUFzc2V0SUQgT3B0aW9uYWwuIFRoZSBhc3NldElEIG9mIHRoZSBmZWVzIGJlaW5nIGJ1cm5lZFxuICAgKiBAcGFyYW0gbWVtbyBPcHRpb25hbCBjb250YWlucyBhcmJpdHJhcnkgYnl0ZXMsIHVwIHRvIDI1NiBieXRlc1xuICAgKiBAcGFyYW0gYXNPZiBPcHRpb25hbC4gVGhlIHRpbWVzdGFtcCB0byB2ZXJpZnkgdGhlIHRyYW5zYWN0aW9uIGFnYWluc3QgYXMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfVxuICAgKiBAcGFyYW0gY2hhbmdlVGhyZXNob2xkIE9wdGlvbmFsLiBUaGUgbnVtYmVyIG9mIHNpZ25hdHVyZXMgcmVxdWlyZWQgdG8gc3BlbmQgdGhlIGZ1bmRzIGluIHRoZSByZXN1bHRhbnQgY2hhbmdlIFVUWE9cbiAgICpcbiAgICogQHJldHVybnMgQW4gdW5zaWduZWQgRGVwb3NpdFR4IGNyZWF0ZWQgZnJvbSB0aGUgcGFzc2VkIGluIHBhcmFtZXRlcnMuXG4gICAqL1xuICBidWlsZERlcG9zaXRUeCA9IGFzeW5jIChcbiAgICB2ZXJzaW9uOiBudW1iZXIgPSBEZWZhdWx0VHJhbnNhY3Rpb25WZXJzaW9uTnVtYmVyLFxuICAgIG5ldHdvcmtJRDogbnVtYmVyID0gRGVmYXVsdE5ldHdvcmtJRCxcbiAgICBibG9ja2NoYWluSUQ6IEJ1ZmZlcixcbiAgICBmcm9tU2lnbmVyOiBGcm9tU2lnbmVyLFxuICAgIGNoYW5nZUFkZHJlc3NlczogQnVmZmVyW10sXG4gICAgZGVwb3NpdE9mZmVySUQ6IEJ1ZmZlcixcbiAgICBkZXBvc2l0RHVyYXRpb246IG51bWJlcixcbiAgICByZXdhcmRzT3duZXI6IE91dHB1dE93bmVycyxcbiAgICBkZXBvc2l0Q3JlYXRvckFkZHJlc3M6IEJ1ZmZlciA9IHVuZGVmaW5lZCxcbiAgICBkZXBvc2l0Q3JlYXRvckF1dGg6IFtudW1iZXIsIEJ1ZmZlcl1bXSA9IFtdLFxuICAgIGRlcG9zaXRPZmZlck93bmVyU2lnczogQnVmZmVyW10gPSBbXSxcbiAgICBkZXBvc2l0T2ZmZXJPd25lckF1dGg6IFtudW1iZXIsIEJ1ZmZlcl1bXSA9IFtdLFxuICAgIGZlZTogQk4gPSB6ZXJvLFxuICAgIGZlZUFzc2V0SUQ6IEJ1ZmZlciA9IHVuZGVmaW5lZCxcbiAgICBtZW1vOiBCdWZmZXIgPSB1bmRlZmluZWQsXG4gICAgYXNPZjogQk4gPSB6ZXJvLFxuICAgIGFtb3VudFRvTG9jazogQk4sXG4gICAgY2hhbmdlVGhyZXNob2xkOiBudW1iZXIgPSAxLFxuICAgIHRvOiBCdWZmZXJbXSA9IFtdLFxuICAgIHRvVGhyZXNob2xkOiBudW1iZXIgPSAwXG4gICk6IFByb21pc2U8VW5zaWduZWRUeD4gPT4ge1xuICAgIGxldCBpbnM6IFRyYW5zZmVyYWJsZUlucHV0W10gPSBbXVxuICAgIGxldCBvdXRzOiBUcmFuc2ZlcmFibGVPdXRwdXRbXSA9IFtdXG4gICAgbGV0IG93bmVyczogT3V0cHV0T3duZXJzW10gPSBbXVxuXG4gICAgaWYgKHRoaXMuX2ZlZUNoZWNrKGZlZSwgZmVlQXNzZXRJRCkpIHtcbiAgICAgIGNvbnN0IGFhZDogQXNzZXRBbW91bnREZXN0aW5hdGlvbiA9IG5ldyBBc3NldEFtb3VudERlc3RpbmF0aW9uKFxuICAgICAgICB0byxcbiAgICAgICAgdG9UaHJlc2hvbGQsXG4gICAgICAgIGZyb21TaWduZXIuZnJvbSxcbiAgICAgICAgZnJvbVNpZ25lci5zaWduZXIsXG4gICAgICAgIGNoYW5nZUFkZHJlc3NlcyxcbiAgICAgICAgY2hhbmdlVGhyZXNob2xkXG4gICAgICApXG5cbiAgICAgIGFhZC5hZGRBc3NldEFtb3VudChmZWVBc3NldElELCBhbW91bnRUb0xvY2ssIGZlZSlcblxuICAgICAgY29uc3QgbWluU3BlbmRhYmxlRXJyOiBFcnJvciA9IGF3YWl0IHRoaXMuc3BlbmRlci5nZXRNaW5pbXVtU3BlbmRhYmxlKFxuICAgICAgICBhYWQsXG4gICAgICAgIGFzT2YsXG4gICAgICAgIHplcm8sXG4gICAgICAgIFwiRGVwb3NpdFwiXG4gICAgICApXG4gICAgICBpZiAodHlwZW9mIG1pblNwZW5kYWJsZUVyciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpbnMgPSBhYWQuZ2V0SW5wdXRzKClcbiAgICAgICAgb3V0cyA9IGFhZC5nZXRBbGxPdXRwdXRzKClcbiAgICAgICAgb3duZXJzID0gYWFkLmdldE91dHB1dE93bmVycygpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBtaW5TcGVuZGFibGVFcnJcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzZWNwT3duZXJzID0gbmV3IFNFQ1BPd25lck91dHB1dChcbiAgICAgIHJld2FyZHNPd25lci5nZXRBZGRyZXNzZXMoKSxcbiAgICAgIHJld2FyZHNPd25lcj8uZ2V0TG9ja3RpbWUoKSxcbiAgICAgIHJld2FyZHNPd25lci5nZXRUaHJlc2hvbGQoKVxuICAgIClcblxuICAgIGNvbnN0IGJhc2VUeDogRGVwb3NpdFR4ID0gbmV3IERlcG9zaXRUeChcbiAgICAgIHZlcnNpb24sXG4gICAgICBuZXR3b3JrSUQsXG4gICAgICBibG9ja2NoYWluSUQsXG4gICAgICBvdXRzLFxuICAgICAgaW5zLFxuICAgICAgbWVtbyxcbiAgICAgIGRlcG9zaXRPZmZlcklELFxuICAgICAgZGVwb3NpdER1cmF0aW9uLFxuICAgICAgbmV3IFBhcnNlYWJsZU91dHB1dChzZWNwT3duZXJzKSxcbiAgICAgIGRlcG9zaXRDcmVhdG9yQWRkcmVzc1xuICAgIClcblxuICAgIGlmICh2ZXJzaW9uID4gMCkge1xuICAgICAgYmFzZVR4LmFkZERlcG9zaXRDcmVhdG9yQXV0aChkZXBvc2l0Q3JlYXRvckF1dGgpXG4gICAgICBiYXNlVHguYWRkT3duZXJBdXRoKGRlcG9zaXRPZmZlck93bmVyQXV0aCwgZGVwb3NpdE9mZmVyT3duZXJTaWdzKVxuXG4gICAgICBvd25lcnMucHVzaChuZXcgT3V0cHV0T3duZXJzKFtkZXBvc2l0Q3JlYXRvckFkZHJlc3NdLCBaZXJvQk4sIDEpKVxuXG4gICAgICAvLyBDcmVhdGUgcHNldWRvIGFkZHJlc3NlcyBmb3IgTXVsdGlzaWcsIHRoZXkgaGF2ZSB0byBwYXNzZWRcbiAgICAgIC8vIHRvIE11bHRpc2lnS2V5Y2hhaW4gb24ga2V5Y2hhaW4gaW5pdGlhbGl6YXRpb25cbiAgICAgIGNvbnN0IG51bUFkZHJlc3NlcyA9XG4gICAgICAgIGRlcG9zaXRPZmZlck93bmVyQXV0aC5sZW5ndGggPiAwXG4gICAgICAgICAgPyBkZXBvc2l0T2ZmZXJPd25lckF1dGguYXQoZGVwb3NpdE9mZmVyT3duZXJBdXRoLmxlbmd0aCAtIDEpWzBdXG4gICAgICAgICAgOiAwXG4gICAgICBjb25zdCBhZGRyczogQnVmZmVyW10gPSBbXVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1BZGRyZXNzZXM7ICsraSkge1xuICAgICAgICBhZGRycy5wdXNoKEJ1ZmZlci5hbGxvYygyMCkpXG4gICAgICAgIGFkZHJzLmF0KGFkZHJzLmxlbmd0aCAtIDEpLndyaXRlVUludEJFKGkgKyAxLCAxNiwgNClcbiAgICAgIH1cbiAgICAgIG93bmVycy5wdXNoKG5ldyBPdXRwdXRPd25lcnMoYWRkcnMsIFplcm9CTiwgZGVwb3NpdE9mZmVyT3duZXJBdXRoLmxlbmd0aCkpXG4gICAgfVxuXG4gICAgYmFzZVR4LnNldE91dHB1dE93bmVycyhvd25lcnMpXG4gICAgcmV0dXJuIG5ldyBVbnNpZ25lZFR4KGJhc2VUeClcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZCBhbiB1bnNpZ25lZCBbW1VubG9ja0RlcG9zaXRUeF1dLlxuICAgKlxuICAgKiBAcGFyYW0gbmV0d29ya0lEIE5ldHdvcmtpZCwgW1tEZWZhdWx0TmV0d29ya0lEXV1cbiAgICogQHBhcmFtIGJsb2NrY2hhaW5JRCBCbG9ja2NoYWluaWQsIGRlZmF1bHQgdW5kZWZpbmVkXG4gICAqIEBwYXJhbSBmcm9tU2lnbmVyIEBwYXJhbSBmcm9tU2lnbmVyIFRoZSBhZGRyZXNzZXMgYmVpbmcgdXNlZCB0byBzZW5kIGFuZCB2ZXJpZnkgdGhlIGZ1bmRzIGZyb20gdGhlIFVUWE9zIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9XG4gICAqIEBwYXJhbSBjaGFuZ2VBZGRyZXNzZXMgVGhlIGFkZHJlc3NlcyB0aGF0IGNhbiBzcGVuZCB0aGUgY2hhbmdlIHJlbWFpbmluZyBmcm9tIHRoZSBzcGVudCBVVFhPcy5cbiAgICogQHBhcmFtIGZlZSBPcHRpb25hbC4gVGhlIGFtb3VudCBvZiBmZWVzIHRvIGJ1cm4gaW4gaXRzIHNtYWxsZXN0IGRlbm9taW5hdGlvbiwgcmVwcmVzZW50ZWQgYXMge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn1cbiAgICogQHBhcmFtIGZlZUFzc2V0SUQgT3B0aW9uYWwuIFRoZSBhc3NldElEIG9mIHRoZSBmZWVzIGJlaW5nIGJ1cm5lZFxuICAgKiBAcGFyYW0gbWVtbyBPcHRpb25hbCBjb250YWlucyBhcmJpdHJhcnkgYnl0ZXMsIHVwIHRvIDI1NiBieXRlc1xuICAgKiBAcGFyYW0gYXNPZiBPcHRpb25hbC4gVGhlIHRpbWVzdGFtcCB0byB2ZXJpZnkgdGhlIHRyYW5zYWN0aW9uIGFnYWluc3QgYXMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfVxuICAgKiBAcGFyYW0gY2hhbmdlVGhyZXNob2xkIE9wdGlvbmFsLiBUaGUgbnVtYmVyIG9mIHNpZ25hdHVyZXMgcmVxdWlyZWQgdG8gc3BlbmQgdGhlIGZ1bmRzIGluIHRoZSByZXN1bHRhbnQgY2hhbmdlIFVUWE9cbiAgICpcbiAgICogQHJldHVybnMgQW4gdW5zaWduZWQgVW5sb2NrRGVwb3NpdFR4IGNyZWF0ZWQgZnJvbSB0aGUgcGFzc2VkIGluIHBhcmFtZXRlcnMuXG4gICAqL1xuICBidWlsZFVubG9ja0RlcG9zaXRUeCA9IGFzeW5jIChcbiAgICBuZXR3b3JrSUQ6IG51bWJlciA9IERlZmF1bHROZXR3b3JrSUQsXG4gICAgYmxvY2tjaGFpbklEOiBCdWZmZXIsXG4gICAgZnJvbVNpZ25lcjogRnJvbVNpZ25lcixcbiAgICBjaGFuZ2VBZGRyZXNzZXM6IEJ1ZmZlcltdLFxuICAgIGZlZTogQk4gPSB6ZXJvLFxuICAgIGZlZUFzc2V0SUQ6IEJ1ZmZlciA9IHVuZGVmaW5lZCxcbiAgICBtZW1vOiBCdWZmZXIgPSB1bmRlZmluZWQsXG4gICAgYXNPZjogQk4gPSB6ZXJvLFxuICAgIGNoYW5nZVRocmVzaG9sZDogbnVtYmVyID0gMVxuICApOiBQcm9taXNlPFVuc2lnbmVkVHg+ID0+IHtcbiAgICBsZXQgaW5zOiBUcmFuc2ZlcmFibGVJbnB1dFtdID0gW11cbiAgICBsZXQgb3V0czogVHJhbnNmZXJhYmxlT3V0cHV0W10gPSBbXVxuXG4gICAgaWYgKHRoaXMuX2ZlZUNoZWNrKGZlZSwgZmVlQXNzZXRJRCkpIHtcbiAgICAgIGNvbnN0IGFhZDogQXNzZXRBbW91bnREZXN0aW5hdGlvbiA9IG5ldyBBc3NldEFtb3VudERlc3RpbmF0aW9uKFxuICAgICAgICBbXSxcbiAgICAgICAgMCxcbiAgICAgICAgZnJvbVNpZ25lci5mcm9tLFxuICAgICAgICBmcm9tU2lnbmVyLnNpZ25lcixcbiAgICAgICAgY2hhbmdlQWRkcmVzc2VzLFxuICAgICAgICBjaGFuZ2VUaHJlc2hvbGRcbiAgICAgIClcblxuICAgICAgYWFkLmFkZEFzc2V0QW1vdW50KGZlZUFzc2V0SUQsIHplcm8sIGZlZSlcblxuICAgICAgY29uc3QgbWluU3BlbmRhYmxlRXJyOiBFcnJvciA9IGF3YWl0IHRoaXMuc3BlbmRlci5nZXRNaW5pbXVtU3BlbmRhYmxlKFxuICAgICAgICBhYWQsXG4gICAgICAgIGFzT2YsXG4gICAgICAgIHplcm8sXG4gICAgICAgIFwiVW5sb2NrZWRcIlxuICAgICAgKVxuICAgICAgaWYgKHR5cGVvZiBtaW5TcGVuZGFibGVFcnIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaW5zID0gYWFkLmdldElucHV0cygpXG4gICAgICAgIG91dHMgPSBhYWQuZ2V0QWxsT3V0cHV0cygpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBtaW5TcGVuZGFibGVFcnJcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB1bmxvY2tEZXBvc2l0VHg6IFVubG9ja0RlcG9zaXRUeCA9IG5ldyBVbmxvY2tEZXBvc2l0VHgoXG4gICAgICBuZXR3b3JrSUQsXG4gICAgICBibG9ja2NoYWluSUQsXG4gICAgICBvdXRzLFxuICAgICAgaW5zLFxuICAgICAgbWVtb1xuICAgIClcblxuICAgIHJldHVybiBuZXcgVW5zaWduZWRUeCh1bmxvY2tEZXBvc2l0VHgpXG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgYW4gdW5zaWduZWQgW1tDbGFpbVR4XV0uXG4gICAqXG4gICAqIEBwYXJhbSBuZXR3b3JrSUQgTmV0d29ya0lELCBbW0RlZmF1bHROZXR3b3JrSURdXVxuICAgKiBAcGFyYW0gYmxvY2tjaGFpbklEIEJsb2NrY2hhaW5JRCwgZGVmYXVsdCB1bmRlZmluZWRcbiAgICogQHBhcmFtIGZyb21TaWduZXIgQHBhcmFtIGZyb21TaWduZXIgVGhlIGFkZHJlc3NlcyBiZWluZyB1c2VkIHRvIHNlbmQgYW5kIHZlcmlmeSB0aGUgZnVuZHMgZnJvbSB0aGUgVVRYT3Mge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn1cbiAgICogQHBhcmFtIGNoYW5nZUFkZHJlc3NlcyBUaGUgYWRkcmVzc2VzIHRoYXQgY2FuIHNwZW5kIHRoZSBjaGFuZ2UgcmVtYWluaW5nIGZyb20gdGhlIHNwZW50IFVUWE9zLlxuICAgKiBAcGFyYW0gZmVlIE9wdGlvbmFsLiBUaGUgYW1vdW50IG9mIGZlZXMgdG8gYnVybiBpbiBpdHMgc21hbGxlc3QgZGVub21pbmF0aW9uLCByZXByZXNlbnRlZCBhcyB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfVxuICAgKiBAcGFyYW0gZmVlQXNzZXRJRCBPcHRpb25hbC4gVGhlIGFzc2V0SUQgb2YgdGhlIGZlZXMgYmVpbmcgYnVybmVkXG4gICAqIEBwYXJhbSBtZW1vIE9wdGlvbmFsIGNvbnRhaW5zIGFyYml0cmFyeSBieXRlcywgdXAgdG8gMjU2IGJ5dGVzXG4gICAqIEBwYXJhbSBhc09mIE9wdGlvbmFsLiBUaGUgdGltZXN0YW1wIHRvIHZlcmlmeSB0aGUgdHJhbnNhY3Rpb24gYWdhaW5zdCBhcyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcy98Qk59XG4gICAqIEBwYXJhbSBjaGFuZ2VUaHJlc2hvbGQgT3B0aW9uYWwuIFRoZSBudW1iZXIgb2Ygc2lnbmF0dXJlcyByZXF1aXJlZCB0byBzcGVuZCB0aGUgZnVuZHMgaW4gdGhlIHJlc3VsdGFudCBjaGFuZ2UgVVRYT1xuICAgKiBAcGFyYW0gY2xhaW1BbW91bnRzIFRoZSBzcGVjaWZpY2F0aW9uIGFuZCBhdXRoZW50aWNhdGlvbiB3aGF0IGFuZCBob3cgbXVjaCB0byBjbGFpbVxuICAgKiBAcGFyYW0gY2xhaW1UbyBUaGUgYWRkcmVzcyB0byBjbGFpbWVkIHJld2FyZHMgd2lsbCBiZSBkaXJlY3RlZCB0b1xuICAgKlxuICAgKiBAcmV0dXJucyBBbiB1bnNpZ25lZCBDbGFpbVR4IGNyZWF0ZWQgZnJvbSB0aGUgcGFzc2VkIGluIHBhcmFtZXRlcnMuXG4gICAqL1xuICBidWlsZENsYWltVHggPSBhc3luYyAoXG4gICAgbmV0d29ya0lEOiBudW1iZXIgPSBEZWZhdWx0TmV0d29ya0lELFxuICAgIGJsb2NrY2hhaW5JRDogQnVmZmVyLFxuICAgIGZyb21TaWduZXI6IEZyb21TaWduZXIsXG4gICAgY2hhbmdlQWRkcmVzc2VzOiBCdWZmZXJbXSxcbiAgICBmZWU6IEJOID0gemVybyxcbiAgICBmZWVBc3NldElEOiBCdWZmZXIgPSB1bmRlZmluZWQsXG4gICAgbWVtbzogQnVmZmVyID0gdW5kZWZpbmVkLFxuICAgIGFzT2Y6IEJOID0gemVybyxcbiAgICBjaGFuZ2VUaHJlc2hvbGQ6IG51bWJlciA9IDEsXG4gICAgY2xhaW1BbW91bnRzOiBDbGFpbUFtb3VudFBhcmFtc1tdLFxuICAgIGNsYWltVG86IE91dHB1dE93bmVycyA9IHVuZGVmaW5lZFxuICApOiBQcm9taXNlPFVuc2lnbmVkVHg+ID0+IHtcbiAgICBsZXQgaW5zOiBUcmFuc2ZlcmFibGVJbnB1dFtdID0gW11cbiAgICBsZXQgb3V0czogVHJhbnNmZXJhYmxlT3V0cHV0W10gPSBbXVxuICAgIGxldCBvd25lcnM6IE91dHB1dE93bmVyc1tdID0gW11cblxuICAgIGlmICh0aGlzLl9mZWVDaGVjayhmZWUsIGZlZUFzc2V0SUQpKSB7XG4gICAgICBjb25zdCBhYWQ6IEFzc2V0QW1vdW50RGVzdGluYXRpb24gPSBuZXcgQXNzZXRBbW91bnREZXN0aW5hdGlvbihcbiAgICAgICAgW10sXG4gICAgICAgIDAsXG4gICAgICAgIGZyb21TaWduZXIuZnJvbSxcbiAgICAgICAgZnJvbVNpZ25lci5zaWduZXIsXG4gICAgICAgIGNoYW5nZUFkZHJlc3NlcyxcbiAgICAgICAgY2hhbmdlVGhyZXNob2xkXG4gICAgICApXG5cbiAgICAgIGFhZC5hZGRBc3NldEFtb3VudChmZWVBc3NldElELCB6ZXJvLCBmZWUpXG5cbiAgICAgIGNvbnN0IG1pblNwZW5kYWJsZUVycjogRXJyb3IgPSBhd2FpdCB0aGlzLnNwZW5kZXIuZ2V0TWluaW11bVNwZW5kYWJsZShcbiAgICAgICAgYWFkLFxuICAgICAgICBhc09mLFxuICAgICAgICB6ZXJvLFxuICAgICAgICBcIlVubG9ja2VkXCJcbiAgICAgIClcbiAgICAgIGlmICh0eXBlb2YgbWluU3BlbmRhYmxlRXJyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlucyA9IGFhZC5nZXRJbnB1dHMoKVxuICAgICAgICBvdXRzID0gYWFkLmdldEFsbE91dHB1dHMoKVxuICAgICAgICBvd25lcnMgPSBhYWQuZ2V0T3V0cHV0T3duZXJzKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG1pblNwZW5kYWJsZUVyclxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IENvbXBhY3QgaWYgcG9zc2libGVcbiAgICBjb25zdCB0eENsYWltQW1vdW50czogQ2xhaW1BbW91bnRbXSA9IFtdXG4gICAgY29uc3QgYWxsU2lnSWR4czogU2lnSWR4W11bXSA9IFtdXG4gICAgZm9yIChjb25zdCBhbXQgb2YgY2xhaW1BbW91bnRzKSB7XG4gICAgICBjb25zdCByZWNlaXZlciA9IGNsYWltVG8gPyBjbGFpbVRvIDogYW10Lm93bmVyc1xuICAgICAgb3V0cy5wdXNoKFxuICAgICAgICBuZXcgVHJhbnNmZXJhYmxlT3V0cHV0KFxuICAgICAgICAgIGZlZUFzc2V0SUQsXG4gICAgICAgICAgbmV3IFNFQ1BUcmFuc2Zlck91dHB1dChcbiAgICAgICAgICAgIGFtdC5hbW91bnQsXG4gICAgICAgICAgICByZWNlaXZlci5nZXRBZGRyZXNzZXMoKSxcbiAgICAgICAgICAgIHJlY2VpdmVyLmdldExvY2t0aW1lKCksXG4gICAgICAgICAgICByZWNlaXZlci5nZXRUaHJlc2hvbGQoKVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKVxuICAgICAgbGV0IGlkID0gYW10LmlkXG4gICAgICBpZiAoIWlkKSB7XG4gICAgICAgIGlmIChhbXQuY2xhaW1UeXBlID09PSBDbGFpbVR5cGUuQUNUSVZFX0RFUE9TSVRfUkVXQVJEKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNsYWltQW1vdW50IGlkIG11c3QgYmUgc2V0XCIpXG4gICAgICAgIGNvbnN0IGIgPSBCdWZmZXIuYWxsb2MoMiwgUGxhdGZvcm1WTUNvbnN0YW50cy5MQVRFU1RDT0RFQylcbiAgICAgICAgaWQgPSBCdWZmZXIuZnJvbShcbiAgICAgICAgICBjcmVhdGVIYXNoKFwic2hhMjU2XCIpXG4gICAgICAgICAgICAudXBkYXRlKEJ1ZmZlci5jb25jYXQoW2IsIGFtdC5vd25lcnMudG9CdWZmZXIoKV0pKVxuICAgICAgICAgICAgLmRpZ2VzdCgpXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIFNpZ0lkeHNcbiAgICAgIGlmIChhbXQuc2lnSWR4cy5sZW5ndGggIT09IGFtdC5vd25lcnMuZ2V0VGhyZXNob2xkKCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNpZ0lkeCBjb3VudCBtaXNtYXRjaFwiKVxuICAgICAgY29uc3Qgc2lnSWR4czogU2lnSWR4W10gPSBbXVxuICAgICAgY29uc3QgYWRkcnMgPSBhbXQub3duZXJzLmdldEFkZHJlc3NlcygpXG4gICAgICBmb3IgKGNvbnN0IGlkeCBvZiBhbXQuc2lnSWR4cykge1xuICAgICAgICBpZiAoaWR4ID49IGFkZHJzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKFwiU2lnSWR4IG91dCBvZiBib3VuZFwiKVxuICAgICAgICBzaWdJZHhzLnB1c2gobmV3IFNpZ0lkeChpZHgsIGFkZHJzW2lkeF0pKVxuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYXV0aCBmb3IgdmVyaWZpY2F0aW9uIG9mIGNsYWltQW1vdW50IG93bmVyXG4gICAgICBjb25zdCBidWZmZXJTaWdJZHhzID0gc2lnSWR4cy5tYXAoKHMpID0+IHMuZ2V0Qnl0ZXMoKSlcblxuICAgICAgdHhDbGFpbUFtb3VudHMucHVzaChcbiAgICAgICAgbmV3IENsYWltQW1vdW50KGlkLCBhbXQuY2xhaW1UeXBlLCBhbXQuYW1vdW50LCBidWZmZXJTaWdJZHhzKVxuICAgICAgKVxuICAgICAgYWxsU2lnSWR4cy5wdXNoKHNpZ0lkeHMpXG4gICAgICBvd25lcnMucHVzaChhbXQub3duZXJzKVxuICAgIH1cblxuICAgIGNvbnN0IGNsYWltVHg6IENsYWltVHggPSBuZXcgQ2xhaW1UeChcbiAgICAgIG5ldHdvcmtJRCxcbiAgICAgIGJsb2NrY2hhaW5JRCxcbiAgICAgIG91dHMsXG4gICAgICBpbnMsXG4gICAgICBtZW1vLFxuICAgICAgdHhDbGFpbUFtb3VudHNcbiAgICApXG5cbiAgICAvLyBCdWlsZCBzaWduYXR1cmVJbmRpY2VzXG4gICAgZm9yIChjb25zdCBzIG9mIGFsbFNpZ0lkeHMpIGNsYWltVHguYWRkU2lnSWR4cyhzKVxuXG4gICAgY2xhaW1UeC5zZXRPdXRwdXRPd25lcnMob3duZXJzKVxuICAgIHJldHVybiBuZXcgVW5zaWduZWRUeChjbGFpbVR4KVxuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkIGFuIHVuc2lnbmVkIFtbTXVsdGlzaWdBbGlhc1R4XV0uXG4gICAqXG4gICAqIEBwYXJhbSBuZXR3b3JrSUQgTmV0d29yayBJRCwgZGVmYXVsdCBbW0RlZmF1bHROZXR3b3JrSURdXVxuICAgKiBAcGFyYW0gYmxvY2tjaGFpbklEIEJsb2NrY2hhaW4gSUQsIGRlZmF1bHQgdW5kZWZpbmVkXG4gICAqIEBwYXJhbSBmcm9tU2lnbmVyIFRoZSBhZGRyZXNzZXMgYmVpbmcgdXNlZCB0byBzZW5kIGFuZCB2ZXJpZnkgdGhlIGZ1bmRzIGZyb20gdGhlIFVUWE9zXG4gICAqIEBwYXJhbSBjaGFuZ2VBZGRyZXNzZXMgVGhlIGFkZHJlc3NlcyB0aGF0IGNhbiBzcGVuZCB0aGUgY2hhbmdlIHJlbWFpbmluZyBmcm9tIHRoZSBzcGVudCBVVFhPc1xuICAgKiBAcGFyYW0gbXVsdGlzaWdBbGlhc1BhcmFtcyBQYXJhbWV0ZXJzIG9mIE11bHRpc2lnQWxpYXNUeC4gbXVsdGlzaWdBbGlhc1BhcmFtcy5JRCBtdXN0IGJlIGVtcHR5IGlmIGl0J3MgdGhlIG5ldyBhbGlhc1xuICAgKiBAcGFyYW0gZmVlIE9wdGlvbmFsIGFtb3VudCBvZiBmZWVzIHRvIGJ1cm4gaW4gaXRzIHNtYWxsZXN0IGRlbm9taW5hdGlvbiwgcmVwcmVzZW50ZWQgYXMgQk5cbiAgICogQHBhcmFtIGZlZUFzc2V0SUQgT3B0aW9uYWwgYXNzZXQgSUQgb2YgdGhlIGZlZXMgYmVpbmcgYnVybmVkXG4gICAqIEBwYXJhbSBtZW1vIE9wdGlvbmFsIGNvbnRhaW5zIGFyYml0cmFyeSBieXRlcywgdXAgdG8gMjU2IGJ5dGVzXG4gICAqIEBwYXJhbSBhc09mIE9wdGlvbmFsIHRpbWVzdGFtcCB0byB2ZXJpZnkgdGhlIHRyYW5zYWN0aW9uIGFnYWluc3QsIGFzIEJOXG4gICAqIEBwYXJhbSBjaGFuZ2VUaHJlc2hvbGQgT3B0aW9uYWwgbnVtYmVyIG9mIHNpZ25hdHVyZXMgcmVxdWlyZWQgdG8gc3BlbmQgdGhlIGZ1bmRzIGluIHRoZSByZXN1bHRhbnQgY2hhbmdlIFVUWE9cbiAgICpcbiAgICogQHJldHVybnMgQW4gdW5zaWduZWQgTXVsdGlzaWdBbGlhc1R4IGNyZWF0ZWQgZnJvbSB0aGUgcGFzc2VkLWluIHBhcmFtZXRlcnMuXG4gICAqL1xuICBidWlsZE11bHRpc2lnQWxpYXNUeCA9IGFzeW5jIChcbiAgICBuZXR3b3JrSUQ6IG51bWJlciA9IERlZmF1bHROZXR3b3JrSUQsXG4gICAgYmxvY2tjaGFpbklEOiBCdWZmZXIsXG4gICAgZnJvbVNpZ25lcjogRnJvbVNpZ25lcixcbiAgICBjaGFuZ2VBZGRyZXNzZXM6IEJ1ZmZlcltdLFxuICAgIG11bHRpc2lnQWxpYXNQYXJhbXM6IE11bHRpc2lnQWxpYXNQYXJhbXMsXG4gICAgZmVlOiBCTiA9IHplcm8sXG4gICAgZmVlQXNzZXRJRDogQnVmZmVyID0gdW5kZWZpbmVkLFxuICAgIG1lbW86IEJ1ZmZlciA9IHVuZGVmaW5lZCxcbiAgICBhc09mOiBCTiA9IHplcm8sXG4gICAgY2hhbmdlVGhyZXNob2xkOiBudW1iZXIgPSAxXG4gICk6IFByb21pc2U8VW5zaWduZWRUeD4gPT4ge1xuICAgIGxldCBpbnM6IFRyYW5zZmVyYWJsZUlucHV0W10gPSBbXVxuICAgIGxldCBvdXRzOiBUcmFuc2ZlcmFibGVPdXRwdXRbXSA9IFtdXG4gICAgbGV0IG93bmVyczogT3V0cHV0T3duZXJzW10gPSBbXVxuXG4gICAgaWYgKHRoaXMuX2ZlZUNoZWNrKGZlZSwgZmVlQXNzZXRJRCkpIHtcbiAgICAgIGNvbnN0IGFhZDogQXNzZXRBbW91bnREZXN0aW5hdGlvbiA9IG5ldyBBc3NldEFtb3VudERlc3RpbmF0aW9uKFxuICAgICAgICBbXSxcbiAgICAgICAgMCxcbiAgICAgICAgZnJvbVNpZ25lci5mcm9tLFxuICAgICAgICBmcm9tU2lnbmVyLnNpZ25lcixcbiAgICAgICAgY2hhbmdlQWRkcmVzc2VzLFxuICAgICAgICBjaGFuZ2VUaHJlc2hvbGRcbiAgICAgIClcblxuICAgICAgYWFkLmFkZEFzc2V0QW1vdW50KGZlZUFzc2V0SUQsIHplcm8sIGZlZSlcblxuICAgICAgY29uc3QgbWluU3BlbmRhYmxlRXJyOiBFcnJvciA9IGF3YWl0IHRoaXMuc3BlbmRlci5nZXRNaW5pbXVtU3BlbmRhYmxlKFxuICAgICAgICBhYWQsXG4gICAgICAgIGFzT2YsXG4gICAgICAgIHplcm8sXG4gICAgICAgIFwiVW5sb2NrZWRcIlxuICAgICAgKVxuICAgICAgaWYgKHR5cGVvZiBtaW5TcGVuZGFibGVFcnIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaW5zID0gYWFkLmdldElucHV0cygpXG4gICAgICAgIG91dHMgPSBhYWQuZ2V0QWxsT3V0cHV0cygpXG4gICAgICAgIG93bmVycyA9IGFhZC5nZXRPdXRwdXRPd25lcnMoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbWluU3BlbmRhYmxlRXJyXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgb3V0cHV0OiBTRUNQT3duZXJPdXRwdXQgPSBuZXcgU0VDUE93bmVyT3V0cHV0KFxuICAgICAgbXVsdGlzaWdBbGlhc1BhcmFtcy5vd25lcnMuZ2V0QWRkcmVzc2VzKCksXG4gICAgICBtdWx0aXNpZ0FsaWFzUGFyYW1zLm93bmVycy5nZXRMb2NrdGltZSgpLFxuICAgICAgbXVsdGlzaWdBbGlhc1BhcmFtcy5vd25lcnMuZ2V0VGhyZXNob2xkKClcbiAgICApXG5cbiAgICBjb25zdCBtdWx0aXNpZ0FsaWFzOiBNdWx0aXNpZ0FsaWFzID0gbmV3IE11bHRpc2lnQWxpYXMoXG4gICAgICBtdWx0aXNpZ0FsaWFzUGFyYW1zLmlkLFxuICAgICAgQnVmZmVyLmZyb20obXVsdGlzaWdBbGlhc1BhcmFtcy5tZW1vLCBcInV0Zi04XCIpLFxuICAgICAgbmV3IFBhcnNlYWJsZU91dHB1dChvdXRwdXQpXG4gICAgKVxuXG4gICAgY29uc3QgYmFzZVR4OiBNdWx0aXNpZ0FsaWFzVHggPSBuZXcgTXVsdGlzaWdBbGlhc1R4KFxuICAgICAgbmV0d29ya0lELFxuICAgICAgYmxvY2tjaGFpbklELFxuICAgICAgb3V0cyxcbiAgICAgIGlucyxcbiAgICAgIG1lbW8sXG4gICAgICBtdWx0aXNpZ0FsaWFzXG4gICAgKVxuXG4gICAgbXVsdGlzaWdBbGlhc1BhcmFtcy5hdXRoLmZvckVhY2goKGFkZHJlc3NBdXRoKSA9PiB7XG4gICAgICBiYXNlVHguYWRkU2lnbmF0dXJlSWR4KGFkZHJlc3NBdXRoWzBdLCBhZGRyZXNzQXV0aFsxXSlcbiAgICB9KVxuXG4gICAgaWYgKG11bHRpc2lnQWxpYXNQYXJhbXMuaWQgJiYgbXVsdGlzaWdBbGlhc1BhcmFtcy5pZC5sZW5ndGggIT0gMCkge1xuICAgICAgb3duZXJzLnB1c2gobmV3IE91dHB1dE93bmVycyhbbXVsdGlzaWdBbGlhc1BhcmFtcy5pZF0sIFplcm9CTiwgMSkpXG4gICAgfVxuXG4gICAgYmFzZVR4LnNldE91dHB1dE93bmVycyhvd25lcnMpXG4gICAgcmV0dXJuIG5ldyBVbnNpZ25lZFR4KGJhc2VUeClcbiAgfVxuXG4gIF9mZWVDaGVjayhmZWU6IEJOLCBmZWVBc3NldElEOiBCdWZmZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKFxuICAgICAgdHlwZW9mIGZlZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgdHlwZW9mIGZlZUFzc2V0SUQgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgIGZlZS5ndChuZXcgQk4oMCkpICYmXG4gICAgICBmZWVBc3NldElEIGluc3RhbmNlb2YgQnVmZmVyXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkIGFuIHVuc2lnbmVkIFtbQWRkRGVwb3NpdE9mZmVyVHhdXS5cbiAgICpcbiAgICogQHBhcmFtIG5ldHdvcmtJRFxuICAgKiBAcGFyYW0gYmxvY2tjaGFpbklEXG4gICAqIEBwYXJhbSBmcm9tU2lnbmVyXG4gICAqIEBwYXJhbSBjaGFuZ2VBZGRyZXNzZXNcbiAgICogQHBhcmFtIGRlcG9zaXRPZmZlclxuICAgKiBAcGFyYW0gZGVwb3NpdE9mZmVyQ3JlYXRvckFkZHJlc3NcbiAgICogQHBhcmFtIGRlcG9zaXRPZmZlckNyZWF0b3JBdXRoXG4gICAqIEBwYXJhbSBmZWVcbiAgICogQHBhcmFtIGZlZUFzc2V0SURcbiAgICogQHBhcmFtIG1lbW9cbiAgICogQHBhcmFtIGFzT2ZcbiAgICogQHBhcmFtIGNoYW5nZVRocmVzaG9sZFxuICAgKi9cbiAgYnVpbGRBZGREZXBvc2l0T2ZmZXJUeCA9IGFzeW5jIChcbiAgICBuZXR3b3JrSUQ6IG51bWJlciA9IERlZmF1bHROZXR3b3JrSUQsXG4gICAgYmxvY2tjaGFpbklEOiBCdWZmZXIsXG4gICAgZnJvbVNpZ25lcjogRnJvbVNpZ25lcixcbiAgICBjaGFuZ2VBZGRyZXNzZXM6IEJ1ZmZlcltdLFxuICAgIG9mZmVyOiBPZmZlcixcbiAgICBkZXBvc2l0T2ZmZXJDcmVhdG9yQWRkcmVzczogQnVmZmVyLFxuICAgIGRlcG9zaXRPZmZlckNyZWF0b3JBdXRoOiBbbnVtYmVyLCBCdWZmZXJdW10gPSBbXSxcbiAgICBmZWU6IEJOID0gemVybyxcbiAgICBmZWVBc3NldElEOiBCdWZmZXIgPSB1bmRlZmluZWQsXG4gICAgbWVtbzogQnVmZmVyID0gdW5kZWZpbmVkLFxuICAgIGFzT2Y6IEJOID0gemVybyxcbiAgICBjaGFuZ2VUaHJlc2hvbGQ6IG51bWJlciA9IDFcbiAgKTogUHJvbWlzZTxVbnNpZ25lZFR4PiA9PiB7XG4gICAgbGV0IGluczogVHJhbnNmZXJhYmxlSW5wdXRbXSA9IFtdXG4gICAgbGV0IG91dHM6IFRyYW5zZmVyYWJsZU91dHB1dFtdID0gW11cbiAgICBsZXQgb3duZXJzOiBPdXRwdXRPd25lcnNbXSA9IFtdXG5cbiAgICBpZiAodGhpcy5fZmVlQ2hlY2soZmVlLCBmZWVBc3NldElEKSkge1xuICAgICAgY29uc3QgYWFkOiBBc3NldEFtb3VudERlc3RpbmF0aW9uID0gbmV3IEFzc2V0QW1vdW50RGVzdGluYXRpb24oXG4gICAgICAgIFtdLFxuICAgICAgICAwLFxuICAgICAgICBmcm9tU2lnbmVyLmZyb20sXG4gICAgICAgIGZyb21TaWduZXIuc2lnbmVyLFxuICAgICAgICBjaGFuZ2VBZGRyZXNzZXMsXG4gICAgICAgIGNoYW5nZVRocmVzaG9sZFxuICAgICAgKVxuXG4gICAgICBhYWQuYWRkQXNzZXRBbW91bnQoZmVlQXNzZXRJRCwgemVybywgZmVlKVxuXG4gICAgICBjb25zdCBtaW5TcGVuZGFibGVFcnI6IEVycm9yID0gYXdhaXQgdGhpcy5zcGVuZGVyLmdldE1pbmltdW1TcGVuZGFibGUoXG4gICAgICAgIGFhZCxcbiAgICAgICAgYXNPZixcbiAgICAgICAgemVybyxcbiAgICAgICAgXCJVbmxvY2tlZFwiXG4gICAgICApXG4gICAgICBpZiAodHlwZW9mIG1pblNwZW5kYWJsZUVyciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpbnMgPSBhYWQuZ2V0SW5wdXRzKClcbiAgICAgICAgb3V0cyA9IGFhZC5nZXRBbGxPdXRwdXRzKClcbiAgICAgICAgb3duZXJzID0gYWFkLmdldE91dHB1dE93bmVycygpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBtaW5TcGVuZGFibGVFcnJcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBiYXNlVHg6IEFkZERlcG9zaXRPZmZlclR4ID0gbmV3IEFkZERlcG9zaXRPZmZlclR4KFxuICAgICAgbmV0d29ya0lELFxuICAgICAgYmxvY2tjaGFpbklELFxuICAgICAgb3V0cyxcbiAgICAgIGlucyxcbiAgICAgIG1lbW8sXG4gICAgICBvZmZlcixcbiAgICAgIGRlcG9zaXRPZmZlckNyZWF0b3JBZGRyZXNzXG4gICAgKVxuXG4gICAgZGVwb3NpdE9mZmVyQ3JlYXRvckF1dGguZm9yRWFjaCgoc2lnbmVyKTogdm9pZCA9PiB7XG4gICAgICBiYXNlVHguYWRkU2lnbmF0dXJlSWR4KHNpZ25lclswXSwgc2lnbmVyWzFdKVxuICAgIH0pXG5cbiAgICBvd25lcnMucHVzaChuZXcgT3V0cHV0T3duZXJzKFtkZXBvc2l0T2ZmZXJDcmVhdG9yQWRkcmVzc10sIFplcm9CTiwgMSkpXG5cbiAgICBiYXNlVHguc2V0T3V0cHV0T3duZXJzKG93bmVycylcbiAgICByZXR1cm4gbmV3IFVuc2lnbmVkVHgoYmFzZVR4KVxuICB9XG59XG4iXX0=