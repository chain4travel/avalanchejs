"use strict";
/**
 * @packageDocumentation
 * @module API-PlatformVM-Builder
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Builder = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const buffer_1 = require("buffer/");
const create_hash_1 = __importDefault(require("create-hash"));
const _1 = require(".");
const adddepositoffertx_1 = require("../../apis/platformvm/adddepositoffertx");
const common_1 = require("../../common");
const utils_1 = require("../../utils");
const errors_1 = require("../../utils/errors");
const addproposaltx_1 = require("./addproposaltx");
const addvotetx_1 = require("./addvotetx");
const zero = new bn_js_1.default(0);
class Builder {
    constructor(spender, caminoEnabled) {
        /**
         * Creates an [[UnsignedTx]] wrapping a [[BaseTx]]. For more granular control, you may create your own
         * [[UnsignedTx]] wrapping a [[BaseTx]] manually (with their corresponding [[TransferableInput]]s and [[TransferableOutput]]s).
         *
         * @param networkID The number representing NetworkID of the node
         * @param blockchainID The {@link https://github.com/feross/buffer|Buffer} representing the BlockchainID for the transaction
         * @param amount The amount of the asset to be spent in its smallest denomination, represented as {@link https://github.com/indutny/bn.js/|BN}.
         * @param assetID {@link https://github.com/feross/buffer|Buffer} of the asset ID for the UTXO
         * @param toAddresses The addresses to send the funds
         * @param fromSigner The addresses being used to send and verify the funds from the UTXOs {@link https://github.com/feross/buffer|Buffer}
         * @param changeAddresses Optional. The addresses that can spend the change remaining from the spent UTXOs. Default: toAddresses
         * @param fee Optional. The amount of fees to burn in its smallest denomination, represented as {@link https://github.com/indutny/bn.js/|BN}
         * @param feeAssetID Optional. The assetID of the fees being burned. Default: assetID
         * @param memo Optional. Contains arbitrary data, up to 256 bytes
         * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
         * @param locktime Optional. The locktime field created in the resulting outputs
         * @param toThreshold Optional. The number of signatures required to spend the funds in the resultant UTXO
         * @param changeThreshold Optional. The number of signatures required to spend the funds in the resultant change UTXO
         *
         * @returns An unsigned transaction created from the passed in parameters.
         *
         */
        this.buildBaseTx = (networkID, blockchainID, amount, amountAssetID, toAddresses, fromSigner, changeAddresses = undefined, fee = zero, feeAssetID = undefined, memo = undefined, asOf = zero, lockTime = zero, toThreshold = 1, changeThreshold = 1) => __awaiter(this, void 0, void 0, function* () {
            if (toThreshold > toAddresses.length) {
                /* istanbul ignore next */
                throw new errors_1.ThresholdError("Error - UTXOSet.buildBaseTx: threshold is greater than number of addresses");
            }
            if (typeof changeAddresses === "undefined") {
                changeAddresses = [];
            }
            if (typeof feeAssetID === "undefined") {
                feeAssetID = amountAssetID;
            }
            if (amount.eq(zero)) {
                return undefined;
            }
            const aad = new _1.AssetAmountDestination(toAddresses, toThreshold, fromSigner.from, fromSigner.signer, changeAddresses, changeThreshold);
            if (amountAssetID.toString("hex") === feeAssetID.toString("hex")) {
                aad.addAssetAmount(amountAssetID, amount, fee);
            }
            else {
                aad.addAssetAmount(amountAssetID, amount, zero);
                if (this._feeCheck(fee, feeAssetID)) {
                    aad.addAssetAmount(feeAssetID, zero, fee);
                }
            }
            let ins = [];
            let outs = [];
            let owners = [];
            const minSpendableErr = yield this.spender.getMinimumSpendable(aad, asOf, lockTime, "Unlocked");
            if (typeof minSpendableErr === "undefined") {
                ins = aad.getInputs();
                outs = aad.getAllOutputs();
                owners = aad.getOutputOwners();
            }
            else {
                throw minSpendableErr;
            }
            const baseTx = new _1.BaseTx(networkID, blockchainID, outs, ins, memo);
            baseTx.setOutputOwners(owners);
            return new _1.UnsignedTx(baseTx);
        });
        /**
         * Creates an unsigned ImportTx transaction.
         *
         * @param networkID The number representing NetworkID of the node
         * @param blockchainID The {@link https://github.com/feross/buffer|Buffer} representing the BlockchainID for the transaction
         * @param toAddresses The addresses to send the funds
         * @param fromSigner The addresses being used to send and verify the funds from the UTXOs {@link https://github.com/feross/buffer|Buffer}
         * @param changeAddresses Optional. The addresses that can spend the change remaining from the spent UTXOs. Default: toAddresses
         * @param importIns An array of [[TransferableInput]]s being imported
         * @param sourceChain A {@link https://github.com/feross/buffer|Buffer} for the chainid where the imports are coming from.
         * @param fee Optional. The amount of fees to burn in its smallest denomination, represented as {@link https://github.com/indutny/bn.js/|BN}. Fee will come from the inputs first, if they can.
         * @param feeAssetID Optional. The assetID of the fees being burned.
         * @param memo Optional contains arbitrary bytes, up to 256 bytes
         * @param locktime Optional. The locktime field created in the resulting outputs
         * @param toThreshold Optional. The number of signatures required to spend the funds in the received UTXO
         * @param changeThreshold Optional. The number of signatures required to spend the funds in the resultant change UTXO
         *
         * @returns An unsigned transaction created from the passed in parameters.
         *
         */
        this.buildImportTx = (networkID, blockchainID, toAddresses, fromSigner, changeAddresses, atomics, sourceChain = undefined, fee = zero, feeAssetID = undefined, memo = undefined, asOf = zero, locktime = zero, toThreshold = 1, changeThreshold = 1) => __awaiter(this, void 0, void 0, function* () {
            let ins = [];
            let outs = [];
            let owners = [];
            const importOwners = [];
            if (typeof fee === "undefined") {
                fee = zero.clone();
            }
            const importIns = [];
            let feepaid = new bn_js_1.default(0);
            let feeAssetStr = feeAssetID.toString("hex");
            for (let i = 0; i < atomics.length; i++) {
                const utxo = atomics[`${i}`];
                const assetID = utxo.getAssetID();
                const output = utxo.getOutput();
                let amt = output.getAmount().clone();
                let infeeamount = amt.clone();
                let assetStr = assetID.toString("hex");
                if (typeof feeAssetID !== "undefined" &&
                    fee.gt(zero) &&
                    feepaid.lt(fee) &&
                    assetStr === feeAssetStr) {
                    feepaid = feepaid.add(infeeamount);
                    if (feepaid.gte(fee)) {
                        infeeamount = feepaid.sub(fee);
                        feepaid = fee.clone();
                    }
                    else {
                        infeeamount = zero.clone();
                    }
                }
                const txid = utxo.getTxID();
                const outputidx = utxo.getOutputIdx();
                const input = new _1.SECPTransferInput(amt);
                const xferin = new _1.TransferableInput(txid, outputidx, assetID, input);
                const from = output.getAddresses();
                const spenders = output.getSpenders(from);
                for (let j = 0; j < spenders.length; j++) {
                    const idx = output.getAddressIdx(spenders[`${j}`]);
                    if (idx === -1) {
                        /* istanbul ignore next */
                        throw new errors_1.AddressError("Error - UTXOSet.buildImportTx: no such " +
                            `address in output: ${spenders[`${j}`]}`);
                    }
                    xferin.getInput().addSignatureIdx(idx, spenders[`${j}`]);
                }
                importOwners.push(new common_1.OutputOwners(output.getAddresses(), output.getLocktime(), output.getThreshold()));
                importIns.push(xferin);
                //add extra outputs for each amount (calculated from the imported inputs), minus fees
                if (infeeamount.gt(zero)) {
                    const spendout = (0, _1.SelectOutputClass)(output.getOutputID(), infeeamount, toAddresses, locktime, toThreshold);
                    const xferout = new _1.TransferableOutput(assetID, spendout);
                    outs.push(xferout);
                }
            }
            // get remaining fees from the provided addresses
            let feeRemaining = fee.sub(feepaid);
            if (feeRemaining.gt(zero) && this._feeCheck(feeRemaining, feeAssetID)) {
                const aad = new _1.AssetAmountDestination(toAddresses, toThreshold, fromSigner.from, fromSigner.signer, changeAddresses, changeThreshold);
                aad.addAssetAmount(feeAssetID, zero, feeRemaining);
                const minSpendableErr = yield this.spender.getMinimumSpendable(aad, asOf, locktime, "Unlocked");
                if (typeof minSpendableErr === "undefined") {
                    ins = aad.getInputs();
                    outs = aad.getAllOutputs();
                    owners = aad.getOutputOwners();
                    owners.push(...importOwners);
                }
                else {
                    throw minSpendableErr;
                }
            }
            const baseTx = new _1.ImportTx(networkID, blockchainID, outs, ins, memo, sourceChain, importIns);
            baseTx.setOutputOwners(owners);
            return new _1.UnsignedTx(baseTx);
        });
        /**
         * Creates an unsigned ExportTx transaction.
         *
         * @param networkID The number representing NetworkID of the node
         * @param blockchainID The {@link https://github.com/feross/buffer|Buffer} representing the BlockchainID for the transaction
         * @param amount The amount being exported as a {@link https://github.com/indutny/bn.js/|BN}
         * @param avaxAssetID {@link https://github.com/feross/buffer|Buffer} of the asset ID for AVAX
         * @param toAddresses An array of addresses as {@link https://github.com/feross/buffer|Buffer} who recieves the AVAX
         * @param fromSigner The addresses being used to send and verify the funds from the UTXOs {@link https://github.com/feross/buffer|Buffer}
         * @param changeAddresses An array of addresses as {@link https://github.com/feross/buffer|Buffer} who gets the change leftover of the AVAX
         * @param destinationChain Optional. A {@link https://github.com/feross/buffer|Buffer} for the chainid where to send the asset.
         * @param fee Optional. The amount of fees to burn in its smallest denomination, represented as {@link https://github.com/indutny/bn.js/|BN}
         * @param feeAssetID Optional. The assetID of the fees being burned.
         * @param memo Optional contains arbitrary bytes, up to 256 bytes
         * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
         * @param locktime Optional. The locktime field created in the resulting outputs
         * @param toThreshold Optional. The number of signatures required to spend the funds in the received UTXO
         * @param changeThreshold Optional. The number of signatures required to spend the funds in the resultant change UTXO
         *
         * @returns An unsigned transaction created from the passed in parameters.
         *
         */
        this.buildExportTx = (networkID, blockchainID, amount, amountAssetID, toAddresses, fromSigner, destinationChain, changeAddresses = undefined, fee = zero, feeAssetID = undefined, memo = undefined, asOf = zero, locktime = zero, toThreshold = 1, changeThreshold = 1) => __awaiter(this, void 0, void 0, function* () {
            let ins = [];
            let outs = [];
            let owners = [];
            if (typeof changeAddresses === "undefined") {
                changeAddresses = toAddresses;
            }
            if (amount.eq(zero)) {
                return undefined;
            }
            if (typeof feeAssetID === "undefined") {
                feeAssetID = amountAssetID;
            }
            else if (feeAssetID.toString("hex") !== amountAssetID.toString("hex")) {
                /* istanbul ignore next */
                throw new errors_1.FeeAssetError("Error - CaminoExecutor.buildExportTx: " +
                    `feeAssetID must match avaxAssetID`);
            }
            const aad = new _1.AssetAmountDestination(toAddresses, toThreshold, fromSigner.from, fromSigner.signer, changeAddresses, changeThreshold);
            let singleAsset = true;
            if (amountAssetID.toString("hex") === feeAssetID.toString("hex")) {
                aad.addAssetAmount(amountAssetID, zero, fee.add(amount));
            }
            else {
                singleAsset = false;
                aad.addAssetAmount(amountAssetID, amount, zero);
                if (this._feeCheck(fee, feeAssetID)) {
                    aad.addAssetAmount(feeAssetID, zero, fee);
                }
            }
            const minSpendableErr = yield this.spender.getMinimumSpendable(aad, asOf, locktime, "Unlocked");
            if (typeof minSpendableErr === "undefined") {
                ins = aad.getInputs();
                outs = singleAsset ? aad.getAllOutputs() : aad.getChangeOutputs();
                exports = singleAsset ? [] : aad.getOutputs();
                owners = aad.getOutputOwners();
            }
            else {
                throw minSpendableErr;
            }
            const baseTx = new _1.ExportTx(networkID, blockchainID, outs, ins, memo, destinationChain, exports.length > 0
                ? exports
                : [
                    new _1.SECPTransferOutput(amount, toAddresses, locktime, toThreshold).makeTransferable(amountAssetID)
                ]);
            baseTx.setOutputOwners(owners);
            return new _1.UnsignedTx(baseTx);
        });
        /**
         * Class representing an unsigned [[AddSubnetValidatorTx]] transaction.
         *
         * @param networkID Networkid, [[DefaultNetworkID]]
         * @param blockchainID Blockchainid, default undefined
         * @param fromSigner The addresses being used to send and verify the funds from the UTXOs {@link https://github.com/feross/buffer|Buffer}
         * @param changeAddresses An array of addresses as {@link https://github.com/feross/buffer|Buffer} who gets the change leftover from the fee payment
         * @param nodeID The node ID of the validator being added.
         * @param startTime The Unix time when the validator starts validating the Primary Network.
         * @param endTime The Unix time when the validator stops validating the Primary Network (and staked AVAX is returned).
         * @param weight The amount of weight for this subnet validator.
         * @param fee Optional. The amount of fees to burn in its smallest denomination, represented as {@link https://github.com/indutny/bn.js/|BN}
         * @param feeAssetID Optional. The assetID of the fees being burned.
         * @param memo Optional contains arbitrary bytes, up to 256 bytes
         * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
         * @param subnetAuth Optional. An Auth struct which contains the subnet Auth and the signers.
         * @param changeThreshold Optional. The number of signatures required to spend the funds in the resultant change UTXO
         *
         * @returns An unsigned transaction created from the passed in parameters.
         */
        this.buildAddSubnetValidatorTx = (networkID = utils_1.DefaultNetworkID, blockchainID, fromSigner, changeAddresses, nodeID, startTime, endTime, weight, subnetID, fee = zero, feeAssetID = undefined, memo = undefined, asOf = zero, subnetAuth = { addresses: [], threshold: 0, signer: [] }, changeThreshold = 1) => __awaiter(this, void 0, void 0, function* () {
            let ins = [];
            let outs = [];
            let owners = [];
            const now = (0, utils_1.UnixNow)();
            if (startTime.lt(now) || endTime.lte(startTime)) {
                throw new Error("CaminoExecutor.buildAddSubnetValidatorTx -- startTime must be in the future and endTime must come after startTime");
            }
            if (this._feeCheck(fee, feeAssetID)) {
                const aad = new _1.AssetAmountDestination([], 0, fromSigner.from, fromSigner.signer, changeAddresses, changeThreshold);
                aad.addAssetAmount(feeAssetID, zero, fee);
                const minSpendableErr = yield this.spender.getMinimumSpendable(aad, asOf, zero, this.caminoEnabled ? "Unlocked" : "Stake");
                if (typeof minSpendableErr === "undefined") {
                    ins = aad.getInputs();
                    outs = aad.getAllOutputs();
                    owners = aad.getOutputOwners();
                }
                else {
                    throw minSpendableErr;
                }
            }
            const baseTx = new _1.AddSubnetValidatorTx(networkID, blockchainID, outs, ins, memo, nodeID, startTime, endTime, weight, subnetID);
            subnetAuth.signer.forEach((subnetSigner) => {
                baseTx.addSignatureIdx(subnetSigner[0], subnetSigner[1]);
            });
            // We need to fetch the AUTH for later msig verification
            // For now we use simply what we get in subnetAuth
            owners.push(new common_1.OutputOwners(subnetAuth.addresses, common_1.ZeroBN, subnetAuth.threshold));
            if (this.caminoEnabled) {
                baseTx.includeNodeSignature();
                owners.push(new common_1.OutputOwners([nodeID], common_1.ZeroBN, 1));
            }
            baseTx.setOutputOwners(owners);
            return new _1.UnsignedTx(baseTx);
        });
        /**
         * Class representing an unsigned [[AddDelegatorTx]] transaction.
         *
         * @param networkID Networkid, [[DefaultNetworkID]]
         * @param blockchainID Blockchainid, default undefined
         * @param avaxAssetID {@link https://github.com/feross/buffer|Buffer} of the asset ID for AVAX
         * @param toAddresses An array of addresses as {@link https://github.com/feross/buffer|Buffer} recieves the stake at the end of the staking period
         * @param fromSigner The addresses being used to send and verify the funds from the UTXOs {@link https://github.com/feross/buffer|Buffer}
         * @param changeAddresses An array of addresses as {@link https://github.com/feross/buffer|Buffer} who gets the change leftover from the staking payment
         * @param nodeID The node ID of the validator being added.
         * @param startTime The Unix time when the validator starts validating the Primary Network.
         * @param endTime The Unix time when the validator stops validating the Primary Network (and staked AVAX is returned).
         * @param stakeAmount A {@link https://github.com/indutny/bn.js/|BN} for the amount of stake to be delegated in nAVAX.
         * @param rewardLocktime The locktime field created in the resulting reward outputs
         * @param rewardThreshold The number of signatures required to spend the funds in the resultant reward UTXO
         * @param rewardAddresses The addresses the validator reward goes.
         * @param fee Optional. The amount of fees to burn in its smallest denomination, represented as {@link https://github.com/indutny/bn.js/|BN}
         * @param feeAssetID Optional. The assetID of the fees being burned.
         * @param memo Optional contains arbitrary bytes, up to 256 bytes
         * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
         * @param toThreshold Optional. The number of signatures required to spend the funds in the stake UTXO
         * @param changeThreshold Optional. The number of signatures required to spend the funds in the change UTXO
         *
         * @returns An unsigned transaction created from the passed in parameters.
         */
        this.buildAddDelegatorTx = (networkID = utils_1.DefaultNetworkID, blockchainID, avaxAssetID, toAddresses, fromSigner, changeAddresses, nodeID, startTime, endTime, stakeAmount, rewardLocktime, rewardThreshold, rewardAddresses, fee = zero, feeAssetID = undefined, memo = undefined, asOf = zero, toThreshold = 1, changeThreshold = 1) => __awaiter(this, void 0, void 0, function* () {
            if (this.caminoEnabled) {
                throw new errors_1.ProtocolError("buildAddDelegatorTx - Not supported in Camino mode");
            }
            if (rewardThreshold > rewardAddresses.length) {
                /* istanbul ignore next */
                throw new errors_1.ThresholdError("Error - UTXOSet.buildAddDelegatorTx: reward threshold is greater than number of addresses");
            }
            if (typeof changeAddresses === "undefined") {
                changeAddresses = toAddresses;
            }
            let ins = [];
            let outs = [];
            let stakeOuts = [];
            let owners = [];
            const now = (0, utils_1.UnixNow)();
            if (startTime.lt(now) || endTime.lte(startTime)) {
                throw new errors_1.TimeError("UTXOSet.buildAddDelegatorTx -- startTime must be in the future and endTime must come after startTime");
            }
            const aad = new _1.AssetAmountDestination(toAddresses, toThreshold, fromSigner.from, fromSigner.signer, changeAddresses, changeThreshold);
            if (avaxAssetID.toString("hex") === feeAssetID.toString("hex")) {
                aad.addAssetAmount(avaxAssetID, stakeAmount, fee);
            }
            else {
                aad.addAssetAmount(avaxAssetID, stakeAmount, zero);
                if (this._feeCheck(fee, feeAssetID)) {
                    aad.addAssetAmount(feeAssetID, zero, fee);
                }
            }
            const minSpendableErr = yield this.spender.getMinimumSpendable(aad, asOf, zero, "Stake");
            if (typeof minSpendableErr === "undefined") {
                ins = aad.getInputs();
                outs = aad.getChangeOutputs();
                stakeOuts = aad.getOutputs();
                owners = aad.getOutputOwners();
            }
            else {
                throw minSpendableErr;
            }
            const rewardOutputOwners = new _1.SECPOwnerOutput(rewardAddresses, rewardLocktime, rewardThreshold);
            const baseTx = new _1.AddDelegatorTx(networkID, blockchainID, outs, ins, memo, nodeID, startTime, endTime, stakeAmount, stakeOuts, new _1.ParseableOutput(rewardOutputOwners));
            baseTx.setOutputOwners(owners);
            return new _1.UnsignedTx(baseTx);
        });
        /**
         * Class representing an unsigned [[AddValidatorTx]] transaction.
         *
         * @param networkID NetworkID, [[DefaultNetworkID]]
         * @param blockchainID BlockchainID, default undefined
         * @param avaxAssetID {@link https://github.com/feross/buffer|Buffer} of the asset ID for AVAX
         * @param toAddresses An array of addresses as {@link https://github.com/feross/buffer|Buffer} recieves the stake at the end of the staking period
         * @param fromSigner The addresses being used to send and verify the funds from the UTXOs {@link https://github.com/feross/buffer|Buffer}
         * @param changeAddresses An array of addresses as {@link https://github.com/feross/buffer|Buffer} who gets the change leftover from the staking payment
         * @param nodeID The node ID of the validator being added.
         * @param startTime The Unix time when the validator starts validating the Primary Network.
         * @param endTime The Unix time when the validator stops validating the Primary Network (and staked AVAX is returned).
         * @param stakeAmount A {@link https://github.com/indutny/bn.js/|BN} for the amount of stake to be delegated in nAVAX.
         * @param rewardLocktime The locktime field created in the resulting reward outputs
         * @param rewardThreshold The number of signatures required to spend the funds in the resultant reward UTXO
         * @param rewardAddresses The addresses the validator reward goes.
         * @param delegationFee A number for the percentage of reward to be given to the validator when someone delegates to them. Must be between 0 and 100.
         * @param minStake A {@link https://github.com/indutny/bn.js/|BN} representing the minimum stake required to validate on this network.
         * @param fee Optional. The amount of fees to burn in its smallest denomination, represented as {@link https://github.com/indutny/bn.js/|BN}
         * @param feeAssetID Optional. The assetID of the fees being burned.
         * @param memo Optional contains arbitrary bytes, up to 256 bytes
         * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
         * @param toThreshold Optional. The number of signatures required to spend the funds in the stake UTXO
         * @param changeThreshold Optional. The number of signatures required to spend the funds in the change UTXO
         */
        this.buildAddValidatorTx = (networkID = utils_1.DefaultNetworkID, blockchainID, toAddresses, fromSigner, changeAddresses, nodeID, startTime, endTime, stakeAmount, stakeAssetID, rewardLocktime, rewardThreshold, rewardAddresses, delegationFee, fee = zero, feeAssetID = undefined, memo = undefined, asOf = (0, utils_1.UnixNow)(), toThreshold = 1, changeThreshold = 1) => __awaiter(this, void 0, void 0, function* () {
            if (this.caminoEnabled) {
                throw new Error("Use buildCaminoAddValidatorTx");
            }
            let ins = [];
            let outs = [];
            let stakeOuts = [];
            let owners = [];
            const now = (0, utils_1.UnixNow)();
            if (startTime.lt(now) || endTime.lte(startTime)) {
                throw new errors_1.TimeError("UTXOSet.buildAddValidatorTx -- startTime must be in the future and endTime must come after startTime");
            }
            if (delegationFee > 100 || delegationFee < 0) {
                throw new errors_1.TimeError("UTXOSet.buildAddValidatorTx -- startTime must be in the range of 0 to 100, inclusively");
            }
            const aad = new _1.AssetAmountDestination(toAddresses, toThreshold, fromSigner.from, fromSigner.signer, changeAddresses, changeThreshold);
            if (stakeAssetID.toString("hex") === feeAssetID.toString("hex")) {
                aad.addAssetAmount(stakeAssetID, stakeAmount, fee);
            }
            else {
                aad.addAssetAmount(stakeAssetID, stakeAmount, zero);
                if (this._feeCheck(fee, feeAssetID)) {
                    aad.addAssetAmount(feeAssetID, zero, fee);
                }
            }
            const minSpendableErr = yield this.spender.getMinimumSpendable(aad, asOf, zero, "Stake");
            if (typeof minSpendableErr === "undefined") {
                ins = aad.getInputs();
                outs = aad.getChangeOutputs();
                stakeOuts = aad.getOutputs();
                owners = aad.getOutputOwners();
            }
            else {
                throw minSpendableErr;
            }
            const rewardOutputOwners = new _1.SECPOwnerOutput(rewardAddresses, rewardLocktime, rewardThreshold);
            const baseTx = new _1.AddValidatorTx(networkID, blockchainID, outs, ins, memo, nodeID, startTime, endTime, stakeAmount, stakeOuts, new _1.ParseableOutput(rewardOutputOwners), delegationFee);
            baseTx.setOutputOwners(owners);
            return new _1.UnsignedTx(baseTx);
        });
        /**
         * Class representing an unsigned [[CreateSubnetTx]] transaction.
         *
         * @param networkID Networkid, [[DefaultNetworkID]]
         * @param blockchainID Blockchainid, default undefined
         * @param fromSigner The addresses being used to send and verify the funds from the UTXOs {@link https://github.com/feross/buffer|Buffer}
         * @param changeAddresses The addresses that can spend the change remaining from the spent UTXOs.
         * @param subnetOwnerAddresses An array of {@link https://github.com/feross/buffer|Buffer} for the addresses to add to a subnet
         * @param subnetOwnerThreshold The number of owners's signatures required to add a validator to the network
         * @param fee Optional. The amount of fees to burn in its smallest denomination, represented as {@link https://github.com/indutny/bn.js/|BN}
         * @param feeAssetID Optional. The assetID of the fees being burned
         * @param memo Optional contains arbitrary bytes, up to 256 bytes
         * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
         * @param changeThreshold Optional. The number of signatures required to spend the funds in the resultant change UTXO
         *
         * @returns An unsigned transaction created from the passed in parameters.
         */
        this.buildCreateSubnetTx = (networkID = utils_1.DefaultNetworkID, blockchainID, fromSigner, changeAddresses, subnetOwnerAddresses, subnetOwnerThreshold, fee = zero, feeAssetID = undefined, memo = undefined, asOf = zero, changeThreshold = 1) => __awaiter(this, void 0, void 0, function* () {
            let ins = [];
            let outs = [];
            let owners = [];
            if (this._feeCheck(fee, feeAssetID)) {
                const aad = new _1.AssetAmountDestination([], 0, fromSigner.from, fromSigner.signer, changeAddresses, changeThreshold);
                aad.addAssetAmount(feeAssetID, zero, fee);
                const minSpendableErr = yield this.spender.getMinimumSpendable(aad, asOf, zero, "Unlocked");
                if (typeof minSpendableErr === "undefined") {
                    ins = aad.getInputs();
                    outs = aad.getAllOutputs();
                    owners = aad.getOutputOwners();
                }
                else {
                    throw minSpendableErr;
                }
            }
            const locktime = new bn_js_1.default(0);
            const subnetOwners = new _1.SECPOwnerOutput(subnetOwnerAddresses, locktime, subnetOwnerThreshold);
            const baseTx = new _1.CreateSubnetTx(networkID, blockchainID, outs, ins, memo, subnetOwners);
            baseTx.setOutputOwners(owners);
            return new _1.UnsignedTx(baseTx);
        });
        /**
         * Build an unsigned [[CreateChainTx]].
         *
         * @param networkID Networkid, [[DefaultNetworkID]]
         * @param blockchainID Blockchainid, default undefined
         * @param fromSigner The addresses being used to send and verify the funds from the UTXOs {@link https://github.com/feross/buffer|Buffer}
         * @param changeAddresses The addresses that can spend the change remaining from the spent UTXOs.
         * @param subnetID Optional ID of the Subnet that validates this blockchain
         * @param chainName Optional A human readable name for the chain; need not be unique
         * @param vmID Optional ID of the VM running on the new chain
         * @param fxIDs Optional IDs of the feature extensions running on the new chain
         * @param genesisData Optional Byte representation of genesis state of the new chain
         * @param fee Optional. The amount of fees to burn in its smallest denomination, represented as {@link https://github.com/indutny/bn.js/|BN}
         * @param feeAssetID Optional. The assetID of the fees being burned
         * @param memo Optional contains arbitrary bytes, up to 256 bytes
         * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
         * @param subnetAuth Optional. An Auth struct to sign for the Subnet.
         * @param changeThreshold Optional. The number of signatures required to spend the funds in the resultant change UTXO
         *
         * @returns An unsigned CreateChainTx created from the passed in parameters.
         */
        this.buildCreateChainTx = (networkID = utils_1.DefaultNetworkID, blockchainID, fromSigner, changeAddresses, subnetID = undefined, chainName = undefined, vmID = undefined, fxIDs = undefined, genesisData = undefined, fee = zero, feeAssetID = undefined, memo = undefined, asOf = zero, subnetAuth = { addresses: [], threshold: 0, signer: [] }, changeThreshold = 1) => __awaiter(this, void 0, void 0, function* () {
            let ins = [];
            let outs = [];
            let owners = [];
            if (this._feeCheck(fee, feeAssetID)) {
                const aad = new _1.AssetAmountDestination([], 0, fromSigner.from, fromSigner.signer, changeAddresses, changeThreshold);
                aad.addAssetAmount(feeAssetID, zero, fee);
                const minSpendableErr = yield this.spender.getMinimumSpendable(aad, asOf, zero, "Unlocked");
                if (typeof minSpendableErr === "undefined") {
                    ins = aad.getInputs();
                    outs = aad.getAllOutputs();
                    owners = aad.getOutputOwners();
                }
                else {
                    throw minSpendableErr;
                }
            }
            const baseTx = new _1.CreateChainTx(networkID, blockchainID, outs, ins, memo, subnetID, chainName, vmID, fxIDs, genesisData);
            subnetAuth.signer.forEach((subnetAuthSigner) => {
                baseTx.addSignatureIdx(subnetAuthSigner[0], subnetAuthSigner[1]);
            });
            // We need to fetch the AUTH for later msig verification
            // For now we use simply what we get in subnetAuth
            owners.push(new common_1.OutputOwners(subnetAuth.addresses, common_1.ZeroBN, subnetAuth.threshold));
            baseTx.setOutputOwners(owners);
            return new _1.UnsignedTx(baseTx);
        });
        /**
         * Helper function which creates an unsigned [[CaminoAddValidatorTx]]. For more granular control, you may create your own
         * [[UnsignedTx]] manually and import the [[CaminoAddValidatorTx]] class directly.
         *
         * @param networkID Networkid, [[DefaultNetworkID]]
         * @param blockchainID Blockchainid, default undefined
         * @param toAddresses An array of addresses as {@link https://github.com/feross/buffer|Buffer} who received the staked tokens at the end of the staking period
         * @param fromSigner The addresses being used to send and verify the funds from the UTXOs {@link https://github.com/feross/buffer|Buffer}
         * @param changeAddresses An array of addresses as {@link https://github.com/feross/buffer|Buffer} who gets the change leftover from the fee payment
         * @param nodeID The node ID of the validator being added.
         * @param nodeOwner The address and signature indices of the registered nodeId owner.
         * @param startTime The Unix time when the validator starts validating the Primary Network.
         * @param endTime The Unix time when the validator stops validating the Primary Network (and staked AVAX is returned).
         * @param stakeAmount The amount being delegated as a {@link https://github.com/indutny/bn.js/|BN}
         * @param rewardAddresses The addresses which will recieve the rewards from the delegated stake.
         * @param rewardLocktime Optional. The locktime field created in the resulting reward outputs
         * @param rewardThreshold Opional. The number of signatures required to spend the funds in the resultant reward UTXO. Default 1.
         * @param memo Optional contains arbitrary bytes, up to 256 bytes
         * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
         * @param toThreshold Optional. The number of signatures required to spend the funds in the received UTXO
         * @param changeThreshold Optional. The number of signatures required to spend the funds in the resultant change UTXO
         *
         * @returns An unsigned transaction created from the passed in parameters.
         */
        this.buildCaminoAddValidatorTx = (networkID = utils_1.DefaultNetworkID, blockchainID, fromSigner, change, nodeID, nodeOwner, startTime, endTime, stakeAmount, stakeAssetID, rewards, rewardLocktime = zero, rewardThreshold = 1, memo = undefined, asOf = zero, toThreshold = 1, changeThreshold = 1) => __awaiter(this, void 0, void 0, function* () {
            let ins = [];
            let outs = [];
            let owners = [];
            const now = (0, utils_1.UnixNow)();
            if (startTime.lt(now) || endTime.lte(startTime)) {
                throw new errors_1.TimeError("buildCaminoAddValidatorTx -- startTime must be in the future and endTime must come after startTime");
            }
            const aad = new _1.AssetAmountDestination([], toThreshold, fromSigner.from, fromSigner.signer, change, changeThreshold);
            aad.addAssetAmount(stakeAssetID, stakeAmount, new bn_js_1.default(0));
            const minSpendableErr = yield this.spender.getMinimumSpendable(aad, asOf, zero, "Bond");
            if (typeof minSpendableErr === "undefined") {
                ins = aad.getInputs();
                outs = aad.getAllOutputs();
                owners = aad.getOutputOwners();
            }
            else {
                throw minSpendableErr;
            }
            const rewardOutputOwners = new _1.SECPOwnerOutput(rewards, rewardLocktime, rewardThreshold);
            const baseTx = new _1.CaminoAddValidatorTx(networkID, blockchainID, outs, ins, memo, nodeID, startTime, endTime, stakeAmount, new _1.ParseableOutput(rewardOutputOwners));
            nodeOwner.auth.forEach((o) => {
                baseTx.addSignatureIdx(o[0], o[1]);
            });
            owners.push(new common_1.OutputOwners([nodeOwner.address], common_1.ZeroBN, 1));
            baseTx.setOutputOwners(owners);
            return new _1.UnsignedTx(baseTx);
        });
        /**
         * Build an unsigned [[AddressStateTx]].
         *
         * @param version Optional. Transaction version number, default 0.
         * @param networkID Networkid, [[DefaultNetworkID]]
         * @param blockchainID Blockchainid, default undefined
         * @param fromSigner The addresses being used to send and verify the funds from the UTXOs {@link https://github.com/feross/buffer|Buffer}
         * @param changeAddresses The addresses that can spend the change remaining from the spent UTXOs.
         * @param address The address to alter state.
         * @param state The state to set or remove on the given address
         * @param remove Optional. Flag if state should be applied or removed
         * @param fee Optional. The amount of fees to burn in its smallest denomination, represented as {@link https://github.com/indutny/bn.js/|BN}
         * @param feeAssetID Optional. The assetID of the fees being burned
         * @param memo Optional contains arbitrary bytes, up to 256 bytes
         * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
         * @param changeThreshold Optional. The number of signatures required to spend the funds in the resultant change UTXO
         *
         * @returns An unsigned AddressStateTx created from the passed in parameters.
         */
        this.buildAddressStateTx = (version = utils_1.DefaultTransactionVersionNumber, networkID = utils_1.DefaultNetworkID, blockchainID, fromSigner, changeAddresses, address, state, remove = false, fee = zero, feeAssetID = undefined, memo = undefined, asOf = zero, changeThreshold = 1, executorAddress = undefined, executorAuth = []) => __awaiter(this, void 0, void 0, function* () {
            let ins = [];
            let outs = [];
            let owners = [];
            if (this._feeCheck(fee, feeAssetID)) {
                const aad = new _1.AssetAmountDestination([], 0, fromSigner.from, fromSigner.signer, changeAddresses, changeThreshold);
                aad.addAssetAmount(feeAssetID, zero, fee);
                const minSpendableErr = yield this.spender.getMinimumSpendable(aad, asOf, zero, "Unlocked");
                if (typeof minSpendableErr === "undefined") {
                    ins = aad.getInputs();
                    outs = aad.getAllOutputs();
                }
                else {
                    throw minSpendableErr;
                }
            }
            const baseTx = new _1.AddressStateTx(version, networkID, blockchainID, outs, ins, memo, address, state, remove, executorAddress);
            if (executorAddress) {
                executorAuth.forEach((signer) => {
                    baseTx.addSignatureIdx(signer[0], signer[1]);
                });
                owners.push(new common_1.OutputOwners([executorAddress], common_1.ZeroBN, 1));
            }
            baseTx.setOutputOwners(owners);
            return new _1.UnsignedTx(baseTx);
        });
        /**
         * Build an unsigned [[RegisterNodeTx]].
         *
         * @param networkID Networkid, [[DefaultNetworkID]]
         * @param blockchainID Blockchainid, default undefined
         * @param fromSigner The addresses being used to send and verify the funds from the UTXOs {@link https://github.com/feross/buffer|Buffer}
         * @param changeAddresses The addresses that can spend the change remaining from the spent UTXOs.
         * @param oldNodeID Optional. ID of the existing NodeID to replace or remove.
         * @param newNodeID Optional. ID of the newNodID to register address.
         * @param address The consortiumMemberAddress, single or multi-sig.
         * @param addressAuths An array of index and address to verify ownership of address.
         * @param fee Optional. The amount of fees to burn in its smallest denomination, represented as {@link https://github.com/indutny/bn.js/|BN}
         * @param feeAssetID Optional. The assetID of the fees being burned
         * @param memo Optional contains arbitrary bytes, up to 256 bytes
         * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
         * @param changeThreshold Optional. The number of signatures required to spend the funds in the resultant change UTXO
         *
         * @returns An unsigned RegisterNodeTx created from the passed in parameters.
         */
        this.buildRegisterNodeTx = (networkID = utils_1.DefaultNetworkID, blockchainID, fromSigner, changeAddresses, oldNodeID = undefined, newNodeID = undefined, address = undefined, addressAuths = [], fee = zero, feeAssetID = undefined, memo = undefined, asOf = zero, changeThreshold = 1) => __awaiter(this, void 0, void 0, function* () {
            let ins = [];
            let outs = [];
            let owners = [];
            if (this._feeCheck(fee, feeAssetID)) {
                const aad = new _1.AssetAmountDestination([], 0, fromSigner.from, fromSigner.signer, changeAddresses, changeThreshold);
                aad.addAssetAmount(feeAssetID, zero, fee);
                const minSpendableErr = yield this.spender.getMinimumSpendable(aad, asOf, zero, "Unlocked");
                if (typeof minSpendableErr === "undefined") {
                    ins = aad.getInputs();
                    outs = aad.getAllOutputs();
                    owners = aad.getOutputOwners();
                }
                else {
                    throw minSpendableErr;
                }
            }
            const baseTx = new _1.RegisterNodeTx(networkID, blockchainID, outs, ins, memo, oldNodeID, newNodeID, address);
            addressAuths.forEach((addressAuth) => {
                baseTx.addSignatureIdx(addressAuth[0], addressAuth[1]);
            });
            owners.push(newNodeID && !oldNodeID
                ? new common_1.OutputOwners([newNodeID], common_1.ZeroBN, 1)
                : new common_1.OutputOwners());
            owners.push(new common_1.OutputOwners([address], common_1.ZeroBN, 1));
            baseTx.setOutputOwners(owners);
            return new _1.UnsignedTx(baseTx);
        });
        /**
         * Build an unsigned [[DepositTx]].
         *
         * @param version Optional. Transaction version number, default 0.
         * @param networkID Networkid, [[DefaultNetworkID]]
         * @param blockchainID Blockchainid, default undefined
         * @param fromSigner The addresses being used to send and verify the funds from the UTXOs {@link https://github.com/feross/buffer|Buffer}
         * @param changeAddresses The addresses that can spend the change remaining from the spent UTXOs.
         * @param depositOfferID ID of the deposit offer.
         * @param depositDuration Duration of the deposit
         * @param rewardsOwner Optional The owners of the reward. If omitted, all inputs must have the same owner
         * @param depositCreatorAddress Address that is authorized to create deposit with given offer. Could be empty, if offer owner is empty.
         * @param depositCreatorAuth Auth for deposit creator address
         * @param depositOfferOwnerSigs Signatures which recover to depositOfferOwner address(es)
         * @param depositOfferOwnerAuth Auth for deposit offer owner
         * @param fee Optional. The amount of fees to burn in its smallest denomination, represented as {@link https://github.com/indutny/bn.js/|BN}
         * @param feeAssetID Optional. The assetID of the fees being burned
         * @param memo Optional contains arbitrary bytes, up to 256 bytes
         * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
         * @param changeThreshold Optional. The number of signatures required to spend the funds in the resultant change UTXO
         *
         * @returns An unsigned DepositTx created from the passed in parameters.
         */
        this.buildDepositTx = (version = utils_1.DefaultTransactionVersionNumber, networkID = utils_1.DefaultNetworkID, blockchainID, fromSigner, changeAddresses, depositOfferID, depositDuration, rewardsOwner, depositCreatorAddress = undefined, depositCreatorAuth = [], depositOfferOwnerSigs = [], depositOfferOwnerAuth = [], fee = zero, feeAssetID = undefined, memo = undefined, asOf = zero, amountToLock, changeThreshold = 1, to = [], toThreshold = 0) => __awaiter(this, void 0, void 0, function* () {
            let ins = [];
            let outs = [];
            let owners = [];
            if (this._feeCheck(fee, feeAssetID)) {
                const aad = new _1.AssetAmountDestination(to, toThreshold, fromSigner.from, fromSigner.signer, changeAddresses, changeThreshold);
                aad.addAssetAmount(feeAssetID, amountToLock, fee);
                const minSpendableErr = yield this.spender.getMinimumSpendable(aad, asOf, zero, "Deposit");
                if (typeof minSpendableErr === "undefined") {
                    ins = aad.getInputs();
                    outs = aad.getAllOutputs();
                    owners = aad.getOutputOwners();
                }
                else {
                    throw minSpendableErr;
                }
            }
            const secpOwners = new _1.SECPOwnerOutput(rewardsOwner.getAddresses(), rewardsOwner === null || rewardsOwner === void 0 ? void 0 : rewardsOwner.getLocktime(), rewardsOwner.getThreshold());
            const baseTx = new _1.DepositTx(version, networkID, blockchainID, outs, ins, memo, depositOfferID, depositDuration, new _1.ParseableOutput(secpOwners), depositCreatorAddress);
            if (version > 0) {
                baseTx.addDepositCreatorAuth(depositCreatorAuth);
                baseTx.addOwnerAuth(depositOfferOwnerAuth, depositOfferOwnerSigs);
                owners.push(new common_1.OutputOwners([depositCreatorAddress], common_1.ZeroBN, 1));
                // Create pseudo addresses for Multisig, they have to passed
                // to MultisigKeychain on keychain initialization
                const numAddresses = depositOfferOwnerAuth.length > 0
                    ? depositOfferOwnerAuth.at(depositOfferOwnerAuth.length - 1)[0]
                    : 0;
                const addrs = [];
                for (let i = 0; i < numAddresses; ++i) {
                    addrs.push(buffer_1.Buffer.alloc(20));
                    addrs.at(addrs.length - 1).writeUIntBE(i + 1, 16, 4);
                }
                owners.push(new common_1.OutputOwners(addrs, common_1.ZeroBN, depositOfferOwnerAuth.length));
            }
            baseTx.setOutputOwners(owners);
            return new _1.UnsignedTx(baseTx);
        });
        /**
         * Build an unsigned [[UnlockDepositTx]].
         *
         * @param networkID Networkid, [[DefaultNetworkID]]
         * @param blockchainID Blockchainid, default undefined
         * @param fromSigner @param fromSigner The addresses being used to send and verify the funds from the UTXOs {@link https://github.com/feross/buffer|Buffer}
         * @param changeAddresses The addresses that can spend the change remaining from the spent UTXOs.
         * @param fee Optional. The amount of fees to burn in its smallest denomination, represented as {@link https://github.com/indutny/bn.js/|BN}
         * @param feeAssetID Optional. The assetID of the fees being burned
         * @param memo Optional contains arbitrary bytes, up to 256 bytes
         * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
         * @param changeThreshold Optional. The number of signatures required to spend the funds in the resultant change UTXO
         *
         * @returns An unsigned UnlockDepositTx created from the passed in parameters.
         */
        this.buildUnlockDepositTx = (networkID = utils_1.DefaultNetworkID, blockchainID, fromSigner, changeAddresses, fee = zero, feeAssetID = undefined, memo = undefined, asOf = zero, changeThreshold = 1) => __awaiter(this, void 0, void 0, function* () {
            let ins = [];
            let outs = [];
            if (this._feeCheck(fee, feeAssetID)) {
                const aad = new _1.AssetAmountDestination([], 0, fromSigner.from, fromSigner.signer, changeAddresses, changeThreshold);
                aad.addAssetAmount(feeAssetID, zero, fee);
                const minSpendableErr = yield this.spender.getMinimumSpendable(aad, asOf, zero, "Unlocked");
                if (typeof minSpendableErr === "undefined") {
                    ins = aad.getInputs();
                    outs = aad.getAllOutputs();
                }
                else {
                    throw minSpendableErr;
                }
            }
            const unlockDepositTx = new _1.UnlockDepositTx(networkID, blockchainID, outs, ins, memo);
            return new _1.UnsignedTx(unlockDepositTx);
        });
        /**
         * Build an unsigned [[ClaimTx]].
         *
         * @param networkID NetworkID, [[DefaultNetworkID]]
         * @param blockchainID BlockchainID, default undefined
         * @param fromSigner @param fromSigner The addresses being used to send and verify the funds from the UTXOs {@link https://github.com/feross/buffer|Buffer}
         * @param changeAddresses The addresses that can spend the change remaining from the spent UTXOs.
         * @param fee Optional. The amount of fees to burn in its smallest denomination, represented as {@link https://github.com/indutny/bn.js/|BN}
         * @param feeAssetID Optional. The assetID of the fees being burned
         * @param memo Optional contains arbitrary bytes, up to 256 bytes
         * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
         * @param changeThreshold Optional. The number of signatures required to spend the funds in the resultant change UTXO
         * @param claimAmounts The specification and authentication what and how much to claim
         * @param claimTo The address to claimed rewards will be directed to
         *
         * @returns An unsigned ClaimTx created from the passed in parameters.
         */
        this.buildClaimTx = (networkID = utils_1.DefaultNetworkID, blockchainID, fromSigner, changeAddresses, fee = zero, feeAssetID = undefined, memo = undefined, asOf = zero, changeThreshold = 1, claimAmounts, claimTo = undefined) => __awaiter(this, void 0, void 0, function* () {
            let ins = [];
            let outs = [];
            let owners = [];
            if (this._feeCheck(fee, feeAssetID)) {
                const aad = new _1.AssetAmountDestination([], 0, fromSigner.from, fromSigner.signer, changeAddresses, changeThreshold);
                aad.addAssetAmount(feeAssetID, zero, fee);
                const minSpendableErr = yield this.spender.getMinimumSpendable(aad, asOf, zero, "Unlocked");
                if (typeof minSpendableErr === "undefined") {
                    ins = aad.getInputs();
                    outs = aad.getAllOutputs();
                    owners = aad.getOutputOwners();
                }
                else {
                    throw minSpendableErr;
                }
            }
            // TODO: Compact if possible
            const txClaimAmounts = [];
            const allSigIdxs = [];
            for (const amt of claimAmounts) {
                const receiver = claimTo ? claimTo : amt.owners;
                outs.push(new _1.TransferableOutput(feeAssetID, new _1.SECPTransferOutput(amt.amount, receiver.getAddresses(), receiver.getLocktime(), receiver.getThreshold())));
                let id = amt.id;
                if (!id) {
                    if (amt.claimType === _1.ClaimType.ACTIVE_DEPOSIT_REWARD)
                        throw new Error("ClaimAmount id must be set");
                    const b = buffer_1.Buffer.alloc(2, _1.PlatformVMConstants.LATESTCODEC);
                    id = buffer_1.Buffer.from((0, create_hash_1.default)("sha256")
                        .update(buffer_1.Buffer.concat([b, amt.owners.toBuffer()]))
                        .digest());
                }
                // Create SigIdxs
                if (amt.sigIdxs.length !== amt.owners.getThreshold())
                    throw new Error("SigIdx count mismatch");
                const sigIdxs = [];
                const addrs = amt.owners.getAddresses();
                for (const idx of amt.sigIdxs) {
                    if (idx >= addrs.length)
                        throw new Error("SigIdx out of bound");
                    sigIdxs.push(new common_1.SigIdx(idx, addrs[idx]));
                }
                // Create auth for verification of claimAmount owner
                const bufferSigIdxs = sigIdxs.map((s) => s.getBytes());
                txClaimAmounts.push(new _1.ClaimAmount(id, amt.claimType, amt.amount, bufferSigIdxs));
                allSigIdxs.push(sigIdxs);
                owners.push(amt.owners);
            }
            const claimTx = new _1.ClaimTx(networkID, blockchainID, outs, ins, memo, txClaimAmounts);
            // Build signatureIndices
            for (const s of allSigIdxs)
                claimTx.addSigIdxs(s);
            claimTx.setOutputOwners(owners);
            return new _1.UnsignedTx(claimTx);
        });
        /**
         * Build an unsigned [[MultisigAliasTx]].
         *
         * @param networkID Network ID, default [[DefaultNetworkID]]
         * @param blockchainID Blockchain ID, default undefined
         * @param fromSigner The addresses being used to send and verify the funds from the UTXOs
         * @param changeAddresses The addresses that can spend the change remaining from the spent UTXOs
         * @param multisigAliasParams Parameters of MultisigAliasTx. multisigAliasParams.ID must be empty if it's the new alias
         * @param fee Optional amount of fees to burn in its smallest denomination, represented as BN
         * @param feeAssetID Optional asset ID of the fees being burned
         * @param memo Optional contains arbitrary bytes, up to 256 bytes
         * @param asOf Optional timestamp to verify the transaction against, as BN
         * @param changeThreshold Optional number of signatures required to spend the funds in the resultant change UTXO
         *
         * @returns An unsigned MultisigAliasTx created from the passed-in parameters.
         */
        this.buildMultisigAliasTx = (networkID = utils_1.DefaultNetworkID, blockchainID, fromSigner, changeAddresses, multisigAliasParams, fee = zero, feeAssetID = undefined, memo = undefined, asOf = zero, changeThreshold = 1) => __awaiter(this, void 0, void 0, function* () {
            let ins = [];
            let outs = [];
            let owners = [];
            if (this._feeCheck(fee, feeAssetID)) {
                const aad = new _1.AssetAmountDestination([], 0, fromSigner.from, fromSigner.signer, changeAddresses, changeThreshold);
                aad.addAssetAmount(feeAssetID, zero, fee);
                const minSpendableErr = yield this.spender.getMinimumSpendable(aad, asOf, zero, "Unlocked");
                if (typeof minSpendableErr === "undefined") {
                    ins = aad.getInputs();
                    outs = aad.getAllOutputs();
                    owners = aad.getOutputOwners();
                }
                else {
                    throw minSpendableErr;
                }
            }
            const output = new _1.SECPOwnerOutput(multisigAliasParams.owners.getAddresses(), multisigAliasParams.owners.getLocktime(), multisigAliasParams.owners.getThreshold());
            const multisigAlias = new _1.MultisigAlias(multisigAliasParams.id, buffer_1.Buffer.from(multisigAliasParams.memo, "utf-8"), new _1.ParseableOutput(output));
            const baseTx = new _1.MultisigAliasTx(networkID, blockchainID, outs, ins, memo, multisigAlias);
            multisigAliasParams.auth.forEach((addressAuth) => {
                baseTx.addSignatureIdx(addressAuth[0], addressAuth[1]);
            });
            if (multisigAliasParams.id && multisigAliasParams.id.length != 0) {
                owners.push(new common_1.OutputOwners([multisigAliasParams.id], common_1.ZeroBN, 1));
            }
            baseTx.setOutputOwners(owners);
            return new _1.UnsignedTx(baseTx);
        });
        /**
         * Build an unsigned [[AddDepositOfferTx]].
         *
         * @param networkID
         * @param blockchainID
         * @param fromSigner
         * @param changeAddresses
         * @param depositOffer
         * @param depositOfferCreatorAddress
         * @param depositOfferCreatorAuth
         * @param fee
         * @param feeAssetID
         * @param memo
         * @param asOf
         * @param changeThreshold
         */
        this.buildAddDepositOfferTx = (networkID = utils_1.DefaultNetworkID, blockchainID, fromSigner, changeAddresses, offer, depositOfferCreatorAddress, depositOfferCreatorAuth = [], fee = zero, feeAssetID = undefined, memo = undefined, asOf = zero, changeThreshold = 1) => __awaiter(this, void 0, void 0, function* () {
            let ins = [];
            let outs = [];
            let owners = [];
            if (this._feeCheck(fee, feeAssetID)) {
                const aad = new _1.AssetAmountDestination([], 0, fromSigner.from, fromSigner.signer, changeAddresses, changeThreshold);
                aad.addAssetAmount(feeAssetID, zero, fee);
                const minSpendableErr = yield this.spender.getMinimumSpendable(aad, asOf, zero, "Unlocked");
                if (typeof minSpendableErr === "undefined") {
                    ins = aad.getInputs();
                    outs = aad.getAllOutputs();
                    owners = aad.getOutputOwners();
                }
                else {
                    throw minSpendableErr;
                }
            }
            const baseTx = new adddepositoffertx_1.AddDepositOfferTx(networkID, blockchainID, outs, ins, memo, offer, depositOfferCreatorAddress);
            depositOfferCreatorAuth.forEach((signer) => {
                baseTx.addSignatureIdx(signer[0], signer[1]);
            });
            owners.push(new common_1.OutputOwners([depositOfferCreatorAddress], common_1.ZeroBN, 1));
            baseTx.setOutputOwners(owners);
            return new _1.UnsignedTx(baseTx);
        });
        /**
         * Build an unsigned [[AddProposalTx]].
         *
         * @param networkID Networkid, [[DefaultNetworkID]]
         * @param blockchainID Blockchainid, default undefined
         * @param fromSigner The addresses being used to send and verify the funds from the UTXOs {@link https://github.com/feross/buffer|Buffer}
         * @param changeAddresses The addresses that can spend the change remaining from the spent UTXOs.
         * @param proposalDescription Optional contains arbitrary bytes, up to 256 bytes
         * @param proposal The proposal content that will be created.
         * @param proposerAddress The P-address of proposer in Buffer.
         * @param proposerAuth Auth for proposer address
         * @param version Optional. Transaction version number, default 0.
         * @param memo Optional contains arbitrary bytes, up to 256 bytes
         * @param fee Optional. The amount of fees to burn in its smallest denomination, represented as {@link https://github.com/indutny/bn.js/|BN}
         * @param feeAssetID Optional. The assetID of the fees being burned
         * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
         * @param stakeAmount A {@link https://github.com/indutny/bn.js/|BN} for the amount of stake to be delegated in nAVAX.
         * @param stakeAssetID
         * @param toThreshold Optional. The number of signatures required to spend the funds in the resultant UTXO
         * @param changeThreshold Optional. The number of signatures required to spend the funds in the resultant change UTXO
         *
         * @returns An unsigned AddProposalTx created from the passed in parameters.
         */
        this.buildAddProposalTx = (networkID = utils_1.DefaultNetworkID, blockchainID, fromSigner, changeAddresses, proposalDescription, proposal = undefined, proposerAddress = undefined, proposerAuth = undefined, version = utils_1.DefaultTransactionVersionNumber, memo = undefined, fee = zero, feeAssetID = undefined, asOf = zero, stakeAmount = zero, stakeAssetID, toThreshold = 1, changeThreshold = 1) => __awaiter(this, void 0, void 0, function* () {
            let ins = [];
            let outs = [];
            let owners = [];
            if (this._feeCheck(fee, feeAssetID)) {
                const aad = new _1.AssetAmountDestination([], toThreshold, fromSigner.from, fromSigner.signer, changeAddresses, changeThreshold);
                aad.addAssetAmount(stakeAssetID, stakeAmount, fee);
                const minSpendableErr = yield this.spender.getMinimumSpendable(aad, asOf, zero, "Bond");
                if (typeof minSpendableErr === "undefined") {
                    ins = aad.getInputs();
                    outs = aad.getAllOutputs();
                    owners = aad.getOutputOwners();
                }
                else {
                    throw minSpendableErr;
                }
            }
            const baseTx = new addproposaltx_1.AddProposalTx(version, networkID, blockchainID, outs, ins, memo, proposalDescription, proposal, proposerAddress, proposerAuth);
            owners.push(new common_1.OutputOwners([proposerAddress], common_1.ZeroBN, 1));
            baseTx.setOutputOwners(owners);
            return new _1.UnsignedTx(baseTx);
        });
        /**
         * Build an unsigned [[AddVoteTx]].
         *
         * @param networkID Networkid, [[DefaultNetworkID]]
         * @param blockchainID Blockchainid, default undefined
         * @param fromSigner The addresses being used to send and verify the funds from the UTXOs {@link https://github.com/feross/buffer|Buffer}
         * @param changeAddresses The addresses that can spend the change remaining from the spent UTXOs.
         * @param proposalID The proposalID of teh proposal in Buffer
         * @param voteOptionIndex The index of vote option.
         * @param voterAddress The P-address of voter in Buffer.
         * @param voterAuth Auth for voter address
         * @param version Optional. Transaction version number, default 0.
         * @param memo Optional contains arbitrary bytes, up to 256 bytes
         * @param fee Optional. The amount of fees to burn in its smallest denomination, represented as {@link https://github.com/indutny/bn.js/|BN}
         * @param feeAssetID Optional. The assetID of the fees being burned
         * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
         * @param changeThreshold Optional. The number of signatures required to spend the funds in the resultant change UTXO
         *
         * @returns An unsigned AddVoteTx created from the passed in parameters.
         */
        this.buildAddVoteTx = (networkID = utils_1.DefaultNetworkID, blockchainID, fromSigner, changeAddresses, proposalID = undefined, voteOptionIndex = undefined, voterAddress = undefined, voterAuth = undefined, version = utils_1.DefaultTransactionVersionNumber, memo = undefined, fee = zero, feeAssetID = undefined, asOf = zero, changeThreshold = 1) => __awaiter(this, void 0, void 0, function* () {
            let ins = [];
            let outs = [];
            let owners = [];
            if (this._feeCheck(fee, feeAssetID)) {
                const aad = new _1.AssetAmountDestination([], 0, fromSigner.from, fromSigner.signer, changeAddresses, changeThreshold);
                aad.addAssetAmount(feeAssetID, zero, fee);
                const minSpendableErr = yield this.spender.getMinimumSpendable(aad, asOf, zero, "Unlocked");
                if (typeof minSpendableErr === "undefined") {
                    ins = aad.getInputs();
                    outs = aad.getAllOutputs();
                    owners = aad.getOutputOwners();
                }
                else {
                    throw minSpendableErr;
                }
            }
            const baseTx = new addvotetx_1.AddVoteTx(version, networkID, blockchainID, outs, ins, memo, proposalID, voteOptionIndex, voterAddress, voterAuth);
            owners.push(new common_1.OutputOwners([voterAddress], common_1.ZeroBN, 1));
            baseTx.setOutputOwners(owners);
            return new _1.UnsignedTx(baseTx);
        });
        this.spender = spender;
        this.caminoEnabled = caminoEnabled;
    }
    _feeCheck(fee, feeAssetID) {
        return (typeof fee !== "undefined" &&
            typeof feeAssetID !== "undefined" &&
            fee.gt(new bn_js_1.default(0)) &&
            feeAssetID instanceof buffer_1.Buffer);
    }
}
exports.Builder = Builder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVpbGRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9hcGlzL3BsYXRmb3Jtdm0vYnVpbGRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7OztHQUdHOzs7Ozs7Ozs7Ozs7Ozs7QUFFSCxrREFBc0I7QUFFdEIsb0NBQWdDO0FBQ2hDLDhEQUFvQztBQUNwQyx3QkFpQ1U7QUFDViwrRUFHZ0Q7QUFDaEQseUNBQTJEO0FBQzNELHVDQUlvQjtBQUNwQiwrQ0FNMkI7QUFFM0IsbURBQThEO0FBQzlELDJDQUF1QztBQTZCdkMsTUFBTSxJQUFJLEdBQU8sSUFBSSxlQUFFLENBQUMsQ0FBQyxDQUFDLENBQUE7QUFFMUIsTUFBYSxPQUFPO0lBSWxCLFlBQVksT0FBeUIsRUFBRSxhQUFzQjtRQUs3RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1dBcUJHO1FBQ0gsZ0JBQVcsR0FBRyxDQUNaLFNBQWlCLEVBQ2pCLFlBQW9CLEVBQ3BCLE1BQVUsRUFDVixhQUFxQixFQUNyQixXQUFxQixFQUNyQixVQUFzQixFQUN0QixrQkFBNEIsU0FBUyxFQUNyQyxNQUFVLElBQUksRUFDZCxhQUFxQixTQUFTLEVBQzlCLE9BQWUsU0FBUyxFQUN4QixPQUFXLElBQUksRUFDZixXQUFlLElBQUksRUFDbkIsY0FBc0IsQ0FBQyxFQUN2QixrQkFBMEIsQ0FBQyxFQUNOLEVBQUU7WUFDdkIsSUFBSSxXQUFXLEdBQUcsV0FBVyxDQUFDLE1BQU0sRUFBRTtnQkFDcEMsMEJBQTBCO2dCQUMxQixNQUFNLElBQUksdUJBQWMsQ0FDdEIsNEVBQTRFLENBQzdFLENBQUE7YUFDRjtZQUVELElBQUksT0FBTyxlQUFlLEtBQUssV0FBVyxFQUFFO2dCQUMxQyxlQUFlLEdBQUcsRUFBRSxDQUFBO2FBQ3JCO1lBRUQsSUFBSSxPQUFPLFVBQVUsS0FBSyxXQUFXLEVBQUU7Z0JBQ3JDLFVBQVUsR0FBRyxhQUFhLENBQUE7YUFDM0I7WUFFRCxJQUFJLE1BQU0sQ0FBQyxF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QUMsQ0FBQyxDQUFDLENBQUE7WUFDeEQsTUFBTSxDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUMsQ0FBQTtZQUM5QixPQUFPLElBQUksYUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFBO1FBQy9CLENBQUMsQ0FBQSxDQUFBO1FBdjBEQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQTtRQUN0QixJQUFJLENBQUMsYUFBYSxHQUFHLGFBQWEsQ0FBQTtJQUNwQyxDQUFDO0lBZ2tERCxTQUFTLENBQUMsR0FBTyxFQUFFLFVBQWtCO1FBQ25DLE9BQU8sQ0FDTCxPQUFPLEdBQUcsS0FBSyxXQUFXO1lBQzFCLE9BQU8sVUFBVSxLQUFLLFdBQVc7WUFDakMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLGVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNqQixVQUFVLFlBQVksZUFBTSxDQUM3QixDQUFBO0lBQ0gsQ0FBQztDQStQRjtBQTcwREQsMEJBNjBEQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKiBAbW9kdWxlIEFQSS1QbGF0Zm9ybVZNLUJ1aWxkZXJcbiAqL1xuXG5pbXBvcnQgQk4gZnJvbSBcImJuLmpzXCJcblxuaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSBcImJ1ZmZlci9cIlxuaW1wb3J0IGNyZWF0ZUhhc2ggZnJvbSBcImNyZWF0ZS1oYXNoXCJcbmltcG9ydCB7XG4gIEFkZERlbGVnYXRvclR4LFxuICBBZGRTdWJuZXRWYWxpZGF0b3JUeCxcbiAgQWRkVmFsaWRhdG9yVHgsXG4gIEFkZHJlc3NTdGF0ZVR4LFxuICBBbW91bnRPdXRwdXQsXG4gIEFzc2V0QW1vdW50RGVzdGluYXRpb24sXG4gIEJhc2VUeCxcbiAgQ2FtaW5vQWRkVmFsaWRhdG9yVHgsXG4gIENsYWltQW1vdW50LFxuICBDbGFpbUFtb3VudFBhcmFtcyxcbiAgQ2xhaW1UeCxcbiAgQ2xhaW1UeXBlLFxuICBDcmVhdGVDaGFpblR4LFxuICBDcmVhdGVTdWJuZXRUeCxcbiAgRGVwb3NpdFR4LFxuICBFeHBvcnRUeCxcbiAgSW1wb3J0VHgsXG4gIE11bHRpc2lnQWxpYXMsXG4gIE11bHRpc2lnQWxpYXNQYXJhbXMsXG4gIE11bHRpc2lnQWxpYXNUeCxcbiAgUGFyc2VhYmxlT3V0cHV0LFxuICBQbGF0Zm9ybVZNQ29uc3RhbnRzLFxuICBSZWdpc3Rlck5vZGVUeCxcbiAgU0VDUE93bmVyT3V0cHV0LFxuICBTRUNQVHJhbnNmZXJJbnB1dCxcbiAgU0VDUFRyYW5zZmVyT3V0cHV0LFxuICBTZWxlY3RPdXRwdXRDbGFzcyxcbiAgVHJhbnNmZXJhYmxlSW5wdXQsXG4gIFRyYW5zZmVyYWJsZU91dHB1dCxcbiAgVVRYTyxcbiAgVW5sb2NrRGVwb3NpdFR4LFxuICBVbnNpZ25lZFR4XG59IGZyb20gXCIuXCJcbmltcG9ydCB7XG4gIEFkZERlcG9zaXRPZmZlclR4LFxuICBPZmZlclxufSBmcm9tIFwiLi4vLi4vYXBpcy9wbGF0Zm9ybXZtL2FkZGRlcG9zaXRvZmZlcnR4XCJcbmltcG9ydCB7IE91dHB1dE93bmVycywgU2lnSWR4LCBaZXJvQk4gfSBmcm9tIFwiLi4vLi4vY29tbW9uXCJcbmltcG9ydCB7XG4gIERlZmF1bHROZXR3b3JrSUQsXG4gIERlZmF1bHRUcmFuc2FjdGlvblZlcnNpb25OdW1iZXIsXG4gIFVuaXhOb3dcbn0gZnJvbSBcIi4uLy4uL3V0aWxzXCJcbmltcG9ydCB7XG4gIEFkZHJlc3NFcnJvcixcbiAgRmVlQXNzZXRFcnJvcixcbiAgUHJvdG9jb2xFcnJvcixcbiAgVGhyZXNob2xkRXJyb3IsXG4gIFRpbWVFcnJvclxufSBmcm9tIFwiLi4vLi4vdXRpbHMvZXJyb3JzXCJcbmltcG9ydCB7IEdlbmVzaXNEYXRhIH0gZnJvbSBcIi4uL2F2bVwiXG5pbXBvcnQgeyBBZGRQcm9wb3NhbFR4LCB0eXBlIFByb3Bvc2FsIH0gZnJvbSBcIi4vYWRkcHJvcG9zYWx0eFwiXG5pbXBvcnQgeyBBZGRWb3RlVHggfSBmcm9tIFwiLi9hZGR2b3RldHhcIlxuXG5leHBvcnQgdHlwZSBMb2NrTW9kZSA9IFwiVW5sb2NrZWRcIiB8IFwiQm9uZFwiIHwgXCJEZXBvc2l0XCIgfCBcIlN0YWtlXCJcblxuZXhwb3J0IGludGVyZmFjZSBNaW5pbXVtU3BlbmRhYmxlIHtcbiAgZ2V0TWluaW11bVNwZW5kYWJsZShcbiAgICBhYWQ6IEFzc2V0QW1vdW50RGVzdGluYXRpb24sXG4gICAgYXNPZjogQk4sXG4gICAgbG9ja3RpbWU6IEJOLFxuICAgIGxvY2tNb2RlOiBMb2NrTW9kZVxuICApOiBQcm9taXNlPEVycm9yPlxufVxuXG5leHBvcnQgdHlwZSBGcm9tU2lnbmVyID0ge1xuICBmcm9tOiBCdWZmZXJbXVxuICBzaWduZXI6IEJ1ZmZlcltdXG59XG5cbmV4cG9ydCB0eXBlIE5vZGVPd25lciA9IHtcbiAgYWRkcmVzczogQnVmZmVyXG4gIGF1dGg6IFtudW1iZXIsIEJ1ZmZlcl1bXVxufVxuXG5leHBvcnQgdHlwZSBBdXRoID0ge1xuICBhZGRyZXNzZXM6IEJ1ZmZlcltdXG4gIHRocmVzaG9sZDogbnVtYmVyXG4gIHNpZ25lcjogW251bWJlciwgQnVmZmVyXVtdXG59XG5cbmNvbnN0IHplcm86IEJOID0gbmV3IEJOKDApXG5cbmV4cG9ydCBjbGFzcyBCdWlsZGVyIHtcbiAgc3BlbmRlcjogTWluaW11bVNwZW5kYWJsZVxuICBjYW1pbm9FbmFibGVkOiBib29sZWFuXG5cbiAgY29uc3RydWN0b3Ioc3BlbmRlcjogTWluaW11bVNwZW5kYWJsZSwgY2FtaW5vRW5hYmxlZDogYm9vbGVhbikge1xuICAgIHRoaXMuc3BlbmRlciA9IHNwZW5kZXJcbiAgICB0aGlzLmNhbWlub0VuYWJsZWQgPSBjYW1pbm9FbmFibGVkXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBbW1Vuc2lnbmVkVHhdXSB3cmFwcGluZyBhIFtbQmFzZVR4XV0uIEZvciBtb3JlIGdyYW51bGFyIGNvbnRyb2wsIHlvdSBtYXkgY3JlYXRlIHlvdXIgb3duXG4gICAqIFtbVW5zaWduZWRUeF1dIHdyYXBwaW5nIGEgW1tCYXNlVHhdXSBtYW51YWxseSAod2l0aCB0aGVpciBjb3JyZXNwb25kaW5nIFtbVHJhbnNmZXJhYmxlSW5wdXRdXXMgYW5kIFtbVHJhbnNmZXJhYmxlT3V0cHV0XV1zKS5cbiAgICpcbiAgICogQHBhcmFtIG5ldHdvcmtJRCBUaGUgbnVtYmVyIHJlcHJlc2VudGluZyBOZXR3b3JrSUQgb2YgdGhlIG5vZGVcbiAgICogQHBhcmFtIGJsb2NrY2hhaW5JRCBUaGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gcmVwcmVzZW50aW5nIHRoZSBCbG9ja2NoYWluSUQgZm9yIHRoZSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gYW1vdW50IFRoZSBhbW91bnQgb2YgdGhlIGFzc2V0IHRvIGJlIHNwZW50IGluIGl0cyBzbWFsbGVzdCBkZW5vbWluYXRpb24sIHJlcHJlc2VudGVkIGFzIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcy98Qk59LlxuICAgKiBAcGFyYW0gYXNzZXRJRCB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSBvZiB0aGUgYXNzZXQgSUQgZm9yIHRoZSBVVFhPXG4gICAqIEBwYXJhbSB0b0FkZHJlc3NlcyBUaGUgYWRkcmVzc2VzIHRvIHNlbmQgdGhlIGZ1bmRzXG4gICAqIEBwYXJhbSBmcm9tU2lnbmVyIFRoZSBhZGRyZXNzZXMgYmVpbmcgdXNlZCB0byBzZW5kIGFuZCB2ZXJpZnkgdGhlIGZ1bmRzIGZyb20gdGhlIFVUWE9zIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9XG4gICAqIEBwYXJhbSBjaGFuZ2VBZGRyZXNzZXMgT3B0aW9uYWwuIFRoZSBhZGRyZXNzZXMgdGhhdCBjYW4gc3BlbmQgdGhlIGNoYW5nZSByZW1haW5pbmcgZnJvbSB0aGUgc3BlbnQgVVRYT3MuIERlZmF1bHQ6IHRvQWRkcmVzc2VzXG4gICAqIEBwYXJhbSBmZWUgT3B0aW9uYWwuIFRoZSBhbW91bnQgb2YgZmVlcyB0byBidXJuIGluIGl0cyBzbWFsbGVzdCBkZW5vbWluYXRpb24sIHJlcHJlc2VudGVkIGFzIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcy98Qk59XG4gICAqIEBwYXJhbSBmZWVBc3NldElEIE9wdGlvbmFsLiBUaGUgYXNzZXRJRCBvZiB0aGUgZmVlcyBiZWluZyBidXJuZWQuIERlZmF1bHQ6IGFzc2V0SURcbiAgICogQHBhcmFtIG1lbW8gT3B0aW9uYWwuIENvbnRhaW5zIGFyYml0cmFyeSBkYXRhLCB1cCB0byAyNTYgYnl0ZXNcbiAgICogQHBhcmFtIGFzT2YgT3B0aW9uYWwuIFRoZSB0aW1lc3RhbXAgdG8gdmVyaWZ5IHRoZSB0cmFuc2FjdGlvbiBhZ2FpbnN0IGFzIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn1cbiAgICogQHBhcmFtIGxvY2t0aW1lIE9wdGlvbmFsLiBUaGUgbG9ja3RpbWUgZmllbGQgY3JlYXRlZCBpbiB0aGUgcmVzdWx0aW5nIG91dHB1dHNcbiAgICogQHBhcmFtIHRvVGhyZXNob2xkIE9wdGlvbmFsLiBUaGUgbnVtYmVyIG9mIHNpZ25hdHVyZXMgcmVxdWlyZWQgdG8gc3BlbmQgdGhlIGZ1bmRzIGluIHRoZSByZXN1bHRhbnQgVVRYT1xuICAgKiBAcGFyYW0gY2hhbmdlVGhyZXNob2xkIE9wdGlvbmFsLiBUaGUgbnVtYmVyIG9mIHNpZ25hdHVyZXMgcmVxdWlyZWQgdG8gc3BlbmQgdGhlIGZ1bmRzIGluIHRoZSByZXN1bHRhbnQgY2hhbmdlIFVUWE9cbiAgICpcbiAgICogQHJldHVybnMgQW4gdW5zaWduZWQgdHJhbnNhY3Rpb24gY3JlYXRlZCBmcm9tIHRoZSBwYXNzZWQgaW4gcGFyYW1ldGVycy5cbiAgICpcbiAgICovXG4gIGJ1aWxkQmFzZVR4ID0gYXN5bmMgKFxuICAgIG5ldHdvcmtJRDogbnVtYmVyLFxuICAgIGJsb2NrY2hhaW5JRDogQnVmZmVyLFxuICAgIGFtb3VudDogQk4sXG4gICAgYW1vdW50QXNzZXRJRDogQnVmZmVyLFxuICAgIHRvQWRkcmVzc2VzOiBCdWZmZXJbXSxcbiAgICBmcm9tU2lnbmVyOiBGcm9tU2lnbmVyLFxuICAgIGNoYW5nZUFkZHJlc3NlczogQnVmZmVyW10gPSB1bmRlZmluZWQsXG4gICAgZmVlOiBCTiA9IHplcm8sXG4gICAgZmVlQXNzZXRJRDogQnVmZmVyID0gdW5kZWZpbmVkLFxuICAgIG1lbW86IEJ1ZmZlciA9IHVuZGVmaW5lZCxcbiAgICBhc09mOiBCTiA9IHplcm8sXG4gICAgbG9ja1RpbWU6IEJOID0gemVybyxcbiAgICB0b1RocmVzaG9sZDogbnVtYmVyID0gMSxcbiAgICBjaGFuZ2VUaHJlc2hvbGQ6IG51bWJlciA9IDFcbiAgKTogUHJvbWlzZTxVbnNpZ25lZFR4PiA9PiB7XG4gICAgaWYgKHRvVGhyZXNob2xkID4gdG9BZGRyZXNzZXMubGVuZ3RoKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgdGhyb3cgbmV3IFRocmVzaG9sZEVycm9yKFxuICAgICAgICBcIkVycm9yIC0gVVRYT1NldC5idWlsZEJhc2VUeDogdGhyZXNob2xkIGlzIGdyZWF0ZXIgdGhhbiBudW1iZXIgb2YgYWRkcmVzc2VzXCJcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNoYW5nZUFkZHJlc3NlcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2hhbmdlQWRkcmVzc2VzID0gW11cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZlZUFzc2V0SUQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGZlZUFzc2V0SUQgPSBhbW91bnRBc3NldElEXG4gICAgfVxuXG4gICAgaWYgKGFtb3VudC5lcSh6ZXJvKSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGNvbnN0IGFhZDogQXNzZXRBbW91bnREZXN0aW5hdGlvbiA9IG5ldyBBc3NldEFtb3VudERlc3RpbmF0aW9uKFxuICAgICAgdG9BZGRyZXNzZXMsXG4gICAgICB0b1RocmVzaG9sZCxcbiAgICAgIGZyb21TaWduZXIuZnJvbSxcbiAgICAgIGZyb21TaWduZXIuc2lnbmVyLFxuICAgICAgY2hhbmdlQWRkcmVzc2VzLFxuICAgICAgY2hhbmdlVGhyZXNob2xkXG4gICAgKVxuICAgIGlmIChhbW91bnRBc3NldElELnRvU3RyaW5nKFwiaGV4XCIpID09PSBmZWVBc3NldElELnRvU3RyaW5nKFwiaGV4XCIpKSB7XG4gICAgICBhYWQuYWRkQXNzZXRBbW91bnQoYW1vdW50QXNzZXRJRCwgYW1vdW50LCBmZWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFhZC5hZGRBc3NldEFtb3VudChhbW91bnRBc3NldElELCBhbW91bnQsIHplcm8pXG4gICAgICBpZiAodGhpcy5fZmVlQ2hlY2soZmVlLCBmZWVBc3NldElEKSkge1xuICAgICAgICBhYWQuYWRkQXNzZXRBbW91bnQoZmVlQXNzZXRJRCwgemVybywgZmVlKVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBpbnM6IFRyYW5zZmVyYWJsZUlucHV0W10gPSBbXVxuICAgIGxldCBvdXRzOiBUcmFuc2ZlcmFibGVPdXRwdXRbXSA9IFtdXG4gICAgbGV0IG93bmVyczogT3V0cHV0T3duZXJzW10gPSBbXVxuXG4gICAgY29uc3QgbWluU3BlbmRhYmxlRXJyOiBFcnJvciA9IGF3YWl0IHRoaXMuc3BlbmRlci5nZXRNaW5pbXVtU3BlbmRhYmxlKFxuICAgICAgYWFkLFxuICAgICAgYXNPZixcbiAgICAgIGxvY2tUaW1lLFxuICAgICAgXCJVbmxvY2tlZFwiXG4gICAgKVxuICAgIGlmICh0eXBlb2YgbWluU3BlbmRhYmxlRXJyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpbnMgPSBhYWQuZ2V0SW5wdXRzKClcbiAgICAgIG91dHMgPSBhYWQuZ2V0QWxsT3V0cHV0cygpXG4gICAgICBvd25lcnMgPSBhYWQuZ2V0T3V0cHV0T3duZXJzKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbWluU3BlbmRhYmxlRXJyXG4gICAgfVxuXG4gICAgY29uc3QgYmFzZVR4OiBCYXNlVHggPSBuZXcgQmFzZVR4KG5ldHdvcmtJRCwgYmxvY2tjaGFpbklELCBvdXRzLCBpbnMsIG1lbW8pXG4gICAgYmFzZVR4LnNldE91dHB1dE93bmVycyhvd25lcnMpXG4gICAgcmV0dXJuIG5ldyBVbnNpZ25lZFR4KGJhc2VUeClcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIHVuc2lnbmVkIEltcG9ydFR4IHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gbmV0d29ya0lEIFRoZSBudW1iZXIgcmVwcmVzZW50aW5nIE5ldHdvcmtJRCBvZiB0aGUgbm9kZVxuICAgKiBAcGFyYW0gYmxvY2tjaGFpbklEIFRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSByZXByZXNlbnRpbmcgdGhlIEJsb2NrY2hhaW5JRCBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB0b0FkZHJlc3NlcyBUaGUgYWRkcmVzc2VzIHRvIHNlbmQgdGhlIGZ1bmRzXG4gICAqIEBwYXJhbSBmcm9tU2lnbmVyIFRoZSBhZGRyZXNzZXMgYmVpbmcgdXNlZCB0byBzZW5kIGFuZCB2ZXJpZnkgdGhlIGZ1bmRzIGZyb20gdGhlIFVUWE9zIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9XG4gICAqIEBwYXJhbSBjaGFuZ2VBZGRyZXNzZXMgT3B0aW9uYWwuIFRoZSBhZGRyZXNzZXMgdGhhdCBjYW4gc3BlbmQgdGhlIGNoYW5nZSByZW1haW5pbmcgZnJvbSB0aGUgc3BlbnQgVVRYT3MuIERlZmF1bHQ6IHRvQWRkcmVzc2VzXG4gICAqIEBwYXJhbSBpbXBvcnRJbnMgQW4gYXJyYXkgb2YgW1tUcmFuc2ZlcmFibGVJbnB1dF1dcyBiZWluZyBpbXBvcnRlZFxuICAgKiBAcGFyYW0gc291cmNlQ2hhaW4gQSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSBmb3IgdGhlIGNoYWluaWQgd2hlcmUgdGhlIGltcG9ydHMgYXJlIGNvbWluZyBmcm9tLlxuICAgKiBAcGFyYW0gZmVlIE9wdGlvbmFsLiBUaGUgYW1vdW50IG9mIGZlZXMgdG8gYnVybiBpbiBpdHMgc21hbGxlc3QgZGVub21pbmF0aW9uLCByZXByZXNlbnRlZCBhcyB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfS4gRmVlIHdpbGwgY29tZSBmcm9tIHRoZSBpbnB1dHMgZmlyc3QsIGlmIHRoZXkgY2FuLlxuICAgKiBAcGFyYW0gZmVlQXNzZXRJRCBPcHRpb25hbC4gVGhlIGFzc2V0SUQgb2YgdGhlIGZlZXMgYmVpbmcgYnVybmVkLlxuICAgKiBAcGFyYW0gbWVtbyBPcHRpb25hbCBjb250YWlucyBhcmJpdHJhcnkgYnl0ZXMsIHVwIHRvIDI1NiBieXRlc1xuICAgKiBAcGFyYW0gbG9ja3RpbWUgT3B0aW9uYWwuIFRoZSBsb2NrdGltZSBmaWVsZCBjcmVhdGVkIGluIHRoZSByZXN1bHRpbmcgb3V0cHV0c1xuICAgKiBAcGFyYW0gdG9UaHJlc2hvbGQgT3B0aW9uYWwuIFRoZSBudW1iZXIgb2Ygc2lnbmF0dXJlcyByZXF1aXJlZCB0byBzcGVuZCB0aGUgZnVuZHMgaW4gdGhlIHJlY2VpdmVkIFVUWE9cbiAgICogQHBhcmFtIGNoYW5nZVRocmVzaG9sZCBPcHRpb25hbC4gVGhlIG51bWJlciBvZiBzaWduYXR1cmVzIHJlcXVpcmVkIHRvIHNwZW5kIHRoZSBmdW5kcyBpbiB0aGUgcmVzdWx0YW50IGNoYW5nZSBVVFhPXG4gICAqXG4gICAqIEByZXR1cm5zIEFuIHVuc2lnbmVkIHRyYW5zYWN0aW9uIGNyZWF0ZWQgZnJvbSB0aGUgcGFzc2VkIGluIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqL1xuICBidWlsZEltcG9ydFR4ID0gYXN5bmMgKFxuICAgIG5ldHdvcmtJRDogbnVtYmVyLFxuICAgIGJsb2NrY2hhaW5JRDogQnVmZmVyLFxuICAgIHRvQWRkcmVzc2VzOiBCdWZmZXJbXSxcbiAgICBmcm9tU2lnbmVyOiBGcm9tU2lnbmVyLFxuICAgIGNoYW5nZUFkZHJlc3NlczogQnVmZmVyW10sXG4gICAgYXRvbWljczogVVRYT1tdLFxuICAgIHNvdXJjZUNoYWluOiBCdWZmZXIgPSB1bmRlZmluZWQsXG4gICAgZmVlOiBCTiA9IHplcm8sXG4gICAgZmVlQXNzZXRJRDogQnVmZmVyID0gdW5kZWZpbmVkLFxuICAgIG1lbW86IEJ1ZmZlciA9IHVuZGVmaW5lZCxcbiAgICBhc09mOiBCTiA9IHplcm8sXG4gICAgbG9ja3RpbWU6IEJOID0gemVybyxcbiAgICB0b1RocmVzaG9sZDogbnVtYmVyID0gMSxcbiAgICBjaGFuZ2VUaHJlc2hvbGQ6IG51bWJlciA9IDFcbiAgKTogUHJvbWlzZTxVbnNpZ25lZFR4PiA9PiB7XG4gICAgbGV0IGluczogVHJhbnNmZXJhYmxlSW5wdXRbXSA9IFtdXG4gICAgbGV0IG91dHM6IFRyYW5zZmVyYWJsZU91dHB1dFtdID0gW11cbiAgICBsZXQgb3duZXJzOiBPdXRwdXRPd25lcnNbXSA9IFtdXG4gICAgY29uc3QgaW1wb3J0T3duZXJzOiBPdXRwdXRPd25lcnNbXSA9IFtdXG5cbiAgICBpZiAodHlwZW9mIGZlZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgZmVlID0gemVyby5jbG9uZSgpXG4gICAgfVxuXG4gICAgY29uc3QgaW1wb3J0SW5zOiBUcmFuc2ZlcmFibGVJbnB1dFtdID0gW11cbiAgICBsZXQgZmVlcGFpZDogQk4gPSBuZXcgQk4oMClcbiAgICBsZXQgZmVlQXNzZXRTdHI6IHN0cmluZyA9IGZlZUFzc2V0SUQudG9TdHJpbmcoXCJoZXhcIilcbiAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgYXRvbWljcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdXR4bzogVVRYTyA9IGF0b21pY3NbYCR7aX1gXVxuICAgICAgY29uc3QgYXNzZXRJRDogQnVmZmVyID0gdXR4by5nZXRBc3NldElEKClcbiAgICAgIGNvbnN0IG91dHB1dDogQW1vdW50T3V0cHV0ID0gdXR4by5nZXRPdXRwdXQoKSBhcyBBbW91bnRPdXRwdXRcbiAgICAgIGxldCBhbXQ6IEJOID0gb3V0cHV0LmdldEFtb3VudCgpLmNsb25lKClcblxuICAgICAgbGV0IGluZmVlYW1vdW50ID0gYW10LmNsb25lKClcbiAgICAgIGxldCBhc3NldFN0cjogc3RyaW5nID0gYXNzZXRJRC50b1N0cmluZyhcImhleFwiKVxuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgZmVlQXNzZXRJRCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICBmZWUuZ3QoemVybykgJiZcbiAgICAgICAgZmVlcGFpZC5sdChmZWUpICYmXG4gICAgICAgIGFzc2V0U3RyID09PSBmZWVBc3NldFN0clxuICAgICAgKSB7XG4gICAgICAgIGZlZXBhaWQgPSBmZWVwYWlkLmFkZChpbmZlZWFtb3VudClcbiAgICAgICAgaWYgKGZlZXBhaWQuZ3RlKGZlZSkpIHtcbiAgICAgICAgICBpbmZlZWFtb3VudCA9IGZlZXBhaWQuc3ViKGZlZSlcbiAgICAgICAgICBmZWVwYWlkID0gZmVlLmNsb25lKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmZlZWFtb3VudCA9IHplcm8uY2xvbmUoKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHR4aWQ6IEJ1ZmZlciA9IHV0eG8uZ2V0VHhJRCgpXG4gICAgICBjb25zdCBvdXRwdXRpZHg6IEJ1ZmZlciA9IHV0eG8uZ2V0T3V0cHV0SWR4KClcbiAgICAgIGNvbnN0IGlucHV0OiBTRUNQVHJhbnNmZXJJbnB1dCA9IG5ldyBTRUNQVHJhbnNmZXJJbnB1dChhbXQpXG4gICAgICBjb25zdCB4ZmVyaW46IFRyYW5zZmVyYWJsZUlucHV0ID0gbmV3IFRyYW5zZmVyYWJsZUlucHV0KFxuICAgICAgICB0eGlkLFxuICAgICAgICBvdXRwdXRpZHgsXG4gICAgICAgIGFzc2V0SUQsXG4gICAgICAgIGlucHV0XG4gICAgICApXG4gICAgICBjb25zdCBmcm9tOiBCdWZmZXJbXSA9IG91dHB1dC5nZXRBZGRyZXNzZXMoKVxuICAgICAgY29uc3Qgc3BlbmRlcnM6IEJ1ZmZlcltdID0gb3V0cHV0LmdldFNwZW5kZXJzKGZyb20pXG4gICAgICBmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgc3BlbmRlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3QgaWR4OiBudW1iZXIgPSBvdXRwdXQuZ2V0QWRkcmVzc0lkeChzcGVuZGVyc1tgJHtqfWBdKVxuICAgICAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgdGhyb3cgbmV3IEFkZHJlc3NFcnJvcihcbiAgICAgICAgICAgIFwiRXJyb3IgLSBVVFhPU2V0LmJ1aWxkSW1wb3J0VHg6IG5vIHN1Y2ggXCIgK1xuICAgICAgICAgICAgICBgYWRkcmVzcyBpbiBvdXRwdXQ6ICR7c3BlbmRlcnNbYCR7an1gXX1gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIHhmZXJpbi5nZXRJbnB1dCgpLmFkZFNpZ25hdHVyZUlkeChpZHgsIHNwZW5kZXJzW2Ake2p9YF0pXG4gICAgICB9XG4gICAgICBpbXBvcnRPd25lcnMucHVzaChcbiAgICAgICAgbmV3IE91dHB1dE93bmVycyhcbiAgICAgICAgICBvdXRwdXQuZ2V0QWRkcmVzc2VzKCksXG4gICAgICAgICAgb3V0cHV0LmdldExvY2t0aW1lKCksXG4gICAgICAgICAgb3V0cHV0LmdldFRocmVzaG9sZCgpXG4gICAgICAgIClcbiAgICAgIClcbiAgICAgIGltcG9ydElucy5wdXNoKHhmZXJpbilcbiAgICAgIC8vYWRkIGV4dHJhIG91dHB1dHMgZm9yIGVhY2ggYW1vdW50IChjYWxjdWxhdGVkIGZyb20gdGhlIGltcG9ydGVkIGlucHV0cyksIG1pbnVzIGZlZXNcbiAgICAgIGlmIChpbmZlZWFtb3VudC5ndCh6ZXJvKSkge1xuICAgICAgICBjb25zdCBzcGVuZG91dDogQW1vdW50T3V0cHV0ID0gU2VsZWN0T3V0cHV0Q2xhc3MoXG4gICAgICAgICAgb3V0cHV0LmdldE91dHB1dElEKCksXG4gICAgICAgICAgaW5mZWVhbW91bnQsXG4gICAgICAgICAgdG9BZGRyZXNzZXMsXG4gICAgICAgICAgbG9ja3RpbWUsXG4gICAgICAgICAgdG9UaHJlc2hvbGRcbiAgICAgICAgKSBhcyBBbW91bnRPdXRwdXRcbiAgICAgICAgY29uc3QgeGZlcm91dDogVHJhbnNmZXJhYmxlT3V0cHV0ID0gbmV3IFRyYW5zZmVyYWJsZU91dHB1dChcbiAgICAgICAgICBhc3NldElELFxuICAgICAgICAgIHNwZW5kb3V0XG4gICAgICAgIClcbiAgICAgICAgb3V0cy5wdXNoKHhmZXJvdXQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZ2V0IHJlbWFpbmluZyBmZWVzIGZyb20gdGhlIHByb3ZpZGVkIGFkZHJlc3Nlc1xuICAgIGxldCBmZWVSZW1haW5pbmc6IEJOID0gZmVlLnN1YihmZWVwYWlkKVxuICAgIGlmIChmZWVSZW1haW5pbmcuZ3QoemVybykgJiYgdGhpcy5fZmVlQ2hlY2soZmVlUmVtYWluaW5nLCBmZWVBc3NldElEKSkge1xuICAgICAgY29uc3QgYWFkOiBBc3NldEFtb3VudERlc3RpbmF0aW9uID0gbmV3IEFzc2V0QW1vdW50RGVzdGluYXRpb24oXG4gICAgICAgIHRvQWRkcmVzc2VzLFxuICAgICAgICB0b1RocmVzaG9sZCxcbiAgICAgICAgZnJvbVNpZ25lci5mcm9tLFxuICAgICAgICBmcm9tU2lnbmVyLnNpZ25lcixcbiAgICAgICAgY2hhbmdlQWRkcmVzc2VzLFxuICAgICAgICBjaGFuZ2VUaHJlc2hvbGRcbiAgICAgIClcblxuICAgICAgYWFkLmFkZEFzc2V0QW1vdW50KGZlZUFzc2V0SUQsIHplcm8sIGZlZVJlbWFpbmluZylcbiAgICAgIGNvbnN0IG1pblNwZW5kYWJsZUVycjogRXJyb3IgPSBhd2FpdCB0aGlzLnNwZW5kZXIuZ2V0TWluaW11bVNwZW5kYWJsZShcbiAgICAgICAgYWFkLFxuICAgICAgICBhc09mLFxuICAgICAgICBsb2NrdGltZSxcbiAgICAgICAgXCJVbmxvY2tlZFwiXG4gICAgICApXG4gICAgICBpZiAodHlwZW9mIG1pblNwZW5kYWJsZUVyciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpbnMgPSBhYWQuZ2V0SW5wdXRzKClcbiAgICAgICAgb3V0cyA9IGFhZC5nZXRBbGxPdXRwdXRzKClcbiAgICAgICAgb3duZXJzID0gYWFkLmdldE91dHB1dE93bmVycygpXG4gICAgICAgIG93bmVycy5wdXNoKC4uLmltcG9ydE93bmVycylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG1pblNwZW5kYWJsZUVyclxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGJhc2VUeDogSW1wb3J0VHggPSBuZXcgSW1wb3J0VHgoXG4gICAgICBuZXR3b3JrSUQsXG4gICAgICBibG9ja2NoYWluSUQsXG4gICAgICBvdXRzLFxuICAgICAgaW5zLFxuICAgICAgbWVtbyxcbiAgICAgIHNvdXJjZUNoYWluLFxuICAgICAgaW1wb3J0SW5zXG4gICAgKVxuXG4gICAgYmFzZVR4LnNldE91dHB1dE93bmVycyhvd25lcnMpXG4gICAgcmV0dXJuIG5ldyBVbnNpZ25lZFR4KGJhc2VUeClcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIHVuc2lnbmVkIEV4cG9ydFR4IHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gbmV0d29ya0lEIFRoZSBudW1iZXIgcmVwcmVzZW50aW5nIE5ldHdvcmtJRCBvZiB0aGUgbm9kZVxuICAgKiBAcGFyYW0gYmxvY2tjaGFpbklEIFRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSByZXByZXNlbnRpbmcgdGhlIEJsb2NrY2hhaW5JRCBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBhbW91bnQgVGhlIGFtb3VudCBiZWluZyBleHBvcnRlZCBhcyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcy98Qk59XG4gICAqIEBwYXJhbSBhdmF4QXNzZXRJRCB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSBvZiB0aGUgYXNzZXQgSUQgZm9yIEFWQVhcbiAgICogQHBhcmFtIHRvQWRkcmVzc2VzIEFuIGFycmF5IG9mIGFkZHJlc3NlcyBhcyB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSB3aG8gcmVjaWV2ZXMgdGhlIEFWQVhcbiAgICogQHBhcmFtIGZyb21TaWduZXIgVGhlIGFkZHJlc3NlcyBiZWluZyB1c2VkIHRvIHNlbmQgYW5kIHZlcmlmeSB0aGUgZnVuZHMgZnJvbSB0aGUgVVRYT3Mge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn1cbiAgICogQHBhcmFtIGNoYW5nZUFkZHJlc3NlcyBBbiBhcnJheSBvZiBhZGRyZXNzZXMgYXMge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gd2hvIGdldHMgdGhlIGNoYW5nZSBsZWZ0b3ZlciBvZiB0aGUgQVZBWFxuICAgKiBAcGFyYW0gZGVzdGluYXRpb25DaGFpbiBPcHRpb25hbC4gQSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSBmb3IgdGhlIGNoYWluaWQgd2hlcmUgdG8gc2VuZCB0aGUgYXNzZXQuXG4gICAqIEBwYXJhbSBmZWUgT3B0aW9uYWwuIFRoZSBhbW91bnQgb2YgZmVlcyB0byBidXJuIGluIGl0cyBzbWFsbGVzdCBkZW5vbWluYXRpb24sIHJlcHJlc2VudGVkIGFzIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcy98Qk59XG4gICAqIEBwYXJhbSBmZWVBc3NldElEIE9wdGlvbmFsLiBUaGUgYXNzZXRJRCBvZiB0aGUgZmVlcyBiZWluZyBidXJuZWQuXG4gICAqIEBwYXJhbSBtZW1vIE9wdGlvbmFsIGNvbnRhaW5zIGFyYml0cmFyeSBieXRlcywgdXAgdG8gMjU2IGJ5dGVzXG4gICAqIEBwYXJhbSBhc09mIE9wdGlvbmFsLiBUaGUgdGltZXN0YW1wIHRvIHZlcmlmeSB0aGUgdHJhbnNhY3Rpb24gYWdhaW5zdCBhcyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcy98Qk59XG4gICAqIEBwYXJhbSBsb2NrdGltZSBPcHRpb25hbC4gVGhlIGxvY2t0aW1lIGZpZWxkIGNyZWF0ZWQgaW4gdGhlIHJlc3VsdGluZyBvdXRwdXRzXG4gICAqIEBwYXJhbSB0b1RocmVzaG9sZCBPcHRpb25hbC4gVGhlIG51bWJlciBvZiBzaWduYXR1cmVzIHJlcXVpcmVkIHRvIHNwZW5kIHRoZSBmdW5kcyBpbiB0aGUgcmVjZWl2ZWQgVVRYT1xuICAgKiBAcGFyYW0gY2hhbmdlVGhyZXNob2xkIE9wdGlvbmFsLiBUaGUgbnVtYmVyIG9mIHNpZ25hdHVyZXMgcmVxdWlyZWQgdG8gc3BlbmQgdGhlIGZ1bmRzIGluIHRoZSByZXN1bHRhbnQgY2hhbmdlIFVUWE9cbiAgICpcbiAgICogQHJldHVybnMgQW4gdW5zaWduZWQgdHJhbnNhY3Rpb24gY3JlYXRlZCBmcm9tIHRoZSBwYXNzZWQgaW4gcGFyYW1ldGVycy5cbiAgICpcbiAgICovXG4gIGJ1aWxkRXhwb3J0VHggPSBhc3luYyAoXG4gICAgbmV0d29ya0lEOiBudW1iZXIsXG4gICAgYmxvY2tjaGFpbklEOiBCdWZmZXIsXG4gICAgYW1vdW50OiBCTixcbiAgICBhbW91bnRBc3NldElEOiBCdWZmZXIsXG4gICAgdG9BZGRyZXNzZXM6IEJ1ZmZlcltdLFxuICAgIGZyb21TaWduZXI6IEZyb21TaWduZXIsXG4gICAgZGVzdGluYXRpb25DaGFpbjogQnVmZmVyLFxuICAgIGNoYW5nZUFkZHJlc3NlczogQnVmZmVyW10gPSB1bmRlZmluZWQsXG4gICAgZmVlOiBCTiA9IHplcm8sXG4gICAgZmVlQXNzZXRJRDogQnVmZmVyID0gdW5kZWZpbmVkLFxuICAgIG1lbW86IEJ1ZmZlciA9IHVuZGVmaW5lZCxcbiAgICBhc09mOiBCTiA9IHplcm8sXG4gICAgbG9ja3RpbWU6IEJOID0gemVybyxcbiAgICB0b1RocmVzaG9sZDogbnVtYmVyID0gMSxcbiAgICBjaGFuZ2VUaHJlc2hvbGQ6IG51bWJlciA9IDFcbiAgKTogUHJvbWlzZTxVbnNpZ25lZFR4PiA9PiB7XG4gICAgbGV0IGluczogVHJhbnNmZXJhYmxlSW5wdXRbXSA9IFtdXG4gICAgbGV0IG91dHM6IFRyYW5zZmVyYWJsZU91dHB1dFtdID0gW11cbiAgICBsZXQgb3duZXJzOiBPdXRwdXRPd25lcnNbXSA9IFtdXG5cbiAgICBpZiAodHlwZW9mIGNoYW5nZUFkZHJlc3NlcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2hhbmdlQWRkcmVzc2VzID0gdG9BZGRyZXNzZXNcbiAgICB9XG5cbiAgICBpZiAoYW1vdW50LmVxKHplcm8pKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmZWVBc3NldElEID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBmZWVBc3NldElEID0gYW1vdW50QXNzZXRJRFxuICAgIH0gZWxzZSBpZiAoZmVlQXNzZXRJRC50b1N0cmluZyhcImhleFwiKSAhPT0gYW1vdW50QXNzZXRJRC50b1N0cmluZyhcImhleFwiKSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHRocm93IG5ldyBGZWVBc3NldEVycm9yKFxuICAgICAgICBcIkVycm9yIC0gQ2FtaW5vRXhlY3V0b3IuYnVpbGRFeHBvcnRUeDogXCIgK1xuICAgICAgICAgIGBmZWVBc3NldElEIG11c3QgbWF0Y2ggYXZheEFzc2V0SURgXG4gICAgICApXG4gICAgfVxuXG4gICAgY29uc3QgYWFkOiBBc3NldEFtb3VudERlc3RpbmF0aW9uID0gbmV3IEFzc2V0QW1vdW50RGVzdGluYXRpb24oXG4gICAgICB0b0FkZHJlc3NlcyxcbiAgICAgIHRvVGhyZXNob2xkLFxuICAgICAgZnJvbVNpZ25lci5mcm9tLFxuICAgICAgZnJvbVNpZ25lci5zaWduZXIsXG4gICAgICBjaGFuZ2VBZGRyZXNzZXMsXG4gICAgICBjaGFuZ2VUaHJlc2hvbGRcbiAgICApXG5cbiAgICBsZXQgc2luZ2xlQXNzZXQgPSB0cnVlXG4gICAgaWYgKGFtb3VudEFzc2V0SUQudG9TdHJpbmcoXCJoZXhcIikgPT09IGZlZUFzc2V0SUQudG9TdHJpbmcoXCJoZXhcIikpIHtcbiAgICAgIGFhZC5hZGRBc3NldEFtb3VudChhbW91bnRBc3NldElELCB6ZXJvLCBmZWUuYWRkKGFtb3VudCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHNpbmdsZUFzc2V0ID0gZmFsc2VcbiAgICAgIGFhZC5hZGRBc3NldEFtb3VudChhbW91bnRBc3NldElELCBhbW91bnQsIHplcm8pXG4gICAgICBpZiAodGhpcy5fZmVlQ2hlY2soZmVlLCBmZWVBc3NldElEKSkge1xuICAgICAgICBhYWQuYWRkQXNzZXRBbW91bnQoZmVlQXNzZXRJRCwgemVybywgZmVlKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG1pblNwZW5kYWJsZUVycjogRXJyb3IgPSBhd2FpdCB0aGlzLnNwZW5kZXIuZ2V0TWluaW11bVNwZW5kYWJsZShcbiAgICAgIGFhZCxcbiAgICAgIGFzT2YsXG4gICAgICBsb2NrdGltZSxcbiAgICAgIFwiVW5sb2NrZWRcIlxuICAgIClcbiAgICBpZiAodHlwZW9mIG1pblNwZW5kYWJsZUVyciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaW5zID0gYWFkLmdldElucHV0cygpXG4gICAgICBvdXRzID0gc2luZ2xlQXNzZXQgPyBhYWQuZ2V0QWxsT3V0cHV0cygpIDogYWFkLmdldENoYW5nZU91dHB1dHMoKVxuICAgICAgZXhwb3J0cyA9IHNpbmdsZUFzc2V0ID8gW10gOiBhYWQuZ2V0T3V0cHV0cygpXG4gICAgICBvd25lcnMgPSBhYWQuZ2V0T3V0cHV0T3duZXJzKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbWluU3BlbmRhYmxlRXJyXG4gICAgfVxuXG4gICAgY29uc3QgYmFzZVR4OiBFeHBvcnRUeCA9IG5ldyBFeHBvcnRUeChcbiAgICAgIG5ldHdvcmtJRCxcbiAgICAgIGJsb2NrY2hhaW5JRCxcbiAgICAgIG91dHMsXG4gICAgICBpbnMsXG4gICAgICBtZW1vLFxuICAgICAgZGVzdGluYXRpb25DaGFpbixcbiAgICAgIGV4cG9ydHMubGVuZ3RoID4gMFxuICAgICAgICA/IGV4cG9ydHNcbiAgICAgICAgOiBbXG4gICAgICAgICAgICBuZXcgU0VDUFRyYW5zZmVyT3V0cHV0KFxuICAgICAgICAgICAgICBhbW91bnQsXG4gICAgICAgICAgICAgIHRvQWRkcmVzc2VzLFxuICAgICAgICAgICAgICBsb2NrdGltZSxcbiAgICAgICAgICAgICAgdG9UaHJlc2hvbGRcbiAgICAgICAgICAgICkubWFrZVRyYW5zZmVyYWJsZShhbW91bnRBc3NldElEKVxuICAgICAgICAgIF1cbiAgICApXG5cbiAgICBiYXNlVHguc2V0T3V0cHV0T3duZXJzKG93bmVycylcbiAgICByZXR1cm4gbmV3IFVuc2lnbmVkVHgoYmFzZVR4KVxuICB9XG5cbiAgLyoqXG4gICAqIENsYXNzIHJlcHJlc2VudGluZyBhbiB1bnNpZ25lZCBbW0FkZFN1Ym5ldFZhbGlkYXRvclR4XV0gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSBuZXR3b3JrSUQgTmV0d29ya2lkLCBbW0RlZmF1bHROZXR3b3JrSURdXVxuICAgKiBAcGFyYW0gYmxvY2tjaGFpbklEIEJsb2NrY2hhaW5pZCwgZGVmYXVsdCB1bmRlZmluZWRcbiAgICogQHBhcmFtIGZyb21TaWduZXIgVGhlIGFkZHJlc3NlcyBiZWluZyB1c2VkIHRvIHNlbmQgYW5kIHZlcmlmeSB0aGUgZnVuZHMgZnJvbSB0aGUgVVRYT3Mge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn1cbiAgICogQHBhcmFtIGNoYW5nZUFkZHJlc3NlcyBBbiBhcnJheSBvZiBhZGRyZXNzZXMgYXMge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gd2hvIGdldHMgdGhlIGNoYW5nZSBsZWZ0b3ZlciBmcm9tIHRoZSBmZWUgcGF5bWVudFxuICAgKiBAcGFyYW0gbm9kZUlEIFRoZSBub2RlIElEIG9mIHRoZSB2YWxpZGF0b3IgYmVpbmcgYWRkZWQuXG4gICAqIEBwYXJhbSBzdGFydFRpbWUgVGhlIFVuaXggdGltZSB3aGVuIHRoZSB2YWxpZGF0b3Igc3RhcnRzIHZhbGlkYXRpbmcgdGhlIFByaW1hcnkgTmV0d29yay5cbiAgICogQHBhcmFtIGVuZFRpbWUgVGhlIFVuaXggdGltZSB3aGVuIHRoZSB2YWxpZGF0b3Igc3RvcHMgdmFsaWRhdGluZyB0aGUgUHJpbWFyeSBOZXR3b3JrIChhbmQgc3Rha2VkIEFWQVggaXMgcmV0dXJuZWQpLlxuICAgKiBAcGFyYW0gd2VpZ2h0IFRoZSBhbW91bnQgb2Ygd2VpZ2h0IGZvciB0aGlzIHN1Ym5ldCB2YWxpZGF0b3IuXG4gICAqIEBwYXJhbSBmZWUgT3B0aW9uYWwuIFRoZSBhbW91bnQgb2YgZmVlcyB0byBidXJuIGluIGl0cyBzbWFsbGVzdCBkZW5vbWluYXRpb24sIHJlcHJlc2VudGVkIGFzIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcy98Qk59XG4gICAqIEBwYXJhbSBmZWVBc3NldElEIE9wdGlvbmFsLiBUaGUgYXNzZXRJRCBvZiB0aGUgZmVlcyBiZWluZyBidXJuZWQuXG4gICAqIEBwYXJhbSBtZW1vIE9wdGlvbmFsIGNvbnRhaW5zIGFyYml0cmFyeSBieXRlcywgdXAgdG8gMjU2IGJ5dGVzXG4gICAqIEBwYXJhbSBhc09mIE9wdGlvbmFsLiBUaGUgdGltZXN0YW1wIHRvIHZlcmlmeSB0aGUgdHJhbnNhY3Rpb24gYWdhaW5zdCBhcyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcy98Qk59XG4gICAqIEBwYXJhbSBzdWJuZXRBdXRoIE9wdGlvbmFsLiBBbiBBdXRoIHN0cnVjdCB3aGljaCBjb250YWlucyB0aGUgc3VibmV0IEF1dGggYW5kIHRoZSBzaWduZXJzLlxuICAgKiBAcGFyYW0gY2hhbmdlVGhyZXNob2xkIE9wdGlvbmFsLiBUaGUgbnVtYmVyIG9mIHNpZ25hdHVyZXMgcmVxdWlyZWQgdG8gc3BlbmQgdGhlIGZ1bmRzIGluIHRoZSByZXN1bHRhbnQgY2hhbmdlIFVUWE9cbiAgICpcbiAgICogQHJldHVybnMgQW4gdW5zaWduZWQgdHJhbnNhY3Rpb24gY3JlYXRlZCBmcm9tIHRoZSBwYXNzZWQgaW4gcGFyYW1ldGVycy5cbiAgICovXG4gIGJ1aWxkQWRkU3VibmV0VmFsaWRhdG9yVHggPSBhc3luYyAoXG4gICAgbmV0d29ya0lEOiBudW1iZXIgPSBEZWZhdWx0TmV0d29ya0lELFxuICAgIGJsb2NrY2hhaW5JRDogQnVmZmVyLFxuICAgIGZyb21TaWduZXI6IEZyb21TaWduZXIsXG4gICAgY2hhbmdlQWRkcmVzc2VzOiBCdWZmZXJbXSxcbiAgICBub2RlSUQ6IEJ1ZmZlcixcbiAgICBzdGFydFRpbWU6IEJOLFxuICAgIGVuZFRpbWU6IEJOLFxuICAgIHdlaWdodDogQk4sXG4gICAgc3VibmV0SUQ6IHN0cmluZyxcbiAgICBmZWU6IEJOID0gemVybyxcbiAgICBmZWVBc3NldElEOiBCdWZmZXIgPSB1bmRlZmluZWQsXG4gICAgbWVtbzogQnVmZmVyID0gdW5kZWZpbmVkLFxuICAgIGFzT2Y6IEJOID0gemVybyxcbiAgICBzdWJuZXRBdXRoOiBBdXRoID0geyBhZGRyZXNzZXM6IFtdLCB0aHJlc2hvbGQ6IDAsIHNpZ25lcjogW10gfSxcbiAgICBjaGFuZ2VUaHJlc2hvbGQ6IG51bWJlciA9IDFcbiAgKTogUHJvbWlzZTxVbnNpZ25lZFR4PiA9PiB7XG4gICAgbGV0IGluczogVHJhbnNmZXJhYmxlSW5wdXRbXSA9IFtdXG4gICAgbGV0IG91dHM6IFRyYW5zZmVyYWJsZU91dHB1dFtdID0gW11cbiAgICBsZXQgb3duZXJzOiBPdXRwdXRPd25lcnNbXSA9IFtdXG5cbiAgICBjb25zdCBub3c6IEJOID0gVW5peE5vdygpXG4gICAgaWYgKHN0YXJ0VGltZS5sdChub3cpIHx8IGVuZFRpbWUubHRlKHN0YXJ0VGltZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJDYW1pbm9FeGVjdXRvci5idWlsZEFkZFN1Ym5ldFZhbGlkYXRvclR4IC0tIHN0YXJ0VGltZSBtdXN0IGJlIGluIHRoZSBmdXR1cmUgYW5kIGVuZFRpbWUgbXVzdCBjb21lIGFmdGVyIHN0YXJ0VGltZVwiXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2ZlZUNoZWNrKGZlZSwgZmVlQXNzZXRJRCkpIHtcbiAgICAgIGNvbnN0IGFhZDogQXNzZXRBbW91bnREZXN0aW5hdGlvbiA9IG5ldyBBc3NldEFtb3VudERlc3RpbmF0aW9uKFxuICAgICAgICBbXSxcbiAgICAgICAgMCxcbiAgICAgICAgZnJvbVNpZ25lci5mcm9tLFxuICAgICAgICBmcm9tU2lnbmVyLnNpZ25lcixcbiAgICAgICAgY2hhbmdlQWRkcmVzc2VzLFxuICAgICAgICBjaGFuZ2VUaHJlc2hvbGRcbiAgICAgIClcblxuICAgICAgYWFkLmFkZEFzc2V0QW1vdW50KGZlZUFzc2V0SUQsIHplcm8sIGZlZSlcbiAgICAgIGNvbnN0IG1pblNwZW5kYWJsZUVycjogRXJyb3IgPSBhd2FpdCB0aGlzLnNwZW5kZXIuZ2V0TWluaW11bVNwZW5kYWJsZShcbiAgICAgICAgYWFkLFxuICAgICAgICBhc09mLFxuICAgICAgICB6ZXJvLFxuICAgICAgICB0aGlzLmNhbWlub0VuYWJsZWQgPyBcIlVubG9ja2VkXCIgOiBcIlN0YWtlXCJcbiAgICAgIClcbiAgICAgIGlmICh0eXBlb2YgbWluU3BlbmRhYmxlRXJyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlucyA9IGFhZC5nZXRJbnB1dHMoKVxuICAgICAgICBvdXRzID0gYWFkLmdldEFsbE91dHB1dHMoKVxuICAgICAgICBvd25lcnMgPSBhYWQuZ2V0T3V0cHV0T3duZXJzKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG1pblNwZW5kYWJsZUVyclxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGJhc2VUeDogQWRkU3VibmV0VmFsaWRhdG9yVHggPSBuZXcgQWRkU3VibmV0VmFsaWRhdG9yVHgoXG4gICAgICBuZXR3b3JrSUQsXG4gICAgICBibG9ja2NoYWluSUQsXG4gICAgICBvdXRzLFxuICAgICAgaW5zLFxuICAgICAgbWVtbyxcbiAgICAgIG5vZGVJRCxcbiAgICAgIHN0YXJ0VGltZSxcbiAgICAgIGVuZFRpbWUsXG4gICAgICB3ZWlnaHQsXG4gICAgICBzdWJuZXRJRFxuICAgIClcbiAgICBzdWJuZXRBdXRoLnNpZ25lci5mb3JFYWNoKChzdWJuZXRTaWduZXIpOiB2b2lkID0+IHtcbiAgICAgIGJhc2VUeC5hZGRTaWduYXR1cmVJZHgoc3VibmV0U2lnbmVyWzBdLCBzdWJuZXRTaWduZXJbMV0pXG4gICAgfSlcblxuICAgIC8vIFdlIG5lZWQgdG8gZmV0Y2ggdGhlIEFVVEggZm9yIGxhdGVyIG1zaWcgdmVyaWZpY2F0aW9uXG4gICAgLy8gRm9yIG5vdyB3ZSB1c2Ugc2ltcGx5IHdoYXQgd2UgZ2V0IGluIHN1Ym5ldEF1dGhcbiAgICBvd25lcnMucHVzaChcbiAgICAgIG5ldyBPdXRwdXRPd25lcnMoc3VibmV0QXV0aC5hZGRyZXNzZXMsIFplcm9CTiwgc3VibmV0QXV0aC50aHJlc2hvbGQpXG4gICAgKVxuXG4gICAgaWYgKHRoaXMuY2FtaW5vRW5hYmxlZCkge1xuICAgICAgYmFzZVR4LmluY2x1ZGVOb2RlU2lnbmF0dXJlKClcbiAgICAgIG93bmVycy5wdXNoKG5ldyBPdXRwdXRPd25lcnMoW25vZGVJRF0sIFplcm9CTiwgMSkpXG4gICAgfVxuICAgIGJhc2VUeC5zZXRPdXRwdXRPd25lcnMob3duZXJzKVxuICAgIHJldHVybiBuZXcgVW5zaWduZWRUeChiYXNlVHgpXG4gIH1cblxuICAvKipcbiAgICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIHVuc2lnbmVkIFtbQWRkRGVsZWdhdG9yVHhdXSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIG5ldHdvcmtJRCBOZXR3b3JraWQsIFtbRGVmYXVsdE5ldHdvcmtJRF1dXG4gICAqIEBwYXJhbSBibG9ja2NoYWluSUQgQmxvY2tjaGFpbmlkLCBkZWZhdWx0IHVuZGVmaW5lZFxuICAgKiBAcGFyYW0gYXZheEFzc2V0SUQge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gb2YgdGhlIGFzc2V0IElEIGZvciBBVkFYXG4gICAqIEBwYXJhbSB0b0FkZHJlc3NlcyBBbiBhcnJheSBvZiBhZGRyZXNzZXMgYXMge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gcmVjaWV2ZXMgdGhlIHN0YWtlIGF0IHRoZSBlbmQgb2YgdGhlIHN0YWtpbmcgcGVyaW9kXG4gICAqIEBwYXJhbSBmcm9tU2lnbmVyIFRoZSBhZGRyZXNzZXMgYmVpbmcgdXNlZCB0byBzZW5kIGFuZCB2ZXJpZnkgdGhlIGZ1bmRzIGZyb20gdGhlIFVUWE9zIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9XG4gICAqIEBwYXJhbSBjaGFuZ2VBZGRyZXNzZXMgQW4gYXJyYXkgb2YgYWRkcmVzc2VzIGFzIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IHdobyBnZXRzIHRoZSBjaGFuZ2UgbGVmdG92ZXIgZnJvbSB0aGUgc3Rha2luZyBwYXltZW50XG4gICAqIEBwYXJhbSBub2RlSUQgVGhlIG5vZGUgSUQgb2YgdGhlIHZhbGlkYXRvciBiZWluZyBhZGRlZC5cbiAgICogQHBhcmFtIHN0YXJ0VGltZSBUaGUgVW5peCB0aW1lIHdoZW4gdGhlIHZhbGlkYXRvciBzdGFydHMgdmFsaWRhdGluZyB0aGUgUHJpbWFyeSBOZXR3b3JrLlxuICAgKiBAcGFyYW0gZW5kVGltZSBUaGUgVW5peCB0aW1lIHdoZW4gdGhlIHZhbGlkYXRvciBzdG9wcyB2YWxpZGF0aW5nIHRoZSBQcmltYXJ5IE5ldHdvcmsgKGFuZCBzdGFrZWQgQVZBWCBpcyByZXR1cm5lZCkuXG4gICAqIEBwYXJhbSBzdGFrZUFtb3VudCBBIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcy98Qk59IGZvciB0aGUgYW1vdW50IG9mIHN0YWtlIHRvIGJlIGRlbGVnYXRlZCBpbiBuQVZBWC5cbiAgICogQHBhcmFtIHJld2FyZExvY2t0aW1lIFRoZSBsb2NrdGltZSBmaWVsZCBjcmVhdGVkIGluIHRoZSByZXN1bHRpbmcgcmV3YXJkIG91dHB1dHNcbiAgICogQHBhcmFtIHJld2FyZFRocmVzaG9sZCBUaGUgbnVtYmVyIG9mIHNpZ25hdHVyZXMgcmVxdWlyZWQgdG8gc3BlbmQgdGhlIGZ1bmRzIGluIHRoZSByZXN1bHRhbnQgcmV3YXJkIFVUWE9cbiAgICogQHBhcmFtIHJld2FyZEFkZHJlc3NlcyBUaGUgYWRkcmVzc2VzIHRoZSB2YWxpZGF0b3IgcmV3YXJkIGdvZXMuXG4gICAqIEBwYXJhbSBmZWUgT3B0aW9uYWwuIFRoZSBhbW91bnQgb2YgZmVlcyB0byBidXJuIGluIGl0cyBzbWFsbGVzdCBkZW5vbWluYXRpb24sIHJlcHJlc2VudGVkIGFzIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcy98Qk59XG4gICAqIEBwYXJhbSBmZWVBc3NldElEIE9wdGlvbmFsLiBUaGUgYXNzZXRJRCBvZiB0aGUgZmVlcyBiZWluZyBidXJuZWQuXG4gICAqIEBwYXJhbSBtZW1vIE9wdGlvbmFsIGNvbnRhaW5zIGFyYml0cmFyeSBieXRlcywgdXAgdG8gMjU2IGJ5dGVzXG4gICAqIEBwYXJhbSBhc09mIE9wdGlvbmFsLiBUaGUgdGltZXN0YW1wIHRvIHZlcmlmeSB0aGUgdHJhbnNhY3Rpb24gYWdhaW5zdCBhcyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcy98Qk59XG4gICAqIEBwYXJhbSB0b1RocmVzaG9sZCBPcHRpb25hbC4gVGhlIG51bWJlciBvZiBzaWduYXR1cmVzIHJlcXVpcmVkIHRvIHNwZW5kIHRoZSBmdW5kcyBpbiB0aGUgc3Rha2UgVVRYT1xuICAgKiBAcGFyYW0gY2hhbmdlVGhyZXNob2xkIE9wdGlvbmFsLiBUaGUgbnVtYmVyIG9mIHNpZ25hdHVyZXMgcmVxdWlyZWQgdG8gc3BlbmQgdGhlIGZ1bmRzIGluIHRoZSBjaGFuZ2UgVVRYT1xuICAgKlxuICAgKiBAcmV0dXJucyBBbiB1bnNpZ25lZCB0cmFuc2FjdGlvbiBjcmVhdGVkIGZyb20gdGhlIHBhc3NlZCBpbiBwYXJhbWV0ZXJzLlxuICAgKi9cbiAgYnVpbGRBZGREZWxlZ2F0b3JUeCA9IGFzeW5jIChcbiAgICBuZXR3b3JrSUQ6IG51bWJlciA9IERlZmF1bHROZXR3b3JrSUQsXG4gICAgYmxvY2tjaGFpbklEOiBCdWZmZXIsXG4gICAgYXZheEFzc2V0SUQ6IEJ1ZmZlcixcbiAgICB0b0FkZHJlc3NlczogQnVmZmVyW10sXG4gICAgZnJvbVNpZ25lcjogRnJvbVNpZ25lcixcbiAgICBjaGFuZ2VBZGRyZXNzZXM6IEJ1ZmZlcltdLFxuICAgIG5vZGVJRDogQnVmZmVyLFxuICAgIHN0YXJ0VGltZTogQk4sXG4gICAgZW5kVGltZTogQk4sXG4gICAgc3Rha2VBbW91bnQ6IEJOLFxuICAgIHJld2FyZExvY2t0aW1lOiBCTixcbiAgICByZXdhcmRUaHJlc2hvbGQ6IG51bWJlcixcbiAgICByZXdhcmRBZGRyZXNzZXM6IEJ1ZmZlcltdLFxuICAgIGZlZTogQk4gPSB6ZXJvLFxuICAgIGZlZUFzc2V0SUQ6IEJ1ZmZlciA9IHVuZGVmaW5lZCxcbiAgICBtZW1vOiBCdWZmZXIgPSB1bmRlZmluZWQsXG4gICAgYXNPZjogQk4gPSB6ZXJvLFxuICAgIHRvVGhyZXNob2xkOiBudW1iZXIgPSAxLFxuICAgIGNoYW5nZVRocmVzaG9sZDogbnVtYmVyID0gMVxuICApOiBQcm9taXNlPFVuc2lnbmVkVHg+ID0+IHtcbiAgICBpZiAodGhpcy5jYW1pbm9FbmFibGVkKSB7XG4gICAgICB0aHJvdyBuZXcgUHJvdG9jb2xFcnJvcihcbiAgICAgICAgXCJidWlsZEFkZERlbGVnYXRvclR4IC0gTm90IHN1cHBvcnRlZCBpbiBDYW1pbm8gbW9kZVwiXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKHJld2FyZFRocmVzaG9sZCA+IHJld2FyZEFkZHJlc3Nlcy5sZW5ndGgpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICB0aHJvdyBuZXcgVGhyZXNob2xkRXJyb3IoXG4gICAgICAgIFwiRXJyb3IgLSBVVFhPU2V0LmJ1aWxkQWRkRGVsZWdhdG9yVHg6IHJld2FyZCB0aHJlc2hvbGQgaXMgZ3JlYXRlciB0aGFuIG51bWJlciBvZiBhZGRyZXNzZXNcIlxuICAgICAgKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2hhbmdlQWRkcmVzc2VzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjaGFuZ2VBZGRyZXNzZXMgPSB0b0FkZHJlc3Nlc1xuICAgIH1cblxuICAgIGxldCBpbnM6IFRyYW5zZmVyYWJsZUlucHV0W10gPSBbXVxuICAgIGxldCBvdXRzOiBUcmFuc2ZlcmFibGVPdXRwdXRbXSA9IFtdXG4gICAgbGV0IHN0YWtlT3V0czogVHJhbnNmZXJhYmxlT3V0cHV0W10gPSBbXVxuICAgIGxldCBvd25lcnM6IE91dHB1dE93bmVyc1tdID0gW11cblxuICAgIGNvbnN0IG5vdzogQk4gPSBVbml4Tm93KClcbiAgICBpZiAoc3RhcnRUaW1lLmx0KG5vdykgfHwgZW5kVGltZS5sdGUoc3RhcnRUaW1lKSkge1xuICAgICAgdGhyb3cgbmV3IFRpbWVFcnJvcihcbiAgICAgICAgXCJVVFhPU2V0LmJ1aWxkQWRkRGVsZWdhdG9yVHggLS0gc3RhcnRUaW1lIG11c3QgYmUgaW4gdGhlIGZ1dHVyZSBhbmQgZW5kVGltZSBtdXN0IGNvbWUgYWZ0ZXIgc3RhcnRUaW1lXCJcbiAgICAgIClcbiAgICB9XG5cbiAgICBjb25zdCBhYWQ6IEFzc2V0QW1vdW50RGVzdGluYXRpb24gPSBuZXcgQXNzZXRBbW91bnREZXN0aW5hdGlvbihcbiAgICAgIHRvQWRkcmVzc2VzLFxuICAgICAgdG9UaHJlc2hvbGQsXG4gICAgICBmcm9tU2lnbmVyLmZyb20sXG4gICAgICBmcm9tU2lnbmVyLnNpZ25lcixcbiAgICAgIGNoYW5nZUFkZHJlc3NlcyxcbiAgICAgIGNoYW5nZVRocmVzaG9sZFxuICAgIClcbiAgICBpZiAoYXZheEFzc2V0SUQudG9TdHJpbmcoXCJoZXhcIikgPT09IGZlZUFzc2V0SUQudG9TdHJpbmcoXCJoZXhcIikpIHtcbiAgICAgIGFhZC5hZGRBc3NldEFtb3VudChhdmF4QXNzZXRJRCwgc3Rha2VBbW91bnQsIGZlZSlcbiAgICB9IGVsc2Uge1xuICAgICAgYWFkLmFkZEFzc2V0QW1vdW50KGF2YXhBc3NldElELCBzdGFrZUFtb3VudCwgemVybylcbiAgICAgIGlmICh0aGlzLl9mZWVDaGVjayhmZWUsIGZlZUFzc2V0SUQpKSB7XG4gICAgICAgIGFhZC5hZGRBc3NldEFtb3VudChmZWVBc3NldElELCB6ZXJvLCBmZWUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbWluU3BlbmRhYmxlRXJyOiBFcnJvciA9IGF3YWl0IHRoaXMuc3BlbmRlci5nZXRNaW5pbXVtU3BlbmRhYmxlKFxuICAgICAgYWFkLFxuICAgICAgYXNPZixcbiAgICAgIHplcm8sXG4gICAgICBcIlN0YWtlXCJcbiAgICApXG4gICAgaWYgKHR5cGVvZiBtaW5TcGVuZGFibGVFcnIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlucyA9IGFhZC5nZXRJbnB1dHMoKVxuICAgICAgb3V0cyA9IGFhZC5nZXRDaGFuZ2VPdXRwdXRzKClcbiAgICAgIHN0YWtlT3V0cyA9IGFhZC5nZXRPdXRwdXRzKClcbiAgICAgIG93bmVycyA9IGFhZC5nZXRPdXRwdXRPd25lcnMoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBtaW5TcGVuZGFibGVFcnJcbiAgICB9XG5cbiAgICBjb25zdCByZXdhcmRPdXRwdXRPd25lcnM6IFNFQ1BPd25lck91dHB1dCA9IG5ldyBTRUNQT3duZXJPdXRwdXQoXG4gICAgICByZXdhcmRBZGRyZXNzZXMsXG4gICAgICByZXdhcmRMb2NrdGltZSxcbiAgICAgIHJld2FyZFRocmVzaG9sZFxuICAgIClcblxuICAgIGNvbnN0IGJhc2VUeDogQWRkRGVsZWdhdG9yVHggPSBuZXcgQWRkRGVsZWdhdG9yVHgoXG4gICAgICBuZXR3b3JrSUQsXG4gICAgICBibG9ja2NoYWluSUQsXG4gICAgICBvdXRzLFxuICAgICAgaW5zLFxuICAgICAgbWVtbyxcbiAgICAgIG5vZGVJRCxcbiAgICAgIHN0YXJ0VGltZSxcbiAgICAgIGVuZFRpbWUsXG4gICAgICBzdGFrZUFtb3VudCxcbiAgICAgIHN0YWtlT3V0cyxcbiAgICAgIG5ldyBQYXJzZWFibGVPdXRwdXQocmV3YXJkT3V0cHV0T3duZXJzKVxuICAgIClcbiAgICBiYXNlVHguc2V0T3V0cHV0T3duZXJzKG93bmVycylcbiAgICByZXR1cm4gbmV3IFVuc2lnbmVkVHgoYmFzZVR4KVxuICB9XG5cbiAgLyoqXG4gICAqIENsYXNzIHJlcHJlc2VudGluZyBhbiB1bnNpZ25lZCBbW0FkZFZhbGlkYXRvclR4XV0gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSBuZXR3b3JrSUQgTmV0d29ya0lELCBbW0RlZmF1bHROZXR3b3JrSURdXVxuICAgKiBAcGFyYW0gYmxvY2tjaGFpbklEIEJsb2NrY2hhaW5JRCwgZGVmYXVsdCB1bmRlZmluZWRcbiAgICogQHBhcmFtIGF2YXhBc3NldElEIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IG9mIHRoZSBhc3NldCBJRCBmb3IgQVZBWFxuICAgKiBAcGFyYW0gdG9BZGRyZXNzZXMgQW4gYXJyYXkgb2YgYWRkcmVzc2VzIGFzIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IHJlY2lldmVzIHRoZSBzdGFrZSBhdCB0aGUgZW5kIG9mIHRoZSBzdGFraW5nIHBlcmlvZFxuICAgKiBAcGFyYW0gZnJvbVNpZ25lciBUaGUgYWRkcmVzc2VzIGJlaW5nIHVzZWQgdG8gc2VuZCBhbmQgdmVyaWZ5IHRoZSBmdW5kcyBmcm9tIHRoZSBVVFhPcyB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfVxuICAgKiBAcGFyYW0gY2hhbmdlQWRkcmVzc2VzIEFuIGFycmF5IG9mIGFkZHJlc3NlcyBhcyB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSB3aG8gZ2V0cyB0aGUgY2hhbmdlIGxlZnRvdmVyIGZyb20gdGhlIHN0YWtpbmcgcGF5bWVudFxuICAgKiBAcGFyYW0gbm9kZUlEIFRoZSBub2RlIElEIG9mIHRoZSB2YWxpZGF0b3IgYmVpbmcgYWRkZWQuXG4gICAqIEBwYXJhbSBzdGFydFRpbWUgVGhlIFVuaXggdGltZSB3aGVuIHRoZSB2YWxpZGF0b3Igc3RhcnRzIHZhbGlkYXRpbmcgdGhlIFByaW1hcnkgTmV0d29yay5cbiAgICogQHBhcmFtIGVuZFRpbWUgVGhlIFVuaXggdGltZSB3aGVuIHRoZSB2YWxpZGF0b3Igc3RvcHMgdmFsaWRhdGluZyB0aGUgUHJpbWFyeSBOZXR3b3JrIChhbmQgc3Rha2VkIEFWQVggaXMgcmV0dXJuZWQpLlxuICAgKiBAcGFyYW0gc3Rha2VBbW91bnQgQSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfSBmb3IgdGhlIGFtb3VudCBvZiBzdGFrZSB0byBiZSBkZWxlZ2F0ZWQgaW4gbkFWQVguXG4gICAqIEBwYXJhbSByZXdhcmRMb2NrdGltZSBUaGUgbG9ja3RpbWUgZmllbGQgY3JlYXRlZCBpbiB0aGUgcmVzdWx0aW5nIHJld2FyZCBvdXRwdXRzXG4gICAqIEBwYXJhbSByZXdhcmRUaHJlc2hvbGQgVGhlIG51bWJlciBvZiBzaWduYXR1cmVzIHJlcXVpcmVkIHRvIHNwZW5kIHRoZSBmdW5kcyBpbiB0aGUgcmVzdWx0YW50IHJld2FyZCBVVFhPXG4gICAqIEBwYXJhbSByZXdhcmRBZGRyZXNzZXMgVGhlIGFkZHJlc3NlcyB0aGUgdmFsaWRhdG9yIHJld2FyZCBnb2VzLlxuICAgKiBAcGFyYW0gZGVsZWdhdGlvbkZlZSBBIG51bWJlciBmb3IgdGhlIHBlcmNlbnRhZ2Ugb2YgcmV3YXJkIHRvIGJlIGdpdmVuIHRvIHRoZSB2YWxpZGF0b3Igd2hlbiBzb21lb25lIGRlbGVnYXRlcyB0byB0aGVtLiBNdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLlxuICAgKiBAcGFyYW0gbWluU3Rha2UgQSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfSByZXByZXNlbnRpbmcgdGhlIG1pbmltdW0gc3Rha2UgcmVxdWlyZWQgdG8gdmFsaWRhdGUgb24gdGhpcyBuZXR3b3JrLlxuICAgKiBAcGFyYW0gZmVlIE9wdGlvbmFsLiBUaGUgYW1vdW50IG9mIGZlZXMgdG8gYnVybiBpbiBpdHMgc21hbGxlc3QgZGVub21pbmF0aW9uLCByZXByZXNlbnRlZCBhcyB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfVxuICAgKiBAcGFyYW0gZmVlQXNzZXRJRCBPcHRpb25hbC4gVGhlIGFzc2V0SUQgb2YgdGhlIGZlZXMgYmVpbmcgYnVybmVkLlxuICAgKiBAcGFyYW0gbWVtbyBPcHRpb25hbCBjb250YWlucyBhcmJpdHJhcnkgYnl0ZXMsIHVwIHRvIDI1NiBieXRlc1xuICAgKiBAcGFyYW0gYXNPZiBPcHRpb25hbC4gVGhlIHRpbWVzdGFtcCB0byB2ZXJpZnkgdGhlIHRyYW5zYWN0aW9uIGFnYWluc3QgYXMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfVxuICAgKiBAcGFyYW0gdG9UaHJlc2hvbGQgT3B0aW9uYWwuIFRoZSBudW1iZXIgb2Ygc2lnbmF0dXJlcyByZXF1aXJlZCB0byBzcGVuZCB0aGUgZnVuZHMgaW4gdGhlIHN0YWtlIFVUWE9cbiAgICogQHBhcmFtIGNoYW5nZVRocmVzaG9sZCBPcHRpb25hbC4gVGhlIG51bWJlciBvZiBzaWduYXR1cmVzIHJlcXVpcmVkIHRvIHNwZW5kIHRoZSBmdW5kcyBpbiB0aGUgY2hhbmdlIFVUWE9cbiAgICovXG4gIGJ1aWxkQWRkVmFsaWRhdG9yVHggPSBhc3luYyAoXG4gICAgbmV0d29ya0lEOiBudW1iZXIgPSBEZWZhdWx0TmV0d29ya0lELFxuICAgIGJsb2NrY2hhaW5JRDogQnVmZmVyLFxuICAgIHRvQWRkcmVzc2VzOiBCdWZmZXJbXSxcbiAgICBmcm9tU2lnbmVyOiBGcm9tU2lnbmVyLFxuICAgIGNoYW5nZUFkZHJlc3NlczogQnVmZmVyW10sXG4gICAgbm9kZUlEOiBCdWZmZXIsXG4gICAgc3RhcnRUaW1lOiBCTixcbiAgICBlbmRUaW1lOiBCTixcbiAgICBzdGFrZUFtb3VudDogQk4sXG4gICAgc3Rha2VBc3NldElEOiBCdWZmZXIsXG4gICAgcmV3YXJkTG9ja3RpbWU6IEJOLFxuICAgIHJld2FyZFRocmVzaG9sZDogbnVtYmVyLFxuICAgIHJld2FyZEFkZHJlc3NlczogQnVmZmVyW10sXG4gICAgZGVsZWdhdGlvbkZlZTogbnVtYmVyLFxuICAgIGZlZTogQk4gPSB6ZXJvLFxuICAgIGZlZUFzc2V0SUQ6IEJ1ZmZlciA9IHVuZGVmaW5lZCxcbiAgICBtZW1vOiBCdWZmZXIgPSB1bmRlZmluZWQsXG4gICAgYXNPZjogQk4gPSBVbml4Tm93KCksXG4gICAgdG9UaHJlc2hvbGQ6IG51bWJlciA9IDEsXG4gICAgY2hhbmdlVGhyZXNob2xkOiBudW1iZXIgPSAxXG4gICk6IFByb21pc2U8VW5zaWduZWRUeD4gPT4ge1xuICAgIGlmICh0aGlzLmNhbWlub0VuYWJsZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVzZSBidWlsZENhbWlub0FkZFZhbGlkYXRvclR4XCIpXG4gICAgfVxuXG4gICAgbGV0IGluczogVHJhbnNmZXJhYmxlSW5wdXRbXSA9IFtdXG4gICAgbGV0IG91dHM6IFRyYW5zZmVyYWJsZU91dHB1dFtdID0gW11cbiAgICBsZXQgc3Rha2VPdXRzOiBUcmFuc2ZlcmFibGVPdXRwdXRbXSA9IFtdXG4gICAgbGV0IG93bmVyczogT3V0cHV0T3duZXJzW10gPSBbXVxuXG4gICAgY29uc3Qgbm93OiBCTiA9IFVuaXhOb3coKVxuICAgIGlmIChzdGFydFRpbWUubHQobm93KSB8fCBlbmRUaW1lLmx0ZShzdGFydFRpbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgVGltZUVycm9yKFxuICAgICAgICBcIlVUWE9TZXQuYnVpbGRBZGRWYWxpZGF0b3JUeCAtLSBzdGFydFRpbWUgbXVzdCBiZSBpbiB0aGUgZnV0dXJlIGFuZCBlbmRUaW1lIG11c3QgY29tZSBhZnRlciBzdGFydFRpbWVcIlxuICAgICAgKVxuICAgIH1cblxuICAgIGlmIChkZWxlZ2F0aW9uRmVlID4gMTAwIHx8IGRlbGVnYXRpb25GZWUgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVGltZUVycm9yKFxuICAgICAgICBcIlVUWE9TZXQuYnVpbGRBZGRWYWxpZGF0b3JUeCAtLSBzdGFydFRpbWUgbXVzdCBiZSBpbiB0aGUgcmFuZ2Ugb2YgMCB0byAxMDAsIGluY2x1c2l2ZWx5XCJcbiAgICAgIClcbiAgICB9XG5cbiAgICBjb25zdCBhYWQ6IEFzc2V0QW1vdW50RGVzdGluYXRpb24gPSBuZXcgQXNzZXRBbW91bnREZXN0aW5hdGlvbihcbiAgICAgIHRvQWRkcmVzc2VzLFxuICAgICAgdG9UaHJlc2hvbGQsXG4gICAgICBmcm9tU2lnbmVyLmZyb20sXG4gICAgICBmcm9tU2lnbmVyLnNpZ25lcixcbiAgICAgIGNoYW5nZUFkZHJlc3NlcyxcbiAgICAgIGNoYW5nZVRocmVzaG9sZFxuICAgIClcbiAgICBpZiAoc3Rha2VBc3NldElELnRvU3RyaW5nKFwiaGV4XCIpID09PSBmZWVBc3NldElELnRvU3RyaW5nKFwiaGV4XCIpKSB7XG4gICAgICBhYWQuYWRkQXNzZXRBbW91bnQoc3Rha2VBc3NldElELCBzdGFrZUFtb3VudCwgZmVlKVxuICAgIH0gZWxzZSB7XG4gICAgICBhYWQuYWRkQXNzZXRBbW91bnQoc3Rha2VBc3NldElELCBzdGFrZUFtb3VudCwgemVybylcbiAgICAgIGlmICh0aGlzLl9mZWVDaGVjayhmZWUsIGZlZUFzc2V0SUQpKSB7XG4gICAgICAgIGFhZC5hZGRBc3NldEFtb3VudChmZWVBc3NldElELCB6ZXJvLCBmZWUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbWluU3BlbmRhYmxlRXJyOiBFcnJvciA9IGF3YWl0IHRoaXMuc3BlbmRlci5nZXRNaW5pbXVtU3BlbmRhYmxlKFxuICAgICAgYWFkLFxuICAgICAgYXNPZixcbiAgICAgIHplcm8sXG4gICAgICBcIlN0YWtlXCJcbiAgICApXG4gICAgaWYgKHR5cGVvZiBtaW5TcGVuZGFibGVFcnIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlucyA9IGFhZC5nZXRJbnB1dHMoKVxuICAgICAgb3V0cyA9IGFhZC5nZXRDaGFuZ2VPdXRwdXRzKClcbiAgICAgIHN0YWtlT3V0cyA9IGFhZC5nZXRPdXRwdXRzKClcbiAgICAgIG93bmVycyA9IGFhZC5nZXRPdXRwdXRPd25lcnMoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBtaW5TcGVuZGFibGVFcnJcbiAgICB9XG5cbiAgICBjb25zdCByZXdhcmRPdXRwdXRPd25lcnM6IFNFQ1BPd25lck91dHB1dCA9IG5ldyBTRUNQT3duZXJPdXRwdXQoXG4gICAgICByZXdhcmRBZGRyZXNzZXMsXG4gICAgICByZXdhcmRMb2NrdGltZSxcbiAgICAgIHJld2FyZFRocmVzaG9sZFxuICAgIClcblxuICAgIGNvbnN0IGJhc2VUeDogQWRkVmFsaWRhdG9yVHggPSBuZXcgQWRkVmFsaWRhdG9yVHgoXG4gICAgICBuZXR3b3JrSUQsXG4gICAgICBibG9ja2NoYWluSUQsXG4gICAgICBvdXRzLFxuICAgICAgaW5zLFxuICAgICAgbWVtbyxcbiAgICAgIG5vZGVJRCxcbiAgICAgIHN0YXJ0VGltZSxcbiAgICAgIGVuZFRpbWUsXG4gICAgICBzdGFrZUFtb3VudCxcbiAgICAgIHN0YWtlT3V0cyxcbiAgICAgIG5ldyBQYXJzZWFibGVPdXRwdXQocmV3YXJkT3V0cHV0T3duZXJzKSxcbiAgICAgIGRlbGVnYXRpb25GZWVcbiAgICApXG4gICAgYmFzZVR4LnNldE91dHB1dE93bmVycyhvd25lcnMpXG4gICAgcmV0dXJuIG5ldyBVbnNpZ25lZFR4KGJhc2VUeClcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gdW5zaWduZWQgW1tDcmVhdGVTdWJuZXRUeF1dIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gbmV0d29ya0lEIE5ldHdvcmtpZCwgW1tEZWZhdWx0TmV0d29ya0lEXV1cbiAgICogQHBhcmFtIGJsb2NrY2hhaW5JRCBCbG9ja2NoYWluaWQsIGRlZmF1bHQgdW5kZWZpbmVkXG4gICAqIEBwYXJhbSBmcm9tU2lnbmVyIFRoZSBhZGRyZXNzZXMgYmVpbmcgdXNlZCB0byBzZW5kIGFuZCB2ZXJpZnkgdGhlIGZ1bmRzIGZyb20gdGhlIFVUWE9zIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9XG4gICAqIEBwYXJhbSBjaGFuZ2VBZGRyZXNzZXMgVGhlIGFkZHJlc3NlcyB0aGF0IGNhbiBzcGVuZCB0aGUgY2hhbmdlIHJlbWFpbmluZyBmcm9tIHRoZSBzcGVudCBVVFhPcy5cbiAgICogQHBhcmFtIHN1Ym5ldE93bmVyQWRkcmVzc2VzIEFuIGFycmF5IG9mIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IGZvciB0aGUgYWRkcmVzc2VzIHRvIGFkZCB0byBhIHN1Ym5ldFxuICAgKiBAcGFyYW0gc3VibmV0T3duZXJUaHJlc2hvbGQgVGhlIG51bWJlciBvZiBvd25lcnMncyBzaWduYXR1cmVzIHJlcXVpcmVkIHRvIGFkZCBhIHZhbGlkYXRvciB0byB0aGUgbmV0d29ya1xuICAgKiBAcGFyYW0gZmVlIE9wdGlvbmFsLiBUaGUgYW1vdW50IG9mIGZlZXMgdG8gYnVybiBpbiBpdHMgc21hbGxlc3QgZGVub21pbmF0aW9uLCByZXByZXNlbnRlZCBhcyB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfVxuICAgKiBAcGFyYW0gZmVlQXNzZXRJRCBPcHRpb25hbC4gVGhlIGFzc2V0SUQgb2YgdGhlIGZlZXMgYmVpbmcgYnVybmVkXG4gICAqIEBwYXJhbSBtZW1vIE9wdGlvbmFsIGNvbnRhaW5zIGFyYml0cmFyeSBieXRlcywgdXAgdG8gMjU2IGJ5dGVzXG4gICAqIEBwYXJhbSBhc09mIE9wdGlvbmFsLiBUaGUgdGltZXN0YW1wIHRvIHZlcmlmeSB0aGUgdHJhbnNhY3Rpb24gYWdhaW5zdCBhcyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcy98Qk59XG4gICAqIEBwYXJhbSBjaGFuZ2VUaHJlc2hvbGQgT3B0aW9uYWwuIFRoZSBudW1iZXIgb2Ygc2lnbmF0dXJlcyByZXF1aXJlZCB0byBzcGVuZCB0aGUgZnVuZHMgaW4gdGhlIHJlc3VsdGFudCBjaGFuZ2UgVVRYT1xuICAgKlxuICAgKiBAcmV0dXJucyBBbiB1bnNpZ25lZCB0cmFuc2FjdGlvbiBjcmVhdGVkIGZyb20gdGhlIHBhc3NlZCBpbiBwYXJhbWV0ZXJzLlxuICAgKi9cbiAgYnVpbGRDcmVhdGVTdWJuZXRUeCA9IGFzeW5jIChcbiAgICBuZXR3b3JrSUQ6IG51bWJlciA9IERlZmF1bHROZXR3b3JrSUQsXG4gICAgYmxvY2tjaGFpbklEOiBCdWZmZXIsXG4gICAgZnJvbVNpZ25lcjogRnJvbVNpZ25lcixcbiAgICBjaGFuZ2VBZGRyZXNzZXM6IEJ1ZmZlcltdLFxuICAgIHN1Ym5ldE93bmVyQWRkcmVzc2VzOiBCdWZmZXJbXSxcbiAgICBzdWJuZXRPd25lclRocmVzaG9sZDogbnVtYmVyLFxuICAgIGZlZTogQk4gPSB6ZXJvLFxuICAgIGZlZUFzc2V0SUQ6IEJ1ZmZlciA9IHVuZGVmaW5lZCxcbiAgICBtZW1vOiBCdWZmZXIgPSB1bmRlZmluZWQsXG4gICAgYXNPZjogQk4gPSB6ZXJvLFxuICAgIGNoYW5nZVRocmVzaG9sZDogbnVtYmVyID0gMVxuICApOiBQcm9taXNlPFVuc2lnbmVkVHg+ID0+IHtcbiAgICBsZXQgaW5zOiBUcmFuc2ZlcmFibGVJbnB1dFtdID0gW11cbiAgICBsZXQgb3V0czogVHJhbnNmZXJhYmxlT3V0cHV0W10gPSBbXVxuICAgIGxldCBvd25lcnM6IE91dHB1dE93bmVyc1tdID0gW11cblxuICAgIGlmICh0aGlzLl9mZWVDaGVjayhmZWUsIGZlZUFzc2V0SUQpKSB7XG4gICAgICBjb25zdCBhYWQ6IEFzc2V0QW1vdW50RGVzdGluYXRpb24gPSBuZXcgQXNzZXRBbW91bnREZXN0aW5hdGlvbihcbiAgICAgICAgW10sXG4gICAgICAgIDAsXG4gICAgICAgIGZyb21TaWduZXIuZnJvbSxcbiAgICAgICAgZnJvbVNpZ25lci5zaWduZXIsXG4gICAgICAgIGNoYW5nZUFkZHJlc3NlcyxcbiAgICAgICAgY2hhbmdlVGhyZXNob2xkXG4gICAgICApXG5cbiAgICAgIGFhZC5hZGRBc3NldEFtb3VudChmZWVBc3NldElELCB6ZXJvLCBmZWUpXG4gICAgICBjb25zdCBtaW5TcGVuZGFibGVFcnI6IEVycm9yID0gYXdhaXQgdGhpcy5zcGVuZGVyLmdldE1pbmltdW1TcGVuZGFibGUoXG4gICAgICAgIGFhZCxcbiAgICAgICAgYXNPZixcbiAgICAgICAgemVybyxcbiAgICAgICAgXCJVbmxvY2tlZFwiXG4gICAgICApXG4gICAgICBpZiAodHlwZW9mIG1pblNwZW5kYWJsZUVyciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpbnMgPSBhYWQuZ2V0SW5wdXRzKClcbiAgICAgICAgb3V0cyA9IGFhZC5nZXRBbGxPdXRwdXRzKClcbiAgICAgICAgb3duZXJzID0gYWFkLmdldE91dHB1dE93bmVycygpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBtaW5TcGVuZGFibGVFcnJcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBsb2NrdGltZTogQk4gPSBuZXcgQk4oMClcbiAgICBjb25zdCBzdWJuZXRPd25lcnM6IFNFQ1BPd25lck91dHB1dCA9IG5ldyBTRUNQT3duZXJPdXRwdXQoXG4gICAgICBzdWJuZXRPd25lckFkZHJlc3NlcyxcbiAgICAgIGxvY2t0aW1lLFxuICAgICAgc3VibmV0T3duZXJUaHJlc2hvbGRcbiAgICApXG4gICAgY29uc3QgYmFzZVR4OiBDcmVhdGVTdWJuZXRUeCA9IG5ldyBDcmVhdGVTdWJuZXRUeChcbiAgICAgIG5ldHdvcmtJRCxcbiAgICAgIGJsb2NrY2hhaW5JRCxcbiAgICAgIG91dHMsXG4gICAgICBpbnMsXG4gICAgICBtZW1vLFxuICAgICAgc3VibmV0T3duZXJzXG4gICAgKVxuICAgIGJhc2VUeC5zZXRPdXRwdXRPd25lcnMob3duZXJzKVxuICAgIHJldHVybiBuZXcgVW5zaWduZWRUeChiYXNlVHgpXG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgYW4gdW5zaWduZWQgW1tDcmVhdGVDaGFpblR4XV0uXG4gICAqXG4gICAqIEBwYXJhbSBuZXR3b3JrSUQgTmV0d29ya2lkLCBbW0RlZmF1bHROZXR3b3JrSURdXVxuICAgKiBAcGFyYW0gYmxvY2tjaGFpbklEIEJsb2NrY2hhaW5pZCwgZGVmYXVsdCB1bmRlZmluZWRcbiAgICogQHBhcmFtIGZyb21TaWduZXIgVGhlIGFkZHJlc3NlcyBiZWluZyB1c2VkIHRvIHNlbmQgYW5kIHZlcmlmeSB0aGUgZnVuZHMgZnJvbSB0aGUgVVRYT3Mge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn1cbiAgICogQHBhcmFtIGNoYW5nZUFkZHJlc3NlcyBUaGUgYWRkcmVzc2VzIHRoYXQgY2FuIHNwZW5kIHRoZSBjaGFuZ2UgcmVtYWluaW5nIGZyb20gdGhlIHNwZW50IFVUWE9zLlxuICAgKiBAcGFyYW0gc3VibmV0SUQgT3B0aW9uYWwgSUQgb2YgdGhlIFN1Ym5ldCB0aGF0IHZhbGlkYXRlcyB0aGlzIGJsb2NrY2hhaW5cbiAgICogQHBhcmFtIGNoYWluTmFtZSBPcHRpb25hbCBBIGh1bWFuIHJlYWRhYmxlIG5hbWUgZm9yIHRoZSBjaGFpbjsgbmVlZCBub3QgYmUgdW5pcXVlXG4gICAqIEBwYXJhbSB2bUlEIE9wdGlvbmFsIElEIG9mIHRoZSBWTSBydW5uaW5nIG9uIHRoZSBuZXcgY2hhaW5cbiAgICogQHBhcmFtIGZ4SURzIE9wdGlvbmFsIElEcyBvZiB0aGUgZmVhdHVyZSBleHRlbnNpb25zIHJ1bm5pbmcgb24gdGhlIG5ldyBjaGFpblxuICAgKiBAcGFyYW0gZ2VuZXNpc0RhdGEgT3B0aW9uYWwgQnl0ZSByZXByZXNlbnRhdGlvbiBvZiBnZW5lc2lzIHN0YXRlIG9mIHRoZSBuZXcgY2hhaW5cbiAgICogQHBhcmFtIGZlZSBPcHRpb25hbC4gVGhlIGFtb3VudCBvZiBmZWVzIHRvIGJ1cm4gaW4gaXRzIHNtYWxsZXN0IGRlbm9taW5hdGlvbiwgcmVwcmVzZW50ZWQgYXMge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn1cbiAgICogQHBhcmFtIGZlZUFzc2V0SUQgT3B0aW9uYWwuIFRoZSBhc3NldElEIG9mIHRoZSBmZWVzIGJlaW5nIGJ1cm5lZFxuICAgKiBAcGFyYW0gbWVtbyBPcHRpb25hbCBjb250YWlucyBhcmJpdHJhcnkgYnl0ZXMsIHVwIHRvIDI1NiBieXRlc1xuICAgKiBAcGFyYW0gYXNPZiBPcHRpb25hbC4gVGhlIHRpbWVzdGFtcCB0byB2ZXJpZnkgdGhlIHRyYW5zYWN0aW9uIGFnYWluc3QgYXMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfVxuICAgKiBAcGFyYW0gc3VibmV0QXV0aCBPcHRpb25hbC4gQW4gQXV0aCBzdHJ1Y3QgdG8gc2lnbiBmb3IgdGhlIFN1Ym5ldC5cbiAgICogQHBhcmFtIGNoYW5nZVRocmVzaG9sZCBPcHRpb25hbC4gVGhlIG51bWJlciBvZiBzaWduYXR1cmVzIHJlcXVpcmVkIHRvIHNwZW5kIHRoZSBmdW5kcyBpbiB0aGUgcmVzdWx0YW50IGNoYW5nZSBVVFhPXG4gICAqXG4gICAqIEByZXR1cm5zIEFuIHVuc2lnbmVkIENyZWF0ZUNoYWluVHggY3JlYXRlZCBmcm9tIHRoZSBwYXNzZWQgaW4gcGFyYW1ldGVycy5cbiAgICovXG4gIGJ1aWxkQ3JlYXRlQ2hhaW5UeCA9IGFzeW5jIChcbiAgICBuZXR3b3JrSUQ6IG51bWJlciA9IERlZmF1bHROZXR3b3JrSUQsXG4gICAgYmxvY2tjaGFpbklEOiBCdWZmZXIsXG4gICAgZnJvbVNpZ25lcjogRnJvbVNpZ25lcixcbiAgICBjaGFuZ2VBZGRyZXNzZXM6IEJ1ZmZlcltdLFxuICAgIHN1Ym5ldElEOiBzdHJpbmcgfCBCdWZmZXIgPSB1bmRlZmluZWQsXG4gICAgY2hhaW5OYW1lOiBzdHJpbmcgPSB1bmRlZmluZWQsXG4gICAgdm1JRDogc3RyaW5nID0gdW5kZWZpbmVkLFxuICAgIGZ4SURzOiBzdHJpbmdbXSA9IHVuZGVmaW5lZCxcbiAgICBnZW5lc2lzRGF0YTogc3RyaW5nIHwgR2VuZXNpc0RhdGEgPSB1bmRlZmluZWQsXG4gICAgZmVlOiBCTiA9IHplcm8sXG4gICAgZmVlQXNzZXRJRDogQnVmZmVyID0gdW5kZWZpbmVkLFxuICAgIG1lbW86IEJ1ZmZlciA9IHVuZGVmaW5lZCxcbiAgICBhc09mOiBCTiA9IHplcm8sXG4gICAgc3VibmV0QXV0aDogQXV0aCA9IHsgYWRkcmVzc2VzOiBbXSwgdGhyZXNob2xkOiAwLCBzaWduZXI6IFtdIH0sXG4gICAgY2hhbmdlVGhyZXNob2xkOiBudW1iZXIgPSAxXG4gICk6IFByb21pc2U8VW5zaWduZWRUeD4gPT4ge1xuICAgIGxldCBpbnM6IFRyYW5zZmVyYWJsZUlucHV0W10gPSBbXVxuICAgIGxldCBvdXRzOiBUcmFuc2ZlcmFibGVPdXRwdXRbXSA9IFtdXG4gICAgbGV0IG93bmVyczogT3V0cHV0T3duZXJzW10gPSBbXVxuXG4gICAgaWYgKHRoaXMuX2ZlZUNoZWNrKGZlZSwgZmVlQXNzZXRJRCkpIHtcbiAgICAgIGNvbnN0IGFhZDogQXNzZXRBbW91bnREZXN0aW5hdGlvbiA9IG5ldyBBc3NldEFtb3VudERlc3RpbmF0aW9uKFxuICAgICAgICBbXSxcbiAgICAgICAgMCxcbiAgICAgICAgZnJvbVNpZ25lci5mcm9tLFxuICAgICAgICBmcm9tU2lnbmVyLnNpZ25lcixcbiAgICAgICAgY2hhbmdlQWRkcmVzc2VzLFxuICAgICAgICBjaGFuZ2VUaHJlc2hvbGRcbiAgICAgIClcblxuICAgICAgYWFkLmFkZEFzc2V0QW1vdW50KGZlZUFzc2V0SUQsIHplcm8sIGZlZSlcbiAgICAgIGNvbnN0IG1pblNwZW5kYWJsZUVycjogRXJyb3IgPSBhd2FpdCB0aGlzLnNwZW5kZXIuZ2V0TWluaW11bVNwZW5kYWJsZShcbiAgICAgICAgYWFkLFxuICAgICAgICBhc09mLFxuICAgICAgICB6ZXJvLFxuICAgICAgICBcIlVubG9ja2VkXCJcbiAgICAgIClcbiAgICAgIGlmICh0eXBlb2YgbWluU3BlbmRhYmxlRXJyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlucyA9IGFhZC5nZXRJbnB1dHMoKVxuICAgICAgICBvdXRzID0gYWFkLmdldEFsbE91dHB1dHMoKVxuICAgICAgICBvd25lcnMgPSBhYWQuZ2V0T3V0cHV0T3duZXJzKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG1pblNwZW5kYWJsZUVyclxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGJhc2VUeDogQ3JlYXRlQ2hhaW5UeCA9IG5ldyBDcmVhdGVDaGFpblR4KFxuICAgICAgbmV0d29ya0lELFxuICAgICAgYmxvY2tjaGFpbklELFxuICAgICAgb3V0cyxcbiAgICAgIGlucyxcbiAgICAgIG1lbW8sXG4gICAgICBzdWJuZXRJRCxcbiAgICAgIGNoYWluTmFtZSxcbiAgICAgIHZtSUQsXG4gICAgICBmeElEcyxcbiAgICAgIGdlbmVzaXNEYXRhXG4gICAgKVxuICAgIHN1Ym5ldEF1dGguc2lnbmVyLmZvckVhY2goKHN1Ym5ldEF1dGhTaWduZXIpOiB2b2lkID0+IHtcbiAgICAgIGJhc2VUeC5hZGRTaWduYXR1cmVJZHgoc3VibmV0QXV0aFNpZ25lclswXSwgc3VibmV0QXV0aFNpZ25lclsxXSlcbiAgICB9KVxuXG4gICAgLy8gV2UgbmVlZCB0byBmZXRjaCB0aGUgQVVUSCBmb3IgbGF0ZXIgbXNpZyB2ZXJpZmljYXRpb25cbiAgICAvLyBGb3Igbm93IHdlIHVzZSBzaW1wbHkgd2hhdCB3ZSBnZXQgaW4gc3VibmV0QXV0aFxuICAgIG93bmVycy5wdXNoKFxuICAgICAgbmV3IE91dHB1dE93bmVycyhzdWJuZXRBdXRoLmFkZHJlc3NlcywgWmVyb0JOLCBzdWJuZXRBdXRoLnRocmVzaG9sZClcbiAgICApXG5cbiAgICBiYXNlVHguc2V0T3V0cHV0T3duZXJzKG93bmVycylcbiAgICByZXR1cm4gbmV3IFVuc2lnbmVkVHgoYmFzZVR4KVxuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB3aGljaCBjcmVhdGVzIGFuIHVuc2lnbmVkIFtbQ2FtaW5vQWRkVmFsaWRhdG9yVHhdXS4gRm9yIG1vcmUgZ3JhbnVsYXIgY29udHJvbCwgeW91IG1heSBjcmVhdGUgeW91ciBvd25cbiAgICogW1tVbnNpZ25lZFR4XV0gbWFudWFsbHkgYW5kIGltcG9ydCB0aGUgW1tDYW1pbm9BZGRWYWxpZGF0b3JUeF1dIGNsYXNzIGRpcmVjdGx5LlxuICAgKlxuICAgKiBAcGFyYW0gbmV0d29ya0lEIE5ldHdvcmtpZCwgW1tEZWZhdWx0TmV0d29ya0lEXV1cbiAgICogQHBhcmFtIGJsb2NrY2hhaW5JRCBCbG9ja2NoYWluaWQsIGRlZmF1bHQgdW5kZWZpbmVkXG4gICAqIEBwYXJhbSB0b0FkZHJlc3NlcyBBbiBhcnJheSBvZiBhZGRyZXNzZXMgYXMge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gd2hvIHJlY2VpdmVkIHRoZSBzdGFrZWQgdG9rZW5zIGF0IHRoZSBlbmQgb2YgdGhlIHN0YWtpbmcgcGVyaW9kXG4gICAqIEBwYXJhbSBmcm9tU2lnbmVyIFRoZSBhZGRyZXNzZXMgYmVpbmcgdXNlZCB0byBzZW5kIGFuZCB2ZXJpZnkgdGhlIGZ1bmRzIGZyb20gdGhlIFVUWE9zIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9XG4gICAqIEBwYXJhbSBjaGFuZ2VBZGRyZXNzZXMgQW4gYXJyYXkgb2YgYWRkcmVzc2VzIGFzIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IHdobyBnZXRzIHRoZSBjaGFuZ2UgbGVmdG92ZXIgZnJvbSB0aGUgZmVlIHBheW1lbnRcbiAgICogQHBhcmFtIG5vZGVJRCBUaGUgbm9kZSBJRCBvZiB0aGUgdmFsaWRhdG9yIGJlaW5nIGFkZGVkLlxuICAgKiBAcGFyYW0gbm9kZU93bmVyIFRoZSBhZGRyZXNzIGFuZCBzaWduYXR1cmUgaW5kaWNlcyBvZiB0aGUgcmVnaXN0ZXJlZCBub2RlSWQgb3duZXIuXG4gICAqIEBwYXJhbSBzdGFydFRpbWUgVGhlIFVuaXggdGltZSB3aGVuIHRoZSB2YWxpZGF0b3Igc3RhcnRzIHZhbGlkYXRpbmcgdGhlIFByaW1hcnkgTmV0d29yay5cbiAgICogQHBhcmFtIGVuZFRpbWUgVGhlIFVuaXggdGltZSB3aGVuIHRoZSB2YWxpZGF0b3Igc3RvcHMgdmFsaWRhdGluZyB0aGUgUHJpbWFyeSBOZXR3b3JrIChhbmQgc3Rha2VkIEFWQVggaXMgcmV0dXJuZWQpLlxuICAgKiBAcGFyYW0gc3Rha2VBbW91bnQgVGhlIGFtb3VudCBiZWluZyBkZWxlZ2F0ZWQgYXMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfVxuICAgKiBAcGFyYW0gcmV3YXJkQWRkcmVzc2VzIFRoZSBhZGRyZXNzZXMgd2hpY2ggd2lsbCByZWNpZXZlIHRoZSByZXdhcmRzIGZyb20gdGhlIGRlbGVnYXRlZCBzdGFrZS5cbiAgICogQHBhcmFtIHJld2FyZExvY2t0aW1lIE9wdGlvbmFsLiBUaGUgbG9ja3RpbWUgZmllbGQgY3JlYXRlZCBpbiB0aGUgcmVzdWx0aW5nIHJld2FyZCBvdXRwdXRzXG4gICAqIEBwYXJhbSByZXdhcmRUaHJlc2hvbGQgT3Bpb25hbC4gVGhlIG51bWJlciBvZiBzaWduYXR1cmVzIHJlcXVpcmVkIHRvIHNwZW5kIHRoZSBmdW5kcyBpbiB0aGUgcmVzdWx0YW50IHJld2FyZCBVVFhPLiBEZWZhdWx0IDEuXG4gICAqIEBwYXJhbSBtZW1vIE9wdGlvbmFsIGNvbnRhaW5zIGFyYml0cmFyeSBieXRlcywgdXAgdG8gMjU2IGJ5dGVzXG4gICAqIEBwYXJhbSBhc09mIE9wdGlvbmFsLiBUaGUgdGltZXN0YW1wIHRvIHZlcmlmeSB0aGUgdHJhbnNhY3Rpb24gYWdhaW5zdCBhcyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcy98Qk59XG4gICAqIEBwYXJhbSB0b1RocmVzaG9sZCBPcHRpb25hbC4gVGhlIG51bWJlciBvZiBzaWduYXR1cmVzIHJlcXVpcmVkIHRvIHNwZW5kIHRoZSBmdW5kcyBpbiB0aGUgcmVjZWl2ZWQgVVRYT1xuICAgKiBAcGFyYW0gY2hhbmdlVGhyZXNob2xkIE9wdGlvbmFsLiBUaGUgbnVtYmVyIG9mIHNpZ25hdHVyZXMgcmVxdWlyZWQgdG8gc3BlbmQgdGhlIGZ1bmRzIGluIHRoZSByZXN1bHRhbnQgY2hhbmdlIFVUWE9cbiAgICpcbiAgICogQHJldHVybnMgQW4gdW5zaWduZWQgdHJhbnNhY3Rpb24gY3JlYXRlZCBmcm9tIHRoZSBwYXNzZWQgaW4gcGFyYW1ldGVycy5cbiAgICovXG4gIGJ1aWxkQ2FtaW5vQWRkVmFsaWRhdG9yVHggPSBhc3luYyAoXG4gICAgbmV0d29ya0lEOiBudW1iZXIgPSBEZWZhdWx0TmV0d29ya0lELFxuICAgIGJsb2NrY2hhaW5JRDogQnVmZmVyLFxuICAgIGZyb21TaWduZXI6IEZyb21TaWduZXIsXG4gICAgY2hhbmdlOiBCdWZmZXJbXSxcbiAgICBub2RlSUQ6IEJ1ZmZlcixcbiAgICBub2RlT3duZXI6IE5vZGVPd25lcixcbiAgICBzdGFydFRpbWU6IEJOLFxuICAgIGVuZFRpbWU6IEJOLFxuICAgIHN0YWtlQW1vdW50OiBCTixcbiAgICBzdGFrZUFzc2V0SUQ6IEJ1ZmZlcixcbiAgICByZXdhcmRzOiBCdWZmZXJbXSxcbiAgICByZXdhcmRMb2NrdGltZTogQk4gPSB6ZXJvLFxuICAgIHJld2FyZFRocmVzaG9sZDogbnVtYmVyID0gMSxcbiAgICBtZW1vOiBCdWZmZXIgPSB1bmRlZmluZWQsXG4gICAgYXNPZjogQk4gPSB6ZXJvLFxuICAgIHRvVGhyZXNob2xkOiBudW1iZXIgPSAxLFxuICAgIGNoYW5nZVRocmVzaG9sZDogbnVtYmVyID0gMVxuICApOiBQcm9taXNlPFVuc2lnbmVkVHg+ID0+IHtcbiAgICBsZXQgaW5zOiBUcmFuc2ZlcmFibGVJbnB1dFtdID0gW11cbiAgICBsZXQgb3V0czogVHJhbnNmZXJhYmxlT3V0cHV0W10gPSBbXVxuICAgIGxldCBvd25lcnM6IE91dHB1dE93bmVyc1tdID0gW11cblxuICAgIGNvbnN0IG5vdzogQk4gPSBVbml4Tm93KClcbiAgICBpZiAoc3RhcnRUaW1lLmx0KG5vdykgfHwgZW5kVGltZS5sdGUoc3RhcnRUaW1lKSkge1xuICAgICAgdGhyb3cgbmV3IFRpbWVFcnJvcihcbiAgICAgICAgXCJidWlsZENhbWlub0FkZFZhbGlkYXRvclR4IC0tIHN0YXJ0VGltZSBtdXN0IGJlIGluIHRoZSBmdXR1cmUgYW5kIGVuZFRpbWUgbXVzdCBjb21lIGFmdGVyIHN0YXJ0VGltZVwiXG4gICAgICApXG4gICAgfVxuXG4gICAgY29uc3QgYWFkOiBBc3NldEFtb3VudERlc3RpbmF0aW9uID0gbmV3IEFzc2V0QW1vdW50RGVzdGluYXRpb24oXG4gICAgICBbXSxcbiAgICAgIHRvVGhyZXNob2xkLFxuICAgICAgZnJvbVNpZ25lci5mcm9tLFxuICAgICAgZnJvbVNpZ25lci5zaWduZXIsXG4gICAgICBjaGFuZ2UsXG4gICAgICBjaGFuZ2VUaHJlc2hvbGRcbiAgICApXG5cbiAgICBhYWQuYWRkQXNzZXRBbW91bnQoc3Rha2VBc3NldElELCBzdGFrZUFtb3VudCwgbmV3IEJOKDApKVxuXG4gICAgY29uc3QgbWluU3BlbmRhYmxlRXJyOiBFcnJvciA9IGF3YWl0IHRoaXMuc3BlbmRlci5nZXRNaW5pbXVtU3BlbmRhYmxlKFxuICAgICAgYWFkLFxuICAgICAgYXNPZixcbiAgICAgIHplcm8sXG4gICAgICBcIkJvbmRcIlxuICAgIClcbiAgICBpZiAodHlwZW9mIG1pblNwZW5kYWJsZUVyciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaW5zID0gYWFkLmdldElucHV0cygpXG4gICAgICBvdXRzID0gYWFkLmdldEFsbE91dHB1dHMoKVxuICAgICAgb3duZXJzID0gYWFkLmdldE91dHB1dE93bmVycygpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG1pblNwZW5kYWJsZUVyclxuICAgIH1cblxuICAgIGNvbnN0IHJld2FyZE91dHB1dE93bmVyczogU0VDUE93bmVyT3V0cHV0ID0gbmV3IFNFQ1BPd25lck91dHB1dChcbiAgICAgIHJld2FyZHMsXG4gICAgICByZXdhcmRMb2NrdGltZSxcbiAgICAgIHJld2FyZFRocmVzaG9sZFxuICAgIClcblxuICAgIGNvbnN0IGJhc2VUeDogQ2FtaW5vQWRkVmFsaWRhdG9yVHggPSBuZXcgQ2FtaW5vQWRkVmFsaWRhdG9yVHgoXG4gICAgICBuZXR3b3JrSUQsXG4gICAgICBibG9ja2NoYWluSUQsXG4gICAgICBvdXRzLFxuICAgICAgaW5zLFxuICAgICAgbWVtbyxcbiAgICAgIG5vZGVJRCxcbiAgICAgIHN0YXJ0VGltZSxcbiAgICAgIGVuZFRpbWUsXG4gICAgICBzdGFrZUFtb3VudCxcbiAgICAgIG5ldyBQYXJzZWFibGVPdXRwdXQocmV3YXJkT3V0cHV0T3duZXJzKVxuICAgIClcblxuICAgIG5vZGVPd25lci5hdXRoLmZvckVhY2goKG8pID0+IHtcbiAgICAgIGJhc2VUeC5hZGRTaWduYXR1cmVJZHgob1swXSwgb1sxXSlcbiAgICB9KVxuICAgIG93bmVycy5wdXNoKG5ldyBPdXRwdXRPd25lcnMoW25vZGVPd25lci5hZGRyZXNzXSwgWmVyb0JOLCAxKSlcblxuICAgIGJhc2VUeC5zZXRPdXRwdXRPd25lcnMob3duZXJzKVxuICAgIHJldHVybiBuZXcgVW5zaWduZWRUeChiYXNlVHgpXG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgYW4gdW5zaWduZWQgW1tBZGRyZXNzU3RhdGVUeF1dLlxuICAgKlxuICAgKiBAcGFyYW0gdmVyc2lvbiBPcHRpb25hbC4gVHJhbnNhY3Rpb24gdmVyc2lvbiBudW1iZXIsIGRlZmF1bHQgMC5cbiAgICogQHBhcmFtIG5ldHdvcmtJRCBOZXR3b3JraWQsIFtbRGVmYXVsdE5ldHdvcmtJRF1dXG4gICAqIEBwYXJhbSBibG9ja2NoYWluSUQgQmxvY2tjaGFpbmlkLCBkZWZhdWx0IHVuZGVmaW5lZFxuICAgKiBAcGFyYW0gZnJvbVNpZ25lciBUaGUgYWRkcmVzc2VzIGJlaW5nIHVzZWQgdG8gc2VuZCBhbmQgdmVyaWZ5IHRoZSBmdW5kcyBmcm9tIHRoZSBVVFhPcyB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfVxuICAgKiBAcGFyYW0gY2hhbmdlQWRkcmVzc2VzIFRoZSBhZGRyZXNzZXMgdGhhdCBjYW4gc3BlbmQgdGhlIGNoYW5nZSByZW1haW5pbmcgZnJvbSB0aGUgc3BlbnQgVVRYT3MuXG4gICAqIEBwYXJhbSBhZGRyZXNzIFRoZSBhZGRyZXNzIHRvIGFsdGVyIHN0YXRlLlxuICAgKiBAcGFyYW0gc3RhdGUgVGhlIHN0YXRlIHRvIHNldCBvciByZW1vdmUgb24gdGhlIGdpdmVuIGFkZHJlc3NcbiAgICogQHBhcmFtIHJlbW92ZSBPcHRpb25hbC4gRmxhZyBpZiBzdGF0ZSBzaG91bGQgYmUgYXBwbGllZCBvciByZW1vdmVkXG4gICAqIEBwYXJhbSBmZWUgT3B0aW9uYWwuIFRoZSBhbW91bnQgb2YgZmVlcyB0byBidXJuIGluIGl0cyBzbWFsbGVzdCBkZW5vbWluYXRpb24sIHJlcHJlc2VudGVkIGFzIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcy98Qk59XG4gICAqIEBwYXJhbSBmZWVBc3NldElEIE9wdGlvbmFsLiBUaGUgYXNzZXRJRCBvZiB0aGUgZmVlcyBiZWluZyBidXJuZWRcbiAgICogQHBhcmFtIG1lbW8gT3B0aW9uYWwgY29udGFpbnMgYXJiaXRyYXJ5IGJ5dGVzLCB1cCB0byAyNTYgYnl0ZXNcbiAgICogQHBhcmFtIGFzT2YgT3B0aW9uYWwuIFRoZSB0aW1lc3RhbXAgdG8gdmVyaWZ5IHRoZSB0cmFuc2FjdGlvbiBhZ2FpbnN0IGFzIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn1cbiAgICogQHBhcmFtIGNoYW5nZVRocmVzaG9sZCBPcHRpb25hbC4gVGhlIG51bWJlciBvZiBzaWduYXR1cmVzIHJlcXVpcmVkIHRvIHNwZW5kIHRoZSBmdW5kcyBpbiB0aGUgcmVzdWx0YW50IGNoYW5nZSBVVFhPXG4gICAqXG4gICAqIEByZXR1cm5zIEFuIHVuc2lnbmVkIEFkZHJlc3NTdGF0ZVR4IGNyZWF0ZWQgZnJvbSB0aGUgcGFzc2VkIGluIHBhcmFtZXRlcnMuXG4gICAqL1xuICBidWlsZEFkZHJlc3NTdGF0ZVR4ID0gYXN5bmMgKFxuICAgIHZlcnNpb246IG51bWJlciA9IERlZmF1bHRUcmFuc2FjdGlvblZlcnNpb25OdW1iZXIsXG4gICAgbmV0d29ya0lEOiBudW1iZXIgPSBEZWZhdWx0TmV0d29ya0lELFxuICAgIGJsb2NrY2hhaW5JRDogQnVmZmVyLFxuICAgIGZyb21TaWduZXI6IEZyb21TaWduZXIsXG4gICAgY2hhbmdlQWRkcmVzc2VzOiBCdWZmZXJbXSxcbiAgICBhZGRyZXNzOiBCdWZmZXIsXG4gICAgc3RhdGU6IG51bWJlcixcbiAgICByZW1vdmU6IGJvb2xlYW4gPSBmYWxzZSxcbiAgICBmZWU6IEJOID0gemVybyxcbiAgICBmZWVBc3NldElEOiBCdWZmZXIgPSB1bmRlZmluZWQsXG4gICAgbWVtbzogQnVmZmVyID0gdW5kZWZpbmVkLFxuICAgIGFzT2Y6IEJOID0gemVybyxcbiAgICBjaGFuZ2VUaHJlc2hvbGQ6IG51bWJlciA9IDEsXG4gICAgZXhlY3V0b3JBZGRyZXNzOiBCdWZmZXIgPSB1bmRlZmluZWQsXG4gICAgZXhlY3V0b3JBdXRoOiBbbnVtYmVyLCBCdWZmZXJdW10gPSBbXVxuICApOiBQcm9taXNlPFVuc2lnbmVkVHg+ID0+IHtcbiAgICBsZXQgaW5zOiBUcmFuc2ZlcmFibGVJbnB1dFtdID0gW11cbiAgICBsZXQgb3V0czogVHJhbnNmZXJhYmxlT3V0cHV0W10gPSBbXVxuICAgIGxldCBvd25lcnM6IE91dHB1dE93bmVyc1tdID0gW11cblxuICAgIGlmICh0aGlzLl9mZWVDaGVjayhmZWUsIGZlZUFzc2V0SUQpKSB7XG4gICAgICBjb25zdCBhYWQ6IEFzc2V0QW1vdW50RGVzdGluYXRpb24gPSBuZXcgQXNzZXRBbW91bnREZXN0aW5hdGlvbihcbiAgICAgICAgW10sXG4gICAgICAgIDAsXG4gICAgICAgIGZyb21TaWduZXIuZnJvbSxcbiAgICAgICAgZnJvbVNpZ25lci5zaWduZXIsXG4gICAgICAgIGNoYW5nZUFkZHJlc3NlcyxcbiAgICAgICAgY2hhbmdlVGhyZXNob2xkXG4gICAgICApXG5cbiAgICAgIGFhZC5hZGRBc3NldEFtb3VudChmZWVBc3NldElELCB6ZXJvLCBmZWUpXG5cbiAgICAgIGNvbnN0IG1pblNwZW5kYWJsZUVycjogRXJyb3IgPSBhd2FpdCB0aGlzLnNwZW5kZXIuZ2V0TWluaW11bVNwZW5kYWJsZShcbiAgICAgICAgYWFkLFxuICAgICAgICBhc09mLFxuICAgICAgICB6ZXJvLFxuICAgICAgICBcIlVubG9ja2VkXCJcbiAgICAgIClcbiAgICAgIGlmICh0eXBlb2YgbWluU3BlbmRhYmxlRXJyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlucyA9IGFhZC5nZXRJbnB1dHMoKVxuICAgICAgICBvdXRzID0gYWFkLmdldEFsbE91dHB1dHMoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbWluU3BlbmRhYmxlRXJyXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYmFzZVR4OiBBZGRyZXNzU3RhdGVUeCA9IG5ldyBBZGRyZXNzU3RhdGVUeChcbiAgICAgIHZlcnNpb24sXG4gICAgICBuZXR3b3JrSUQsXG4gICAgICBibG9ja2NoYWluSUQsXG4gICAgICBvdXRzLFxuICAgICAgaW5zLFxuICAgICAgbWVtbyxcbiAgICAgIGFkZHJlc3MsXG4gICAgICBzdGF0ZSxcbiAgICAgIHJlbW92ZSxcbiAgICAgIGV4ZWN1dG9yQWRkcmVzc1xuICAgIClcblxuICAgIGlmIChleGVjdXRvckFkZHJlc3MpIHtcbiAgICAgIGV4ZWN1dG9yQXV0aC5mb3JFYWNoKChzaWduZXIpOiB2b2lkID0+IHtcbiAgICAgICAgYmFzZVR4LmFkZFNpZ25hdHVyZUlkeChzaWduZXJbMF0sIHNpZ25lclsxXSlcbiAgICAgIH0pXG4gICAgICBvd25lcnMucHVzaChuZXcgT3V0cHV0T3duZXJzKFtleGVjdXRvckFkZHJlc3NdLCBaZXJvQk4sIDEpKVxuICAgIH1cblxuICAgIGJhc2VUeC5zZXRPdXRwdXRPd25lcnMob3duZXJzKVxuICAgIHJldHVybiBuZXcgVW5zaWduZWRUeChiYXNlVHgpXG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgYW4gdW5zaWduZWQgW1tSZWdpc3Rlck5vZGVUeF1dLlxuICAgKlxuICAgKiBAcGFyYW0gbmV0d29ya0lEIE5ldHdvcmtpZCwgW1tEZWZhdWx0TmV0d29ya0lEXV1cbiAgICogQHBhcmFtIGJsb2NrY2hhaW5JRCBCbG9ja2NoYWluaWQsIGRlZmF1bHQgdW5kZWZpbmVkXG4gICAqIEBwYXJhbSBmcm9tU2lnbmVyIFRoZSBhZGRyZXNzZXMgYmVpbmcgdXNlZCB0byBzZW5kIGFuZCB2ZXJpZnkgdGhlIGZ1bmRzIGZyb20gdGhlIFVUWE9zIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9XG4gICAqIEBwYXJhbSBjaGFuZ2VBZGRyZXNzZXMgVGhlIGFkZHJlc3NlcyB0aGF0IGNhbiBzcGVuZCB0aGUgY2hhbmdlIHJlbWFpbmluZyBmcm9tIHRoZSBzcGVudCBVVFhPcy5cbiAgICogQHBhcmFtIG9sZE5vZGVJRCBPcHRpb25hbC4gSUQgb2YgdGhlIGV4aXN0aW5nIE5vZGVJRCB0byByZXBsYWNlIG9yIHJlbW92ZS5cbiAgICogQHBhcmFtIG5ld05vZGVJRCBPcHRpb25hbC4gSUQgb2YgdGhlIG5ld05vZElEIHRvIHJlZ2lzdGVyIGFkZHJlc3MuXG4gICAqIEBwYXJhbSBhZGRyZXNzIFRoZSBjb25zb3J0aXVtTWVtYmVyQWRkcmVzcywgc2luZ2xlIG9yIG11bHRpLXNpZy5cbiAgICogQHBhcmFtIGFkZHJlc3NBdXRocyBBbiBhcnJheSBvZiBpbmRleCBhbmQgYWRkcmVzcyB0byB2ZXJpZnkgb3duZXJzaGlwIG9mIGFkZHJlc3MuXG4gICAqIEBwYXJhbSBmZWUgT3B0aW9uYWwuIFRoZSBhbW91bnQgb2YgZmVlcyB0byBidXJuIGluIGl0cyBzbWFsbGVzdCBkZW5vbWluYXRpb24sIHJlcHJlc2VudGVkIGFzIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcy98Qk59XG4gICAqIEBwYXJhbSBmZWVBc3NldElEIE9wdGlvbmFsLiBUaGUgYXNzZXRJRCBvZiB0aGUgZmVlcyBiZWluZyBidXJuZWRcbiAgICogQHBhcmFtIG1lbW8gT3B0aW9uYWwgY29udGFpbnMgYXJiaXRyYXJ5IGJ5dGVzLCB1cCB0byAyNTYgYnl0ZXNcbiAgICogQHBhcmFtIGFzT2YgT3B0aW9uYWwuIFRoZSB0aW1lc3RhbXAgdG8gdmVyaWZ5IHRoZSB0cmFuc2FjdGlvbiBhZ2FpbnN0IGFzIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn1cbiAgICogQHBhcmFtIGNoYW5nZVRocmVzaG9sZCBPcHRpb25hbC4gVGhlIG51bWJlciBvZiBzaWduYXR1cmVzIHJlcXVpcmVkIHRvIHNwZW5kIHRoZSBmdW5kcyBpbiB0aGUgcmVzdWx0YW50IGNoYW5nZSBVVFhPXG4gICAqXG4gICAqIEByZXR1cm5zIEFuIHVuc2lnbmVkIFJlZ2lzdGVyTm9kZVR4IGNyZWF0ZWQgZnJvbSB0aGUgcGFzc2VkIGluIHBhcmFtZXRlcnMuXG4gICAqL1xuICBidWlsZFJlZ2lzdGVyTm9kZVR4ID0gYXN5bmMgKFxuICAgIG5ldHdvcmtJRDogbnVtYmVyID0gRGVmYXVsdE5ldHdvcmtJRCxcbiAgICBibG9ja2NoYWluSUQ6IEJ1ZmZlcixcbiAgICBmcm9tU2lnbmVyOiBGcm9tU2lnbmVyLFxuICAgIGNoYW5nZUFkZHJlc3NlczogQnVmZmVyW10sXG4gICAgb2xkTm9kZUlEOiBCdWZmZXIgPSB1bmRlZmluZWQsXG4gICAgbmV3Tm9kZUlEOiBCdWZmZXIgPSB1bmRlZmluZWQsXG4gICAgYWRkcmVzczogQnVmZmVyID0gdW5kZWZpbmVkLFxuICAgIGFkZHJlc3NBdXRoczogW251bWJlciwgQnVmZmVyXVtdID0gW10sXG4gICAgZmVlOiBCTiA9IHplcm8sXG4gICAgZmVlQXNzZXRJRDogQnVmZmVyID0gdW5kZWZpbmVkLFxuICAgIG1lbW86IEJ1ZmZlciA9IHVuZGVmaW5lZCxcbiAgICBhc09mOiBCTiA9IHplcm8sXG4gICAgY2hhbmdlVGhyZXNob2xkOiBudW1iZXIgPSAxXG4gICk6IFByb21pc2U8VW5zaWduZWRUeD4gPT4ge1xuICAgIGxldCBpbnM6IFRyYW5zZmVyYWJsZUlucHV0W10gPSBbXVxuICAgIGxldCBvdXRzOiBUcmFuc2ZlcmFibGVPdXRwdXRbXSA9IFtdXG4gICAgbGV0IG93bmVyczogT3V0cHV0T3duZXJzW10gPSBbXVxuXG4gICAgaWYgKHRoaXMuX2ZlZUNoZWNrKGZlZSwgZmVlQXNzZXRJRCkpIHtcbiAgICAgIGNvbnN0IGFhZDogQXNzZXRBbW91bnREZXN0aW5hdGlvbiA9IG5ldyBBc3NldEFtb3VudERlc3RpbmF0aW9uKFxuICAgICAgICBbXSxcbiAgICAgICAgMCxcbiAgICAgICAgZnJvbVNpZ25lci5mcm9tLFxuICAgICAgICBmcm9tU2lnbmVyLnNpZ25lcixcbiAgICAgICAgY2hhbmdlQWRkcmVzc2VzLFxuICAgICAgICBjaGFuZ2VUaHJlc2hvbGRcbiAgICAgIClcblxuICAgICAgYWFkLmFkZEFzc2V0QW1vdW50KGZlZUFzc2V0SUQsIHplcm8sIGZlZSlcblxuICAgICAgY29uc3QgbWluU3BlbmRhYmxlRXJyOiBFcnJvciA9IGF3YWl0IHRoaXMuc3BlbmRlci5nZXRNaW5pbXVtU3BlbmRhYmxlKFxuICAgICAgICBhYWQsXG4gICAgICAgIGFzT2YsXG4gICAgICAgIHplcm8sXG4gICAgICAgIFwiVW5sb2NrZWRcIlxuICAgICAgKVxuICAgICAgaWYgKHR5cGVvZiBtaW5TcGVuZGFibGVFcnIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaW5zID0gYWFkLmdldElucHV0cygpXG4gICAgICAgIG91dHMgPSBhYWQuZ2V0QWxsT3V0cHV0cygpXG4gICAgICAgIG93bmVycyA9IGFhZC5nZXRPdXRwdXRPd25lcnMoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbWluU3BlbmRhYmxlRXJyXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYmFzZVR4OiBSZWdpc3Rlck5vZGVUeCA9IG5ldyBSZWdpc3Rlck5vZGVUeChcbiAgICAgIG5ldHdvcmtJRCxcbiAgICAgIGJsb2NrY2hhaW5JRCxcbiAgICAgIG91dHMsXG4gICAgICBpbnMsXG4gICAgICBtZW1vLFxuICAgICAgb2xkTm9kZUlELFxuICAgICAgbmV3Tm9kZUlELFxuICAgICAgYWRkcmVzc1xuICAgIClcblxuICAgIGFkZHJlc3NBdXRocy5mb3JFYWNoKChhZGRyZXNzQXV0aCkgPT4ge1xuICAgICAgYmFzZVR4LmFkZFNpZ25hdHVyZUlkeChhZGRyZXNzQXV0aFswXSwgYWRkcmVzc0F1dGhbMV0pXG4gICAgfSlcblxuICAgIG93bmVycy5wdXNoKFxuICAgICAgbmV3Tm9kZUlEICYmICFvbGROb2RlSURcbiAgICAgICAgPyBuZXcgT3V0cHV0T3duZXJzKFtuZXdOb2RlSURdLCBaZXJvQk4sIDEpXG4gICAgICAgIDogbmV3IE91dHB1dE93bmVycygpXG4gICAgKVxuICAgIG93bmVycy5wdXNoKG5ldyBPdXRwdXRPd25lcnMoW2FkZHJlc3NdLCBaZXJvQk4sIDEpKVxuXG4gICAgYmFzZVR4LnNldE91dHB1dE93bmVycyhvd25lcnMpXG4gICAgcmV0dXJuIG5ldyBVbnNpZ25lZFR4KGJhc2VUeClcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZCBhbiB1bnNpZ25lZCBbW0RlcG9zaXRUeF1dLlxuICAgKlxuICAgKiBAcGFyYW0gdmVyc2lvbiBPcHRpb25hbC4gVHJhbnNhY3Rpb24gdmVyc2lvbiBudW1iZXIsIGRlZmF1bHQgMC5cbiAgICogQHBhcmFtIG5ldHdvcmtJRCBOZXR3b3JraWQsIFtbRGVmYXVsdE5ldHdvcmtJRF1dXG4gICAqIEBwYXJhbSBibG9ja2NoYWluSUQgQmxvY2tjaGFpbmlkLCBkZWZhdWx0IHVuZGVmaW5lZFxuICAgKiBAcGFyYW0gZnJvbVNpZ25lciBUaGUgYWRkcmVzc2VzIGJlaW5nIHVzZWQgdG8gc2VuZCBhbmQgdmVyaWZ5IHRoZSBmdW5kcyBmcm9tIHRoZSBVVFhPcyB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfVxuICAgKiBAcGFyYW0gY2hhbmdlQWRkcmVzc2VzIFRoZSBhZGRyZXNzZXMgdGhhdCBjYW4gc3BlbmQgdGhlIGNoYW5nZSByZW1haW5pbmcgZnJvbSB0aGUgc3BlbnQgVVRYT3MuXG4gICAqIEBwYXJhbSBkZXBvc2l0T2ZmZXJJRCBJRCBvZiB0aGUgZGVwb3NpdCBvZmZlci5cbiAgICogQHBhcmFtIGRlcG9zaXREdXJhdGlvbiBEdXJhdGlvbiBvZiB0aGUgZGVwb3NpdFxuICAgKiBAcGFyYW0gcmV3YXJkc093bmVyIE9wdGlvbmFsIFRoZSBvd25lcnMgb2YgdGhlIHJld2FyZC4gSWYgb21pdHRlZCwgYWxsIGlucHV0cyBtdXN0IGhhdmUgdGhlIHNhbWUgb3duZXJcbiAgICogQHBhcmFtIGRlcG9zaXRDcmVhdG9yQWRkcmVzcyBBZGRyZXNzIHRoYXQgaXMgYXV0aG9yaXplZCB0byBjcmVhdGUgZGVwb3NpdCB3aXRoIGdpdmVuIG9mZmVyLiBDb3VsZCBiZSBlbXB0eSwgaWYgb2ZmZXIgb3duZXIgaXMgZW1wdHkuXG4gICAqIEBwYXJhbSBkZXBvc2l0Q3JlYXRvckF1dGggQXV0aCBmb3IgZGVwb3NpdCBjcmVhdG9yIGFkZHJlc3NcbiAgICogQHBhcmFtIGRlcG9zaXRPZmZlck93bmVyU2lncyBTaWduYXR1cmVzIHdoaWNoIHJlY292ZXIgdG8gZGVwb3NpdE9mZmVyT3duZXIgYWRkcmVzcyhlcylcbiAgICogQHBhcmFtIGRlcG9zaXRPZmZlck93bmVyQXV0aCBBdXRoIGZvciBkZXBvc2l0IG9mZmVyIG93bmVyXG4gICAqIEBwYXJhbSBmZWUgT3B0aW9uYWwuIFRoZSBhbW91bnQgb2YgZmVlcyB0byBidXJuIGluIGl0cyBzbWFsbGVzdCBkZW5vbWluYXRpb24sIHJlcHJlc2VudGVkIGFzIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcy98Qk59XG4gICAqIEBwYXJhbSBmZWVBc3NldElEIE9wdGlvbmFsLiBUaGUgYXNzZXRJRCBvZiB0aGUgZmVlcyBiZWluZyBidXJuZWRcbiAgICogQHBhcmFtIG1lbW8gT3B0aW9uYWwgY29udGFpbnMgYXJiaXRyYXJ5IGJ5dGVzLCB1cCB0byAyNTYgYnl0ZXNcbiAgICogQHBhcmFtIGFzT2YgT3B0aW9uYWwuIFRoZSB0aW1lc3RhbXAgdG8gdmVyaWZ5IHRoZSB0cmFuc2FjdGlvbiBhZ2FpbnN0IGFzIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn1cbiAgICogQHBhcmFtIGNoYW5nZVRocmVzaG9sZCBPcHRpb25hbC4gVGhlIG51bWJlciBvZiBzaWduYXR1cmVzIHJlcXVpcmVkIHRvIHNwZW5kIHRoZSBmdW5kcyBpbiB0aGUgcmVzdWx0YW50IGNoYW5nZSBVVFhPXG4gICAqXG4gICAqIEByZXR1cm5zIEFuIHVuc2lnbmVkIERlcG9zaXRUeCBjcmVhdGVkIGZyb20gdGhlIHBhc3NlZCBpbiBwYXJhbWV0ZXJzLlxuICAgKi9cbiAgYnVpbGREZXBvc2l0VHggPSBhc3luYyAoXG4gICAgdmVyc2lvbjogbnVtYmVyID0gRGVmYXVsdFRyYW5zYWN0aW9uVmVyc2lvbk51bWJlcixcbiAgICBuZXR3b3JrSUQ6IG51bWJlciA9IERlZmF1bHROZXR3b3JrSUQsXG4gICAgYmxvY2tjaGFpbklEOiBCdWZmZXIsXG4gICAgZnJvbVNpZ25lcjogRnJvbVNpZ25lcixcbiAgICBjaGFuZ2VBZGRyZXNzZXM6IEJ1ZmZlcltdLFxuICAgIGRlcG9zaXRPZmZlcklEOiBCdWZmZXIsXG4gICAgZGVwb3NpdER1cmF0aW9uOiBudW1iZXIsXG4gICAgcmV3YXJkc093bmVyOiBPdXRwdXRPd25lcnMsXG4gICAgZGVwb3NpdENyZWF0b3JBZGRyZXNzOiBCdWZmZXIgPSB1bmRlZmluZWQsXG4gICAgZGVwb3NpdENyZWF0b3JBdXRoOiBbbnVtYmVyLCBCdWZmZXJdW10gPSBbXSxcbiAgICBkZXBvc2l0T2ZmZXJPd25lclNpZ3M6IEJ1ZmZlcltdID0gW10sXG4gICAgZGVwb3NpdE9mZmVyT3duZXJBdXRoOiBbbnVtYmVyLCBCdWZmZXJdW10gPSBbXSxcbiAgICBmZWU6IEJOID0gemVybyxcbiAgICBmZWVBc3NldElEOiBCdWZmZXIgPSB1bmRlZmluZWQsXG4gICAgbWVtbzogQnVmZmVyID0gdW5kZWZpbmVkLFxuICAgIGFzT2Y6IEJOID0gemVybyxcbiAgICBhbW91bnRUb0xvY2s6IEJOLFxuICAgIGNoYW5nZVRocmVzaG9sZDogbnVtYmVyID0gMSxcbiAgICB0bzogQnVmZmVyW10gPSBbXSxcbiAgICB0b1RocmVzaG9sZDogbnVtYmVyID0gMFxuICApOiBQcm9taXNlPFVuc2lnbmVkVHg+ID0+IHtcbiAgICBsZXQgaW5zOiBUcmFuc2ZlcmFibGVJbnB1dFtdID0gW11cbiAgICBsZXQgb3V0czogVHJhbnNmZXJhYmxlT3V0cHV0W10gPSBbXVxuICAgIGxldCBvd25lcnM6IE91dHB1dE93bmVyc1tdID0gW11cblxuICAgIGlmICh0aGlzLl9mZWVDaGVjayhmZWUsIGZlZUFzc2V0SUQpKSB7XG4gICAgICBjb25zdCBhYWQ6IEFzc2V0QW1vdW50RGVzdGluYXRpb24gPSBuZXcgQXNzZXRBbW91bnREZXN0aW5hdGlvbihcbiAgICAgICAgdG8sXG4gICAgICAgIHRvVGhyZXNob2xkLFxuICAgICAgICBmcm9tU2lnbmVyLmZyb20sXG4gICAgICAgIGZyb21TaWduZXIuc2lnbmVyLFxuICAgICAgICBjaGFuZ2VBZGRyZXNzZXMsXG4gICAgICAgIGNoYW5nZVRocmVzaG9sZFxuICAgICAgKVxuXG4gICAgICBhYWQuYWRkQXNzZXRBbW91bnQoZmVlQXNzZXRJRCwgYW1vdW50VG9Mb2NrLCBmZWUpXG5cbiAgICAgIGNvbnN0IG1pblNwZW5kYWJsZUVycjogRXJyb3IgPSBhd2FpdCB0aGlzLnNwZW5kZXIuZ2V0TWluaW11bVNwZW5kYWJsZShcbiAgICAgICAgYWFkLFxuICAgICAgICBhc09mLFxuICAgICAgICB6ZXJvLFxuICAgICAgICBcIkRlcG9zaXRcIlxuICAgICAgKVxuICAgICAgaWYgKHR5cGVvZiBtaW5TcGVuZGFibGVFcnIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaW5zID0gYWFkLmdldElucHV0cygpXG4gICAgICAgIG91dHMgPSBhYWQuZ2V0QWxsT3V0cHV0cygpXG4gICAgICAgIG93bmVycyA9IGFhZC5nZXRPdXRwdXRPd25lcnMoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbWluU3BlbmRhYmxlRXJyXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc2VjcE93bmVycyA9IG5ldyBTRUNQT3duZXJPdXRwdXQoXG4gICAgICByZXdhcmRzT3duZXIuZ2V0QWRkcmVzc2VzKCksXG4gICAgICByZXdhcmRzT3duZXI/LmdldExvY2t0aW1lKCksXG4gICAgICByZXdhcmRzT3duZXIuZ2V0VGhyZXNob2xkKClcbiAgICApXG5cbiAgICBjb25zdCBiYXNlVHg6IERlcG9zaXRUeCA9IG5ldyBEZXBvc2l0VHgoXG4gICAgICB2ZXJzaW9uLFxuICAgICAgbmV0d29ya0lELFxuICAgICAgYmxvY2tjaGFpbklELFxuICAgICAgb3V0cyxcbiAgICAgIGlucyxcbiAgICAgIG1lbW8sXG4gICAgICBkZXBvc2l0T2ZmZXJJRCxcbiAgICAgIGRlcG9zaXREdXJhdGlvbixcbiAgICAgIG5ldyBQYXJzZWFibGVPdXRwdXQoc2VjcE93bmVycyksXG4gICAgICBkZXBvc2l0Q3JlYXRvckFkZHJlc3NcbiAgICApXG5cbiAgICBpZiAodmVyc2lvbiA+IDApIHtcbiAgICAgIGJhc2VUeC5hZGREZXBvc2l0Q3JlYXRvckF1dGgoZGVwb3NpdENyZWF0b3JBdXRoKVxuICAgICAgYmFzZVR4LmFkZE93bmVyQXV0aChkZXBvc2l0T2ZmZXJPd25lckF1dGgsIGRlcG9zaXRPZmZlck93bmVyU2lncylcblxuICAgICAgb3duZXJzLnB1c2gobmV3IE91dHB1dE93bmVycyhbZGVwb3NpdENyZWF0b3JBZGRyZXNzXSwgWmVyb0JOLCAxKSlcblxuICAgICAgLy8gQ3JlYXRlIHBzZXVkbyBhZGRyZXNzZXMgZm9yIE11bHRpc2lnLCB0aGV5IGhhdmUgdG8gcGFzc2VkXG4gICAgICAvLyB0byBNdWx0aXNpZ0tleWNoYWluIG9uIGtleWNoYWluIGluaXRpYWxpemF0aW9uXG4gICAgICBjb25zdCBudW1BZGRyZXNzZXMgPVxuICAgICAgICBkZXBvc2l0T2ZmZXJPd25lckF1dGgubGVuZ3RoID4gMFxuICAgICAgICAgID8gZGVwb3NpdE9mZmVyT3duZXJBdXRoLmF0KGRlcG9zaXRPZmZlck93bmVyQXV0aC5sZW5ndGggLSAxKVswXVxuICAgICAgICAgIDogMFxuICAgICAgY29uc3QgYWRkcnM6IEJ1ZmZlcltdID0gW11cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQWRkcmVzc2VzOyArK2kpIHtcbiAgICAgICAgYWRkcnMucHVzaChCdWZmZXIuYWxsb2MoMjApKVxuICAgICAgICBhZGRycy5hdChhZGRycy5sZW5ndGggLSAxKS53cml0ZVVJbnRCRShpICsgMSwgMTYsIDQpXG4gICAgICB9XG4gICAgICBvd25lcnMucHVzaChuZXcgT3V0cHV0T3duZXJzKGFkZHJzLCBaZXJvQk4sIGRlcG9zaXRPZmZlck93bmVyQXV0aC5sZW5ndGgpKVxuICAgIH1cblxuICAgIGJhc2VUeC5zZXRPdXRwdXRPd25lcnMob3duZXJzKVxuICAgIHJldHVybiBuZXcgVW5zaWduZWRUeChiYXNlVHgpXG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgYW4gdW5zaWduZWQgW1tVbmxvY2tEZXBvc2l0VHhdXS5cbiAgICpcbiAgICogQHBhcmFtIG5ldHdvcmtJRCBOZXR3b3JraWQsIFtbRGVmYXVsdE5ldHdvcmtJRF1dXG4gICAqIEBwYXJhbSBibG9ja2NoYWluSUQgQmxvY2tjaGFpbmlkLCBkZWZhdWx0IHVuZGVmaW5lZFxuICAgKiBAcGFyYW0gZnJvbVNpZ25lciBAcGFyYW0gZnJvbVNpZ25lciBUaGUgYWRkcmVzc2VzIGJlaW5nIHVzZWQgdG8gc2VuZCBhbmQgdmVyaWZ5IHRoZSBmdW5kcyBmcm9tIHRoZSBVVFhPcyB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfVxuICAgKiBAcGFyYW0gY2hhbmdlQWRkcmVzc2VzIFRoZSBhZGRyZXNzZXMgdGhhdCBjYW4gc3BlbmQgdGhlIGNoYW5nZSByZW1haW5pbmcgZnJvbSB0aGUgc3BlbnQgVVRYT3MuXG4gICAqIEBwYXJhbSBmZWUgT3B0aW9uYWwuIFRoZSBhbW91bnQgb2YgZmVlcyB0byBidXJuIGluIGl0cyBzbWFsbGVzdCBkZW5vbWluYXRpb24sIHJlcHJlc2VudGVkIGFzIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcy98Qk59XG4gICAqIEBwYXJhbSBmZWVBc3NldElEIE9wdGlvbmFsLiBUaGUgYXNzZXRJRCBvZiB0aGUgZmVlcyBiZWluZyBidXJuZWRcbiAgICogQHBhcmFtIG1lbW8gT3B0aW9uYWwgY29udGFpbnMgYXJiaXRyYXJ5IGJ5dGVzLCB1cCB0byAyNTYgYnl0ZXNcbiAgICogQHBhcmFtIGFzT2YgT3B0aW9uYWwuIFRoZSB0aW1lc3RhbXAgdG8gdmVyaWZ5IHRoZSB0cmFuc2FjdGlvbiBhZ2FpbnN0IGFzIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn1cbiAgICogQHBhcmFtIGNoYW5nZVRocmVzaG9sZCBPcHRpb25hbC4gVGhlIG51bWJlciBvZiBzaWduYXR1cmVzIHJlcXVpcmVkIHRvIHNwZW5kIHRoZSBmdW5kcyBpbiB0aGUgcmVzdWx0YW50IGNoYW5nZSBVVFhPXG4gICAqXG4gICAqIEByZXR1cm5zIEFuIHVuc2lnbmVkIFVubG9ja0RlcG9zaXRUeCBjcmVhdGVkIGZyb20gdGhlIHBhc3NlZCBpbiBwYXJhbWV0ZXJzLlxuICAgKi9cbiAgYnVpbGRVbmxvY2tEZXBvc2l0VHggPSBhc3luYyAoXG4gICAgbmV0d29ya0lEOiBudW1iZXIgPSBEZWZhdWx0TmV0d29ya0lELFxuICAgIGJsb2NrY2hhaW5JRDogQnVmZmVyLFxuICAgIGZyb21TaWduZXI6IEZyb21TaWduZXIsXG4gICAgY2hhbmdlQWRkcmVzc2VzOiBCdWZmZXJbXSxcbiAgICBmZWU6IEJOID0gemVybyxcbiAgICBmZWVBc3NldElEOiBCdWZmZXIgPSB1bmRlZmluZWQsXG4gICAgbWVtbzogQnVmZmVyID0gdW5kZWZpbmVkLFxuICAgIGFzT2Y6IEJOID0gemVybyxcbiAgICBjaGFuZ2VUaHJlc2hvbGQ6IG51bWJlciA9IDFcbiAgKTogUHJvbWlzZTxVbnNpZ25lZFR4PiA9PiB7XG4gICAgbGV0IGluczogVHJhbnNmZXJhYmxlSW5wdXRbXSA9IFtdXG4gICAgbGV0IG91dHM6IFRyYW5zZmVyYWJsZU91dHB1dFtdID0gW11cblxuICAgIGlmICh0aGlzLl9mZWVDaGVjayhmZWUsIGZlZUFzc2V0SUQpKSB7XG4gICAgICBjb25zdCBhYWQ6IEFzc2V0QW1vdW50RGVzdGluYXRpb24gPSBuZXcgQXNzZXRBbW91bnREZXN0aW5hdGlvbihcbiAgICAgICAgW10sXG4gICAgICAgIDAsXG4gICAgICAgIGZyb21TaWduZXIuZnJvbSxcbiAgICAgICAgZnJvbVNpZ25lci5zaWduZXIsXG4gICAgICAgIGNoYW5nZUFkZHJlc3NlcyxcbiAgICAgICAgY2hhbmdlVGhyZXNob2xkXG4gICAgICApXG5cbiAgICAgIGFhZC5hZGRBc3NldEFtb3VudChmZWVBc3NldElELCB6ZXJvLCBmZWUpXG5cbiAgICAgIGNvbnN0IG1pblNwZW5kYWJsZUVycjogRXJyb3IgPSBhd2FpdCB0aGlzLnNwZW5kZXIuZ2V0TWluaW11bVNwZW5kYWJsZShcbiAgICAgICAgYWFkLFxuICAgICAgICBhc09mLFxuICAgICAgICB6ZXJvLFxuICAgICAgICBcIlVubG9ja2VkXCJcbiAgICAgIClcbiAgICAgIGlmICh0eXBlb2YgbWluU3BlbmRhYmxlRXJyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlucyA9IGFhZC5nZXRJbnB1dHMoKVxuICAgICAgICBvdXRzID0gYWFkLmdldEFsbE91dHB1dHMoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbWluU3BlbmRhYmxlRXJyXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdW5sb2NrRGVwb3NpdFR4OiBVbmxvY2tEZXBvc2l0VHggPSBuZXcgVW5sb2NrRGVwb3NpdFR4KFxuICAgICAgbmV0d29ya0lELFxuICAgICAgYmxvY2tjaGFpbklELFxuICAgICAgb3V0cyxcbiAgICAgIGlucyxcbiAgICAgIG1lbW9cbiAgICApXG5cbiAgICByZXR1cm4gbmV3IFVuc2lnbmVkVHgodW5sb2NrRGVwb3NpdFR4KVxuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkIGFuIHVuc2lnbmVkIFtbQ2xhaW1UeF1dLlxuICAgKlxuICAgKiBAcGFyYW0gbmV0d29ya0lEIE5ldHdvcmtJRCwgW1tEZWZhdWx0TmV0d29ya0lEXV1cbiAgICogQHBhcmFtIGJsb2NrY2hhaW5JRCBCbG9ja2NoYWluSUQsIGRlZmF1bHQgdW5kZWZpbmVkXG4gICAqIEBwYXJhbSBmcm9tU2lnbmVyIEBwYXJhbSBmcm9tU2lnbmVyIFRoZSBhZGRyZXNzZXMgYmVpbmcgdXNlZCB0byBzZW5kIGFuZCB2ZXJpZnkgdGhlIGZ1bmRzIGZyb20gdGhlIFVUWE9zIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9XG4gICAqIEBwYXJhbSBjaGFuZ2VBZGRyZXNzZXMgVGhlIGFkZHJlc3NlcyB0aGF0IGNhbiBzcGVuZCB0aGUgY2hhbmdlIHJlbWFpbmluZyBmcm9tIHRoZSBzcGVudCBVVFhPcy5cbiAgICogQHBhcmFtIGZlZSBPcHRpb25hbC4gVGhlIGFtb3VudCBvZiBmZWVzIHRvIGJ1cm4gaW4gaXRzIHNtYWxsZXN0IGRlbm9taW5hdGlvbiwgcmVwcmVzZW50ZWQgYXMge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn1cbiAgICogQHBhcmFtIGZlZUFzc2V0SUQgT3B0aW9uYWwuIFRoZSBhc3NldElEIG9mIHRoZSBmZWVzIGJlaW5nIGJ1cm5lZFxuICAgKiBAcGFyYW0gbWVtbyBPcHRpb25hbCBjb250YWlucyBhcmJpdHJhcnkgYnl0ZXMsIHVwIHRvIDI1NiBieXRlc1xuICAgKiBAcGFyYW0gYXNPZiBPcHRpb25hbC4gVGhlIHRpbWVzdGFtcCB0byB2ZXJpZnkgdGhlIHRyYW5zYWN0aW9uIGFnYWluc3QgYXMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfVxuICAgKiBAcGFyYW0gY2hhbmdlVGhyZXNob2xkIE9wdGlvbmFsLiBUaGUgbnVtYmVyIG9mIHNpZ25hdHVyZXMgcmVxdWlyZWQgdG8gc3BlbmQgdGhlIGZ1bmRzIGluIHRoZSByZXN1bHRhbnQgY2hhbmdlIFVUWE9cbiAgICogQHBhcmFtIGNsYWltQW1vdW50cyBUaGUgc3BlY2lmaWNhdGlvbiBhbmQgYXV0aGVudGljYXRpb24gd2hhdCBhbmQgaG93IG11Y2ggdG8gY2xhaW1cbiAgICogQHBhcmFtIGNsYWltVG8gVGhlIGFkZHJlc3MgdG8gY2xhaW1lZCByZXdhcmRzIHdpbGwgYmUgZGlyZWN0ZWQgdG9cbiAgICpcbiAgICogQHJldHVybnMgQW4gdW5zaWduZWQgQ2xhaW1UeCBjcmVhdGVkIGZyb20gdGhlIHBhc3NlZCBpbiBwYXJhbWV0ZXJzLlxuICAgKi9cbiAgYnVpbGRDbGFpbVR4ID0gYXN5bmMgKFxuICAgIG5ldHdvcmtJRDogbnVtYmVyID0gRGVmYXVsdE5ldHdvcmtJRCxcbiAgICBibG9ja2NoYWluSUQ6IEJ1ZmZlcixcbiAgICBmcm9tU2lnbmVyOiBGcm9tU2lnbmVyLFxuICAgIGNoYW5nZUFkZHJlc3NlczogQnVmZmVyW10sXG4gICAgZmVlOiBCTiA9IHplcm8sXG4gICAgZmVlQXNzZXRJRDogQnVmZmVyID0gdW5kZWZpbmVkLFxuICAgIG1lbW86IEJ1ZmZlciA9IHVuZGVmaW5lZCxcbiAgICBhc09mOiBCTiA9IHplcm8sXG4gICAgY2hhbmdlVGhyZXNob2xkOiBudW1iZXIgPSAxLFxuICAgIGNsYWltQW1vdW50czogQ2xhaW1BbW91bnRQYXJhbXNbXSxcbiAgICBjbGFpbVRvOiBPdXRwdXRPd25lcnMgPSB1bmRlZmluZWRcbiAgKTogUHJvbWlzZTxVbnNpZ25lZFR4PiA9PiB7XG4gICAgbGV0IGluczogVHJhbnNmZXJhYmxlSW5wdXRbXSA9IFtdXG4gICAgbGV0IG91dHM6IFRyYW5zZmVyYWJsZU91dHB1dFtdID0gW11cbiAgICBsZXQgb3duZXJzOiBPdXRwdXRPd25lcnNbXSA9IFtdXG5cbiAgICBpZiAodGhpcy5fZmVlQ2hlY2soZmVlLCBmZWVBc3NldElEKSkge1xuICAgICAgY29uc3QgYWFkOiBBc3NldEFtb3VudERlc3RpbmF0aW9uID0gbmV3IEFzc2V0QW1vdW50RGVzdGluYXRpb24oXG4gICAgICAgIFtdLFxuICAgICAgICAwLFxuICAgICAgICBmcm9tU2lnbmVyLmZyb20sXG4gICAgICAgIGZyb21TaWduZXIuc2lnbmVyLFxuICAgICAgICBjaGFuZ2VBZGRyZXNzZXMsXG4gICAgICAgIGNoYW5nZVRocmVzaG9sZFxuICAgICAgKVxuXG4gICAgICBhYWQuYWRkQXNzZXRBbW91bnQoZmVlQXNzZXRJRCwgemVybywgZmVlKVxuXG4gICAgICBjb25zdCBtaW5TcGVuZGFibGVFcnI6IEVycm9yID0gYXdhaXQgdGhpcy5zcGVuZGVyLmdldE1pbmltdW1TcGVuZGFibGUoXG4gICAgICAgIGFhZCxcbiAgICAgICAgYXNPZixcbiAgICAgICAgemVybyxcbiAgICAgICAgXCJVbmxvY2tlZFwiXG4gICAgICApXG4gICAgICBpZiAodHlwZW9mIG1pblNwZW5kYWJsZUVyciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpbnMgPSBhYWQuZ2V0SW5wdXRzKClcbiAgICAgICAgb3V0cyA9IGFhZC5nZXRBbGxPdXRwdXRzKClcbiAgICAgICAgb3duZXJzID0gYWFkLmdldE91dHB1dE93bmVycygpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBtaW5TcGVuZGFibGVFcnJcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiBDb21wYWN0IGlmIHBvc3NpYmxlXG4gICAgY29uc3QgdHhDbGFpbUFtb3VudHM6IENsYWltQW1vdW50W10gPSBbXVxuICAgIGNvbnN0IGFsbFNpZ0lkeHM6IFNpZ0lkeFtdW10gPSBbXVxuICAgIGZvciAoY29uc3QgYW10IG9mIGNsYWltQW1vdW50cykge1xuICAgICAgY29uc3QgcmVjZWl2ZXIgPSBjbGFpbVRvID8gY2xhaW1UbyA6IGFtdC5vd25lcnNcbiAgICAgIG91dHMucHVzaChcbiAgICAgICAgbmV3IFRyYW5zZmVyYWJsZU91dHB1dChcbiAgICAgICAgICBmZWVBc3NldElELFxuICAgICAgICAgIG5ldyBTRUNQVHJhbnNmZXJPdXRwdXQoXG4gICAgICAgICAgICBhbXQuYW1vdW50LFxuICAgICAgICAgICAgcmVjZWl2ZXIuZ2V0QWRkcmVzc2VzKCksXG4gICAgICAgICAgICByZWNlaXZlci5nZXRMb2NrdGltZSgpLFxuICAgICAgICAgICAgcmVjZWl2ZXIuZ2V0VGhyZXNob2xkKClcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIClcbiAgICAgIGxldCBpZCA9IGFtdC5pZFxuICAgICAgaWYgKCFpZCkge1xuICAgICAgICBpZiAoYW10LmNsYWltVHlwZSA9PT0gQ2xhaW1UeXBlLkFDVElWRV9ERVBPU0lUX1JFV0FSRClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDbGFpbUFtb3VudCBpZCBtdXN0IGJlIHNldFwiKVxuICAgICAgICBjb25zdCBiID0gQnVmZmVyLmFsbG9jKDIsIFBsYXRmb3JtVk1Db25zdGFudHMuTEFURVNUQ09ERUMpXG4gICAgICAgIGlkID0gQnVmZmVyLmZyb20oXG4gICAgICAgICAgY3JlYXRlSGFzaChcInNoYTI1NlwiKVxuICAgICAgICAgICAgLnVwZGF0ZShCdWZmZXIuY29uY2F0KFtiLCBhbXQub3duZXJzLnRvQnVmZmVyKCldKSlcbiAgICAgICAgICAgIC5kaWdlc3QoKVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBTaWdJZHhzXG4gICAgICBpZiAoYW10LnNpZ0lkeHMubGVuZ3RoICE9PSBhbXQub3duZXJzLmdldFRocmVzaG9sZCgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaWdJZHggY291bnQgbWlzbWF0Y2hcIilcbiAgICAgIGNvbnN0IHNpZ0lkeHM6IFNpZ0lkeFtdID0gW11cbiAgICAgIGNvbnN0IGFkZHJzID0gYW10Lm93bmVycy5nZXRBZGRyZXNzZXMoKVxuICAgICAgZm9yIChjb25zdCBpZHggb2YgYW10LnNpZ0lkeHMpIHtcbiAgICAgICAgaWYgKGlkeCA+PSBhZGRycy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcihcIlNpZ0lkeCBvdXQgb2YgYm91bmRcIilcbiAgICAgICAgc2lnSWR4cy5wdXNoKG5ldyBTaWdJZHgoaWR4LCBhZGRyc1tpZHhdKSlcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIGF1dGggZm9yIHZlcmlmaWNhdGlvbiBvZiBjbGFpbUFtb3VudCBvd25lclxuICAgICAgY29uc3QgYnVmZmVyU2lnSWR4cyA9IHNpZ0lkeHMubWFwKChzKSA9PiBzLmdldEJ5dGVzKCkpXG5cbiAgICAgIHR4Q2xhaW1BbW91bnRzLnB1c2goXG4gICAgICAgIG5ldyBDbGFpbUFtb3VudChpZCwgYW10LmNsYWltVHlwZSwgYW10LmFtb3VudCwgYnVmZmVyU2lnSWR4cylcbiAgICAgIClcbiAgICAgIGFsbFNpZ0lkeHMucHVzaChzaWdJZHhzKVxuICAgICAgb3duZXJzLnB1c2goYW10Lm93bmVycylcbiAgICB9XG5cbiAgICBjb25zdCBjbGFpbVR4OiBDbGFpbVR4ID0gbmV3IENsYWltVHgoXG4gICAgICBuZXR3b3JrSUQsXG4gICAgICBibG9ja2NoYWluSUQsXG4gICAgICBvdXRzLFxuICAgICAgaW5zLFxuICAgICAgbWVtbyxcbiAgICAgIHR4Q2xhaW1BbW91bnRzXG4gICAgKVxuXG4gICAgLy8gQnVpbGQgc2lnbmF0dXJlSW5kaWNlc1xuICAgIGZvciAoY29uc3QgcyBvZiBhbGxTaWdJZHhzKSBjbGFpbVR4LmFkZFNpZ0lkeHMocylcblxuICAgIGNsYWltVHguc2V0T3V0cHV0T3duZXJzKG93bmVycylcbiAgICByZXR1cm4gbmV3IFVuc2lnbmVkVHgoY2xhaW1UeClcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZCBhbiB1bnNpZ25lZCBbW011bHRpc2lnQWxpYXNUeF1dLlxuICAgKlxuICAgKiBAcGFyYW0gbmV0d29ya0lEIE5ldHdvcmsgSUQsIGRlZmF1bHQgW1tEZWZhdWx0TmV0d29ya0lEXV1cbiAgICogQHBhcmFtIGJsb2NrY2hhaW5JRCBCbG9ja2NoYWluIElELCBkZWZhdWx0IHVuZGVmaW5lZFxuICAgKiBAcGFyYW0gZnJvbVNpZ25lciBUaGUgYWRkcmVzc2VzIGJlaW5nIHVzZWQgdG8gc2VuZCBhbmQgdmVyaWZ5IHRoZSBmdW5kcyBmcm9tIHRoZSBVVFhPc1xuICAgKiBAcGFyYW0gY2hhbmdlQWRkcmVzc2VzIFRoZSBhZGRyZXNzZXMgdGhhdCBjYW4gc3BlbmQgdGhlIGNoYW5nZSByZW1haW5pbmcgZnJvbSB0aGUgc3BlbnQgVVRYT3NcbiAgICogQHBhcmFtIG11bHRpc2lnQWxpYXNQYXJhbXMgUGFyYW1ldGVycyBvZiBNdWx0aXNpZ0FsaWFzVHguIG11bHRpc2lnQWxpYXNQYXJhbXMuSUQgbXVzdCBiZSBlbXB0eSBpZiBpdCdzIHRoZSBuZXcgYWxpYXNcbiAgICogQHBhcmFtIGZlZSBPcHRpb25hbCBhbW91bnQgb2YgZmVlcyB0byBidXJuIGluIGl0cyBzbWFsbGVzdCBkZW5vbWluYXRpb24sIHJlcHJlc2VudGVkIGFzIEJOXG4gICAqIEBwYXJhbSBmZWVBc3NldElEIE9wdGlvbmFsIGFzc2V0IElEIG9mIHRoZSBmZWVzIGJlaW5nIGJ1cm5lZFxuICAgKiBAcGFyYW0gbWVtbyBPcHRpb25hbCBjb250YWlucyBhcmJpdHJhcnkgYnl0ZXMsIHVwIHRvIDI1NiBieXRlc1xuICAgKiBAcGFyYW0gYXNPZiBPcHRpb25hbCB0aW1lc3RhbXAgdG8gdmVyaWZ5IHRoZSB0cmFuc2FjdGlvbiBhZ2FpbnN0LCBhcyBCTlxuICAgKiBAcGFyYW0gY2hhbmdlVGhyZXNob2xkIE9wdGlvbmFsIG51bWJlciBvZiBzaWduYXR1cmVzIHJlcXVpcmVkIHRvIHNwZW5kIHRoZSBmdW5kcyBpbiB0aGUgcmVzdWx0YW50IGNoYW5nZSBVVFhPXG4gICAqXG4gICAqIEByZXR1cm5zIEFuIHVuc2lnbmVkIE11bHRpc2lnQWxpYXNUeCBjcmVhdGVkIGZyb20gdGhlIHBhc3NlZC1pbiBwYXJhbWV0ZXJzLlxuICAgKi9cbiAgYnVpbGRNdWx0aXNpZ0FsaWFzVHggPSBhc3luYyAoXG4gICAgbmV0d29ya0lEOiBudW1iZXIgPSBEZWZhdWx0TmV0d29ya0lELFxuICAgIGJsb2NrY2hhaW5JRDogQnVmZmVyLFxuICAgIGZyb21TaWduZXI6IEZyb21TaWduZXIsXG4gICAgY2hhbmdlQWRkcmVzc2VzOiBCdWZmZXJbXSxcbiAgICBtdWx0aXNpZ0FsaWFzUGFyYW1zOiBNdWx0aXNpZ0FsaWFzUGFyYW1zLFxuICAgIGZlZTogQk4gPSB6ZXJvLFxuICAgIGZlZUFzc2V0SUQ6IEJ1ZmZlciA9IHVuZGVmaW5lZCxcbiAgICBtZW1vOiBCdWZmZXIgPSB1bmRlZmluZWQsXG4gICAgYXNPZjogQk4gPSB6ZXJvLFxuICAgIGNoYW5nZVRocmVzaG9sZDogbnVtYmVyID0gMVxuICApOiBQcm9taXNlPFVuc2lnbmVkVHg+ID0+IHtcbiAgICBsZXQgaW5zOiBUcmFuc2ZlcmFibGVJbnB1dFtdID0gW11cbiAgICBsZXQgb3V0czogVHJhbnNmZXJhYmxlT3V0cHV0W10gPSBbXVxuICAgIGxldCBvd25lcnM6IE91dHB1dE93bmVyc1tdID0gW11cblxuICAgIGlmICh0aGlzLl9mZWVDaGVjayhmZWUsIGZlZUFzc2V0SUQpKSB7XG4gICAgICBjb25zdCBhYWQ6IEFzc2V0QW1vdW50RGVzdGluYXRpb24gPSBuZXcgQXNzZXRBbW91bnREZXN0aW5hdGlvbihcbiAgICAgICAgW10sXG4gICAgICAgIDAsXG4gICAgICAgIGZyb21TaWduZXIuZnJvbSxcbiAgICAgICAgZnJvbVNpZ25lci5zaWduZXIsXG4gICAgICAgIGNoYW5nZUFkZHJlc3NlcyxcbiAgICAgICAgY2hhbmdlVGhyZXNob2xkXG4gICAgICApXG5cbiAgICAgIGFhZC5hZGRBc3NldEFtb3VudChmZWVBc3NldElELCB6ZXJvLCBmZWUpXG5cbiAgICAgIGNvbnN0IG1pblNwZW5kYWJsZUVycjogRXJyb3IgPSBhd2FpdCB0aGlzLnNwZW5kZXIuZ2V0TWluaW11bVNwZW5kYWJsZShcbiAgICAgICAgYWFkLFxuICAgICAgICBhc09mLFxuICAgICAgICB6ZXJvLFxuICAgICAgICBcIlVubG9ja2VkXCJcbiAgICAgIClcbiAgICAgIGlmICh0eXBlb2YgbWluU3BlbmRhYmxlRXJyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlucyA9IGFhZC5nZXRJbnB1dHMoKVxuICAgICAgICBvdXRzID0gYWFkLmdldEFsbE91dHB1dHMoKVxuICAgICAgICBvd25lcnMgPSBhYWQuZ2V0T3V0cHV0T3duZXJzKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG1pblNwZW5kYWJsZUVyclxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG91dHB1dDogU0VDUE93bmVyT3V0cHV0ID0gbmV3IFNFQ1BPd25lck91dHB1dChcbiAgICAgIG11bHRpc2lnQWxpYXNQYXJhbXMub3duZXJzLmdldEFkZHJlc3NlcygpLFxuICAgICAgbXVsdGlzaWdBbGlhc1BhcmFtcy5vd25lcnMuZ2V0TG9ja3RpbWUoKSxcbiAgICAgIG11bHRpc2lnQWxpYXNQYXJhbXMub3duZXJzLmdldFRocmVzaG9sZCgpXG4gICAgKVxuXG4gICAgY29uc3QgbXVsdGlzaWdBbGlhczogTXVsdGlzaWdBbGlhcyA9IG5ldyBNdWx0aXNpZ0FsaWFzKFxuICAgICAgbXVsdGlzaWdBbGlhc1BhcmFtcy5pZCxcbiAgICAgIEJ1ZmZlci5mcm9tKG11bHRpc2lnQWxpYXNQYXJhbXMubWVtbywgXCJ1dGYtOFwiKSxcbiAgICAgIG5ldyBQYXJzZWFibGVPdXRwdXQob3V0cHV0KVxuICAgIClcblxuICAgIGNvbnN0IGJhc2VUeDogTXVsdGlzaWdBbGlhc1R4ID0gbmV3IE11bHRpc2lnQWxpYXNUeChcbiAgICAgIG5ldHdvcmtJRCxcbiAgICAgIGJsb2NrY2hhaW5JRCxcbiAgICAgIG91dHMsXG4gICAgICBpbnMsXG4gICAgICBtZW1vLFxuICAgICAgbXVsdGlzaWdBbGlhc1xuICAgIClcblxuICAgIG11bHRpc2lnQWxpYXNQYXJhbXMuYXV0aC5mb3JFYWNoKChhZGRyZXNzQXV0aCkgPT4ge1xuICAgICAgYmFzZVR4LmFkZFNpZ25hdHVyZUlkeChhZGRyZXNzQXV0aFswXSwgYWRkcmVzc0F1dGhbMV0pXG4gICAgfSlcblxuICAgIGlmIChtdWx0aXNpZ0FsaWFzUGFyYW1zLmlkICYmIG11bHRpc2lnQWxpYXNQYXJhbXMuaWQubGVuZ3RoICE9IDApIHtcbiAgICAgIG93bmVycy5wdXNoKG5ldyBPdXRwdXRPd25lcnMoW211bHRpc2lnQWxpYXNQYXJhbXMuaWRdLCBaZXJvQk4sIDEpKVxuICAgIH1cblxuICAgIGJhc2VUeC5zZXRPdXRwdXRPd25lcnMob3duZXJzKVxuICAgIHJldHVybiBuZXcgVW5zaWduZWRUeChiYXNlVHgpXG4gIH1cblxuICBfZmVlQ2hlY2soZmVlOiBCTiwgZmVlQXNzZXRJRDogQnVmZmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChcbiAgICAgIHR5cGVvZiBmZWUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgIHR5cGVvZiBmZWVBc3NldElEICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICBmZWUuZ3QobmV3IEJOKDApKSAmJlxuICAgICAgZmVlQXNzZXRJRCBpbnN0YW5jZW9mIEJ1ZmZlclxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZCBhbiB1bnNpZ25lZCBbW0FkZERlcG9zaXRPZmZlclR4XV0uXG4gICAqXG4gICAqIEBwYXJhbSBuZXR3b3JrSURcbiAgICogQHBhcmFtIGJsb2NrY2hhaW5JRFxuICAgKiBAcGFyYW0gZnJvbVNpZ25lclxuICAgKiBAcGFyYW0gY2hhbmdlQWRkcmVzc2VzXG4gICAqIEBwYXJhbSBkZXBvc2l0T2ZmZXJcbiAgICogQHBhcmFtIGRlcG9zaXRPZmZlckNyZWF0b3JBZGRyZXNzXG4gICAqIEBwYXJhbSBkZXBvc2l0T2ZmZXJDcmVhdG9yQXV0aFxuICAgKiBAcGFyYW0gZmVlXG4gICAqIEBwYXJhbSBmZWVBc3NldElEXG4gICAqIEBwYXJhbSBtZW1vXG4gICAqIEBwYXJhbSBhc09mXG4gICAqIEBwYXJhbSBjaGFuZ2VUaHJlc2hvbGRcbiAgICovXG4gIGJ1aWxkQWRkRGVwb3NpdE9mZmVyVHggPSBhc3luYyAoXG4gICAgbmV0d29ya0lEOiBudW1iZXIgPSBEZWZhdWx0TmV0d29ya0lELFxuICAgIGJsb2NrY2hhaW5JRDogQnVmZmVyLFxuICAgIGZyb21TaWduZXI6IEZyb21TaWduZXIsXG4gICAgY2hhbmdlQWRkcmVzc2VzOiBCdWZmZXJbXSxcbiAgICBvZmZlcjogT2ZmZXIsXG4gICAgZGVwb3NpdE9mZmVyQ3JlYXRvckFkZHJlc3M6IEJ1ZmZlcixcbiAgICBkZXBvc2l0T2ZmZXJDcmVhdG9yQXV0aDogW251bWJlciwgQnVmZmVyXVtdID0gW10sXG4gICAgZmVlOiBCTiA9IHplcm8sXG4gICAgZmVlQXNzZXRJRDogQnVmZmVyID0gdW5kZWZpbmVkLFxuICAgIG1lbW86IEJ1ZmZlciA9IHVuZGVmaW5lZCxcbiAgICBhc09mOiBCTiA9IHplcm8sXG4gICAgY2hhbmdlVGhyZXNob2xkOiBudW1iZXIgPSAxXG4gICk6IFByb21pc2U8VW5zaWduZWRUeD4gPT4ge1xuICAgIGxldCBpbnM6IFRyYW5zZmVyYWJsZUlucHV0W10gPSBbXVxuICAgIGxldCBvdXRzOiBUcmFuc2ZlcmFibGVPdXRwdXRbXSA9IFtdXG4gICAgbGV0IG93bmVyczogT3V0cHV0T3duZXJzW10gPSBbXVxuXG4gICAgaWYgKHRoaXMuX2ZlZUNoZWNrKGZlZSwgZmVlQXNzZXRJRCkpIHtcbiAgICAgIGNvbnN0IGFhZDogQXNzZXRBbW91bnREZXN0aW5hdGlvbiA9IG5ldyBBc3NldEFtb3VudERlc3RpbmF0aW9uKFxuICAgICAgICBbXSxcbiAgICAgICAgMCxcbiAgICAgICAgZnJvbVNpZ25lci5mcm9tLFxuICAgICAgICBmcm9tU2lnbmVyLnNpZ25lcixcbiAgICAgICAgY2hhbmdlQWRkcmVzc2VzLFxuICAgICAgICBjaGFuZ2VUaHJlc2hvbGRcbiAgICAgIClcblxuICAgICAgYWFkLmFkZEFzc2V0QW1vdW50KGZlZUFzc2V0SUQsIHplcm8sIGZlZSlcblxuICAgICAgY29uc3QgbWluU3BlbmRhYmxlRXJyOiBFcnJvciA9IGF3YWl0IHRoaXMuc3BlbmRlci5nZXRNaW5pbXVtU3BlbmRhYmxlKFxuICAgICAgICBhYWQsXG4gICAgICAgIGFzT2YsXG4gICAgICAgIHplcm8sXG4gICAgICAgIFwiVW5sb2NrZWRcIlxuICAgICAgKVxuICAgICAgaWYgKHR5cGVvZiBtaW5TcGVuZGFibGVFcnIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaW5zID0gYWFkLmdldElucHV0cygpXG4gICAgICAgIG91dHMgPSBhYWQuZ2V0QWxsT3V0cHV0cygpXG4gICAgICAgIG93bmVycyA9IGFhZC5nZXRPdXRwdXRPd25lcnMoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbWluU3BlbmRhYmxlRXJyXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYmFzZVR4OiBBZGREZXBvc2l0T2ZmZXJUeCA9IG5ldyBBZGREZXBvc2l0T2ZmZXJUeChcbiAgICAgIG5ldHdvcmtJRCxcbiAgICAgIGJsb2NrY2hhaW5JRCxcbiAgICAgIG91dHMsXG4gICAgICBpbnMsXG4gICAgICBtZW1vLFxuICAgICAgb2ZmZXIsXG4gICAgICBkZXBvc2l0T2ZmZXJDcmVhdG9yQWRkcmVzc1xuICAgIClcblxuICAgIGRlcG9zaXRPZmZlckNyZWF0b3JBdXRoLmZvckVhY2goKHNpZ25lcik6IHZvaWQgPT4ge1xuICAgICAgYmFzZVR4LmFkZFNpZ25hdHVyZUlkeChzaWduZXJbMF0sIHNpZ25lclsxXSlcbiAgICB9KVxuXG4gICAgb3duZXJzLnB1c2gobmV3IE91dHB1dE93bmVycyhbZGVwb3NpdE9mZmVyQ3JlYXRvckFkZHJlc3NdLCBaZXJvQk4sIDEpKVxuXG4gICAgYmFzZVR4LnNldE91dHB1dE93bmVycyhvd25lcnMpXG4gICAgcmV0dXJuIG5ldyBVbnNpZ25lZFR4KGJhc2VUeClcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZCBhbiB1bnNpZ25lZCBbW0FkZFByb3Bvc2FsVHhdXS5cbiAgICpcbiAgICogQHBhcmFtIG5ldHdvcmtJRCBOZXR3b3JraWQsIFtbRGVmYXVsdE5ldHdvcmtJRF1dXG4gICAqIEBwYXJhbSBibG9ja2NoYWluSUQgQmxvY2tjaGFpbmlkLCBkZWZhdWx0IHVuZGVmaW5lZFxuICAgKiBAcGFyYW0gZnJvbVNpZ25lciBUaGUgYWRkcmVzc2VzIGJlaW5nIHVzZWQgdG8gc2VuZCBhbmQgdmVyaWZ5IHRoZSBmdW5kcyBmcm9tIHRoZSBVVFhPcyB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfVxuICAgKiBAcGFyYW0gY2hhbmdlQWRkcmVzc2VzIFRoZSBhZGRyZXNzZXMgdGhhdCBjYW4gc3BlbmQgdGhlIGNoYW5nZSByZW1haW5pbmcgZnJvbSB0aGUgc3BlbnQgVVRYT3MuXG4gICAqIEBwYXJhbSBwcm9wb3NhbERlc2NyaXB0aW9uIE9wdGlvbmFsIGNvbnRhaW5zIGFyYml0cmFyeSBieXRlcywgdXAgdG8gMjU2IGJ5dGVzXG4gICAqIEBwYXJhbSBwcm9wb3NhbCBUaGUgcHJvcG9zYWwgY29udGVudCB0aGF0IHdpbGwgYmUgY3JlYXRlZC5cbiAgICogQHBhcmFtIHByb3Bvc2VyQWRkcmVzcyBUaGUgUC1hZGRyZXNzIG9mIHByb3Bvc2VyIGluIEJ1ZmZlci5cbiAgICogQHBhcmFtIHByb3Bvc2VyQXV0aCBBdXRoIGZvciBwcm9wb3NlciBhZGRyZXNzXG4gICAqIEBwYXJhbSB2ZXJzaW9uIE9wdGlvbmFsLiBUcmFuc2FjdGlvbiB2ZXJzaW9uIG51bWJlciwgZGVmYXVsdCAwLlxuICAgKiBAcGFyYW0gbWVtbyBPcHRpb25hbCBjb250YWlucyBhcmJpdHJhcnkgYnl0ZXMsIHVwIHRvIDI1NiBieXRlc1xuICAgKiBAcGFyYW0gZmVlIE9wdGlvbmFsLiBUaGUgYW1vdW50IG9mIGZlZXMgdG8gYnVybiBpbiBpdHMgc21hbGxlc3QgZGVub21pbmF0aW9uLCByZXByZXNlbnRlZCBhcyB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfVxuICAgKiBAcGFyYW0gZmVlQXNzZXRJRCBPcHRpb25hbC4gVGhlIGFzc2V0SUQgb2YgdGhlIGZlZXMgYmVpbmcgYnVybmVkXG4gICAqIEBwYXJhbSBhc09mIE9wdGlvbmFsLiBUaGUgdGltZXN0YW1wIHRvIHZlcmlmeSB0aGUgdHJhbnNhY3Rpb24gYWdhaW5zdCBhcyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcy98Qk59XG4gICAqIEBwYXJhbSBzdGFrZUFtb3VudCBBIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcy98Qk59IGZvciB0aGUgYW1vdW50IG9mIHN0YWtlIHRvIGJlIGRlbGVnYXRlZCBpbiBuQVZBWC5cbiAgICogQHBhcmFtIHN0YWtlQXNzZXRJRFxuICAgKiBAcGFyYW0gdG9UaHJlc2hvbGQgT3B0aW9uYWwuIFRoZSBudW1iZXIgb2Ygc2lnbmF0dXJlcyByZXF1aXJlZCB0byBzcGVuZCB0aGUgZnVuZHMgaW4gdGhlIHJlc3VsdGFudCBVVFhPXG4gICAqIEBwYXJhbSBjaGFuZ2VUaHJlc2hvbGQgT3B0aW9uYWwuIFRoZSBudW1iZXIgb2Ygc2lnbmF0dXJlcyByZXF1aXJlZCB0byBzcGVuZCB0aGUgZnVuZHMgaW4gdGhlIHJlc3VsdGFudCBjaGFuZ2UgVVRYT1xuICAgKlxuICAgKiBAcmV0dXJucyBBbiB1bnNpZ25lZCBBZGRQcm9wb3NhbFR4IGNyZWF0ZWQgZnJvbSB0aGUgcGFzc2VkIGluIHBhcmFtZXRlcnMuXG4gICAqL1xuICBidWlsZEFkZFByb3Bvc2FsVHggPSBhc3luYyAoXG4gICAgbmV0d29ya0lEOiBudW1iZXIgPSBEZWZhdWx0TmV0d29ya0lELFxuICAgIGJsb2NrY2hhaW5JRDogQnVmZmVyLFxuICAgIGZyb21TaWduZXI6IEZyb21TaWduZXIsXG4gICAgY2hhbmdlQWRkcmVzc2VzOiBCdWZmZXJbXSxcbiAgICBwcm9wb3NhbERlc2NyaXB0aW9uOiBCdWZmZXIsXG4gICAgcHJvcG9zYWw6IFByb3Bvc2FsID0gdW5kZWZpbmVkLFxuICAgIHByb3Bvc2VyQWRkcmVzczogQnVmZmVyID0gdW5kZWZpbmVkLFxuICAgIHByb3Bvc2VyQXV0aCA9IHVuZGVmaW5lZCxcbiAgICB2ZXJzaW9uOiBudW1iZXIgPSBEZWZhdWx0VHJhbnNhY3Rpb25WZXJzaW9uTnVtYmVyLFxuICAgIG1lbW86IEJ1ZmZlciA9IHVuZGVmaW5lZCxcbiAgICBmZWU6IEJOID0gemVybyxcbiAgICBmZWVBc3NldElEOiBCdWZmZXIgPSB1bmRlZmluZWQsXG4gICAgYXNPZjogQk4gPSB6ZXJvLFxuICAgIHN0YWtlQW1vdW50OiBCTiA9IHplcm8sXG4gICAgc3Rha2VBc3NldElEOiBCdWZmZXIsXG4gICAgdG9UaHJlc2hvbGQ6IG51bWJlciA9IDEsXG4gICAgY2hhbmdlVGhyZXNob2xkOiBudW1iZXIgPSAxXG4gICk6IFByb21pc2U8VW5zaWduZWRUeD4gPT4ge1xuICAgIGxldCBpbnM6IFRyYW5zZmVyYWJsZUlucHV0W10gPSBbXVxuICAgIGxldCBvdXRzOiBUcmFuc2ZlcmFibGVPdXRwdXRbXSA9IFtdXG4gICAgbGV0IG93bmVyczogT3V0cHV0T3duZXJzW10gPSBbXVxuXG4gICAgaWYgKHRoaXMuX2ZlZUNoZWNrKGZlZSwgZmVlQXNzZXRJRCkpIHtcbiAgICAgIGNvbnN0IGFhZDogQXNzZXRBbW91bnREZXN0aW5hdGlvbiA9IG5ldyBBc3NldEFtb3VudERlc3RpbmF0aW9uKFxuICAgICAgICBbXSxcbiAgICAgICAgdG9UaHJlc2hvbGQsXG4gICAgICAgIGZyb21TaWduZXIuZnJvbSxcbiAgICAgICAgZnJvbVNpZ25lci5zaWduZXIsXG4gICAgICAgIGNoYW5nZUFkZHJlc3NlcyxcbiAgICAgICAgY2hhbmdlVGhyZXNob2xkXG4gICAgICApXG4gICAgICBhYWQuYWRkQXNzZXRBbW91bnQoc3Rha2VBc3NldElELCBzdGFrZUFtb3VudCwgZmVlKVxuXG4gICAgICBjb25zdCBtaW5TcGVuZGFibGVFcnI6IEVycm9yID0gYXdhaXQgdGhpcy5zcGVuZGVyLmdldE1pbmltdW1TcGVuZGFibGUoXG4gICAgICAgIGFhZCxcbiAgICAgICAgYXNPZixcbiAgICAgICAgemVybyxcbiAgICAgICAgXCJCb25kXCJcbiAgICAgIClcbiAgICAgIGlmICh0eXBlb2YgbWluU3BlbmRhYmxlRXJyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlucyA9IGFhZC5nZXRJbnB1dHMoKVxuICAgICAgICBvdXRzID0gYWFkLmdldEFsbE91dHB1dHMoKVxuICAgICAgICBvd25lcnMgPSBhYWQuZ2V0T3V0cHV0T3duZXJzKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG1pblNwZW5kYWJsZUVyclxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGJhc2VUeDogQWRkUHJvcG9zYWxUeCA9IG5ldyBBZGRQcm9wb3NhbFR4KFxuICAgICAgdmVyc2lvbixcbiAgICAgIG5ldHdvcmtJRCxcbiAgICAgIGJsb2NrY2hhaW5JRCxcbiAgICAgIG91dHMsXG4gICAgICBpbnMsXG4gICAgICBtZW1vLFxuICAgICAgcHJvcG9zYWxEZXNjcmlwdGlvbixcbiAgICAgIHByb3Bvc2FsLFxuICAgICAgcHJvcG9zZXJBZGRyZXNzLFxuICAgICAgcHJvcG9zZXJBdXRoXG4gICAgKVxuICAgIG93bmVycy5wdXNoKG5ldyBPdXRwdXRPd25lcnMoW3Byb3Bvc2VyQWRkcmVzc10sIFplcm9CTiwgMSkpXG4gICAgYmFzZVR4LnNldE91dHB1dE93bmVycyhvd25lcnMpXG4gICAgcmV0dXJuIG5ldyBVbnNpZ25lZFR4KGJhc2VUeClcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZCBhbiB1bnNpZ25lZCBbW0FkZFZvdGVUeF1dLlxuICAgKlxuICAgKiBAcGFyYW0gbmV0d29ya0lEIE5ldHdvcmtpZCwgW1tEZWZhdWx0TmV0d29ya0lEXV1cbiAgICogQHBhcmFtIGJsb2NrY2hhaW5JRCBCbG9ja2NoYWluaWQsIGRlZmF1bHQgdW5kZWZpbmVkXG4gICAqIEBwYXJhbSBmcm9tU2lnbmVyIFRoZSBhZGRyZXNzZXMgYmVpbmcgdXNlZCB0byBzZW5kIGFuZCB2ZXJpZnkgdGhlIGZ1bmRzIGZyb20gdGhlIFVUWE9zIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9XG4gICAqIEBwYXJhbSBjaGFuZ2VBZGRyZXNzZXMgVGhlIGFkZHJlc3NlcyB0aGF0IGNhbiBzcGVuZCB0aGUgY2hhbmdlIHJlbWFpbmluZyBmcm9tIHRoZSBzcGVudCBVVFhPcy5cbiAgICogQHBhcmFtIHByb3Bvc2FsSUQgVGhlIHByb3Bvc2FsSUQgb2YgdGVoIHByb3Bvc2FsIGluIEJ1ZmZlclxuICAgKiBAcGFyYW0gdm90ZU9wdGlvbkluZGV4IFRoZSBpbmRleCBvZiB2b3RlIG9wdGlvbi5cbiAgICogQHBhcmFtIHZvdGVyQWRkcmVzcyBUaGUgUC1hZGRyZXNzIG9mIHZvdGVyIGluIEJ1ZmZlci5cbiAgICogQHBhcmFtIHZvdGVyQXV0aCBBdXRoIGZvciB2b3RlciBhZGRyZXNzXG4gICAqIEBwYXJhbSB2ZXJzaW9uIE9wdGlvbmFsLiBUcmFuc2FjdGlvbiB2ZXJzaW9uIG51bWJlciwgZGVmYXVsdCAwLlxuICAgKiBAcGFyYW0gbWVtbyBPcHRpb25hbCBjb250YWlucyBhcmJpdHJhcnkgYnl0ZXMsIHVwIHRvIDI1NiBieXRlc1xuICAgKiBAcGFyYW0gZmVlIE9wdGlvbmFsLiBUaGUgYW1vdW50IG9mIGZlZXMgdG8gYnVybiBpbiBpdHMgc21hbGxlc3QgZGVub21pbmF0aW9uLCByZXByZXNlbnRlZCBhcyB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfVxuICAgKiBAcGFyYW0gZmVlQXNzZXRJRCBPcHRpb25hbC4gVGhlIGFzc2V0SUQgb2YgdGhlIGZlZXMgYmVpbmcgYnVybmVkXG4gICAqIEBwYXJhbSBhc09mIE9wdGlvbmFsLiBUaGUgdGltZXN0YW1wIHRvIHZlcmlmeSB0aGUgdHJhbnNhY3Rpb24gYWdhaW5zdCBhcyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcy98Qk59XG4gICAqIEBwYXJhbSBjaGFuZ2VUaHJlc2hvbGQgT3B0aW9uYWwuIFRoZSBudW1iZXIgb2Ygc2lnbmF0dXJlcyByZXF1aXJlZCB0byBzcGVuZCB0aGUgZnVuZHMgaW4gdGhlIHJlc3VsdGFudCBjaGFuZ2UgVVRYT1xuICAgKlxuICAgKiBAcmV0dXJucyBBbiB1bnNpZ25lZCBBZGRWb3RlVHggY3JlYXRlZCBmcm9tIHRoZSBwYXNzZWQgaW4gcGFyYW1ldGVycy5cbiAgICovXG4gIGJ1aWxkQWRkVm90ZVR4ID0gYXN5bmMgKFxuICAgIG5ldHdvcmtJRDogbnVtYmVyID0gRGVmYXVsdE5ldHdvcmtJRCxcbiAgICBibG9ja2NoYWluSUQ6IEJ1ZmZlcixcbiAgICBmcm9tU2lnbmVyOiBGcm9tU2lnbmVyLFxuICAgIGNoYW5nZUFkZHJlc3NlczogQnVmZmVyW10sXG4gICAgcHJvcG9zYWxJRDogQnVmZmVyID0gdW5kZWZpbmVkLFxuICAgIHZvdGVPcHRpb25JbmRleDogbnVtYmVyID0gdW5kZWZpbmVkLFxuICAgIHZvdGVyQWRkcmVzczogQnVmZmVyID0gdW5kZWZpbmVkLFxuICAgIHZvdGVyQXV0aCA9IHVuZGVmaW5lZCxcbiAgICB2ZXJzaW9uOiBudW1iZXIgPSBEZWZhdWx0VHJhbnNhY3Rpb25WZXJzaW9uTnVtYmVyLFxuICAgIG1lbW86IEJ1ZmZlciA9IHVuZGVmaW5lZCxcbiAgICBmZWU6IEJOID0gemVybyxcbiAgICBmZWVBc3NldElEOiBCdWZmZXIgPSB1bmRlZmluZWQsXG4gICAgYXNPZjogQk4gPSB6ZXJvLFxuICAgIGNoYW5nZVRocmVzaG9sZDogbnVtYmVyID0gMVxuICApOiBQcm9taXNlPFVuc2lnbmVkVHg+ID0+IHtcbiAgICBsZXQgaW5zOiBUcmFuc2ZlcmFibGVJbnB1dFtdID0gW11cbiAgICBsZXQgb3V0czogVHJhbnNmZXJhYmxlT3V0cHV0W10gPSBbXVxuICAgIGxldCBvd25lcnM6IE91dHB1dE93bmVyc1tdID0gW11cblxuICAgIGlmICh0aGlzLl9mZWVDaGVjayhmZWUsIGZlZUFzc2V0SUQpKSB7XG4gICAgICBjb25zdCBhYWQ6IEFzc2V0QW1vdW50RGVzdGluYXRpb24gPSBuZXcgQXNzZXRBbW91bnREZXN0aW5hdGlvbihcbiAgICAgICAgW10sXG4gICAgICAgIDAsXG4gICAgICAgIGZyb21TaWduZXIuZnJvbSxcbiAgICAgICAgZnJvbVNpZ25lci5zaWduZXIsXG4gICAgICAgIGNoYW5nZUFkZHJlc3NlcyxcbiAgICAgICAgY2hhbmdlVGhyZXNob2xkXG4gICAgICApXG4gICAgICBhYWQuYWRkQXNzZXRBbW91bnQoZmVlQXNzZXRJRCwgemVybywgZmVlKVxuXG4gICAgICBjb25zdCBtaW5TcGVuZGFibGVFcnI6IEVycm9yID0gYXdhaXQgdGhpcy5zcGVuZGVyLmdldE1pbmltdW1TcGVuZGFibGUoXG4gICAgICAgIGFhZCxcbiAgICAgICAgYXNPZixcbiAgICAgICAgemVybyxcbiAgICAgICAgXCJVbmxvY2tlZFwiXG4gICAgICApXG4gICAgICBpZiAodHlwZW9mIG1pblNwZW5kYWJsZUVyciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpbnMgPSBhYWQuZ2V0SW5wdXRzKClcbiAgICAgICAgb3V0cyA9IGFhZC5nZXRBbGxPdXRwdXRzKClcbiAgICAgICAgb3duZXJzID0gYWFkLmdldE91dHB1dE93bmVycygpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBtaW5TcGVuZGFibGVFcnJcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBiYXNlVHg6IEFkZFZvdGVUeCA9IG5ldyBBZGRWb3RlVHgoXG4gICAgICB2ZXJzaW9uLFxuICAgICAgbmV0d29ya0lELFxuICAgICAgYmxvY2tjaGFpbklELFxuICAgICAgb3V0cyxcbiAgICAgIGlucyxcbiAgICAgIG1lbW8sXG4gICAgICBwcm9wb3NhbElELFxuICAgICAgdm90ZU9wdGlvbkluZGV4LFxuICAgICAgdm90ZXJBZGRyZXNzLFxuICAgICAgdm90ZXJBdXRoXG4gICAgKVxuXG4gICAgb3duZXJzLnB1c2gobmV3IE91dHB1dE93bmVycyhbdm90ZXJBZGRyZXNzXSwgWmVyb0JOLCAxKSlcbiAgICBiYXNlVHguc2V0T3V0cHV0T3duZXJzKG93bmVycylcbiAgICByZXR1cm4gbmV3IFVuc2lnbmVkVHgoYmFzZVR4KVxuICB9XG59XG4iXX0=